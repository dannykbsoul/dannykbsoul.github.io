<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="变量类型和类型转换JS 变量类型JS中有 6 种原始值，分别是：  boolean number string undefined symbol null  引用类型：  对象 数组 函数">
<meta property="og:type" content="article">
<meta property="og:title" content="JS基础总结">
<meta property="og:url" content="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="ZJ&#39;s BLOG">
<meta property="og:description" content="变量类型和类型转换JS 变量类型JS中有 6 种原始值，分别是：  boolean number string undefined symbol null  引用类型：  对象 数组 函数">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/6.png">
<meta property="og:image" content="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/7.png">
<meta property="og:image" content="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/2.png">
<meta property="og:image" content="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/5.png">
<meta property="og:image" content="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/1.png">
<meta property="og:image" content="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/3.png">
<meta property="og:image" content="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/4.png">
<meta property="og:image" content="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/8.jpg">
<meta property="article:published_time" content="2020-02-28T08:52:35.000Z">
<meta property="article:modified_time" content="2020-02-29T07:56:53.501Z">
<meta property="article:author" content="Zhou Jun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/6.png">

<link rel="canonical" href="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>JS基础总结 | ZJ's BLOG</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?815037cb536c1fda6d297b7d52905c8a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZJ's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/dannykbsoul" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JS基础总结<a href="https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name_posts/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93.md" class="post-edit-link" title="Edit this post" rel="noopener" target="_blank"><i class="fa fa-pencil"></i></a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-28 16:52:35" itemprop="dateCreated datePublished" datetime="2020-02-28T16:52:35+08:00">2020-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-29 15:56:53" itemprop="dateModified" datetime="2020-02-29T15:56:53+08:00">2020-02-29</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>30 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="变量类型和类型转换"><a href="#变量类型和类型转换" class="headerlink" title="变量类型和类型转换"></a>变量类型和类型转换</h1><h2 id="JS-变量类型"><a href="#JS-变量类型" class="headerlink" title="JS 变量类型"></a>JS 变量类型</h2><p>JS中有 6 种原始值，分别是：</p>
<ol>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>undefined</li>
<li>symbol</li>
<li>null</li>
</ol>
<p>引用类型：</p>
<ol>
<li>对象</li>
<li>数组</li>
<li>函数</li>
</ol>
<a id="more"></a>

<h2 id="JS中使用typeof能得到哪些类型？"><a href="#JS中使用typeof能得到哪些类型？" class="headerlink" title="JS中使用typeof能得到哪些类型？"></a>JS中使用typeof能得到哪些类型？</h2><p>其中一个奇怪的 null，虽然是基本变量，但是因为设计的时候<code>null</code>是全0，而对象是<code>000</code>开头，所以有这个误判。</p>
<ol>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>undefined</li>
<li>symbol</li>
<li><strong>object</strong></li>
<li><strong>function</strong></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">bigint</a></li>
</ol>
<h2 id="instanceof-能正确判断对象的原理是什么？"><a href="#instanceof-能正确判断对象的原理是什么？" class="headerlink" title="instanceof 能正确判断对象的原理是什么？"></a>instanceof 能正确判断对象的原理是什么？</h2><p>判断一个对象与构造函数是否在一个原型链上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>)</span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对于原始类型来说，你想直接通过 <code>instanceof</code> 来判断类型是不行的，当然我们还是有办法让 <code>instanceof</code> 判断原始类型的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class PrimitiveString &#123;</span><br><span class="line">  static [Symbol.hasInstance](x) &#123;</span><br><span class="line">    return typeof x &#x3D;&#x3D;&#x3D; &#39;string&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;hello world&#39; instanceof PrimitiveString) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>你可能不知道 <code>Symbol.hasInstance</code> 是什么东西，其实就是一个能让我们自定义 <code>instanceof</code> 行为的东西，以上代码等同于 <code>typeof &#39;hello world&#39; === &#39;string&#39;</code>，所以结果自然是 <code>true</code> 了。这其实也侧面反映了一个问题， <code>instanceof</code> 也不是百分之百可信的。</p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><blockquote>
<p>能检测出object、undefined、string、number、boolean、function,但对于object下的细分不能够识别</p>
</blockquote>
<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><blockquote>
<p>When the toString method is called, the following steps are taken:</p>
</blockquote>
<blockquote>
<ol>
<li>If the <strong>this</strong> value is <strong>undefined</strong>, return “<strong>[object Undefined]</strong>“.</li>
<li>If the <strong>this</strong> value is <strong>null</strong>, return “<strong>[object Null]</strong>“.</li>
<li>Let <em>O</em> be the result of calling ToObject passing the <strong>this</strong> value as the argument.</li>
<li>Let <em>class</em> be the value of the [[Class]] internal property of <em>O</em>.</li>
<li>Return the String value that is the result of concatenating the three Strings “<strong>[object</strong> “, <em>class</em>, and “<strong>]</strong>“.</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是11种：</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">1</span>;          <span class="comment">// [object Number]</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'123'</span>;      <span class="comment">// [object String]</span></span><br><span class="line"><span class="keyword">var</span> boolean = <span class="literal">true</span>;      <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="keyword">var</span> und = <span class="literal">undefined</span>;     <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="keyword">var</span> nul = <span class="literal">null</span>;          <span class="comment">// [object Null]</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;         <span class="comment">// [object Object]</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   <span class="comment">// [object Array]</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();   <span class="comment">// [object Date]</span></span><br><span class="line"><span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// [object Error]</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;          <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// [object Function]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>[i]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func)</span><br></pre></td></tr></table></figure>

<p>除了以上 11 种之外，还有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>)); <span class="comment">// [object Math]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>)); <span class="comment">// [object JSON]</span></span><br></pre></td></tr></table></figure>

<p>除了以上 13 种之外，还有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>)); <span class="comment">// [object Arguments]</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>所以我们可以识别至少 14 种类型，当然我们也可以算出来，[[class]] 属性至少有 12 个。</p>
<p><img src="/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/6.png" alt></p>
<h2 id="实现一个类型判断函数"><a href="#实现一个类型判断函数" class="headerlink" title="实现一个类型判断函数"></a>实现一个类型判断函数</h2><ol>
<li>判断null</li>
<li>判断基本类型</li>
<li>使用Object.prototype.toString.call(target)来判断<strong>引用类型</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//先处理最特殊的null</span></span><br><span class="line">    <span class="keyword">if</span>(target === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'null'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是基本类型</span></span><br><span class="line">    <span class="keyword">const</span> typeOfT = <span class="keyword">typeof</span> target</span><br><span class="line">    <span class="keyword">if</span>(typeOfT !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> typeOfT</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//肯定是引用类型</span></span><br><span class="line">    <span class="keyword">const</span> template = &#123;</span><br><span class="line">        <span class="string">"[object Object]"</span>: <span class="string">"object"</span>,</span><br><span class="line">        <span class="string">"[object Array]"</span>: <span class="string">"array"</span>,</span><br><span class="line">        <span class="comment">//一些包装类型</span></span><br><span class="line">        <span class="string">"[object String]"</span>: <span class="string">"object - string"</span>,</span><br><span class="line">        <span class="string">"[object Number]"</span>: <span class="string">"object - number"</span>,</span><br><span class="line">        <span class="string">"[object Boolean]"</span>: <span class="string">"object - boolean"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> typeStr = <span class="built_in">Object</span>.prototype.toString.call(target)</span><br><span class="line">    <span class="keyword">return</span> template[typeStr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转Boolean</h2><p>以下都为假值，其他所有值都转为 true，包括所有对象（空对象，空数组也转为真）。</p>
<ul>
<li>false</li>
<li>undfined</li>
<li>null</li>
<li>‘’</li>
<li>NaN</li>
<li>0</li>
<li>-0</li>
</ul>
<h2 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h2><p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下：</p>
<ul>
<li>如果已经是原始类型了，那就不需要转换了</li>
<li>如果需要转字符串类型就调用 <code>x.toString()</code>，转换为基础类型的话就返回转换的值。不是字符串类型的话就先调用 <code>valueOf</code>，结果不是基础类型的话再调用 <code>toString</code></li>
<li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li>
<li>如果都没有返回原始类型，就会报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + a           <span class="comment">// 1</span></span><br><span class="line"><span class="string">'1'</span>.concat(a)   <span class="comment">//"11"</span></span><br></pre></td></tr></table></figure>

<p>也可以重写 <code>Symbol.toPrimitive</code> ，该方法在转基本类型时调用<strong>优先级最高</strong>。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive" target="_blank" rel="noopener">Symbol.toPrimitive</a> 指将被调用的指定函数值的属性转换为相对应的原始值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(+object1);</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> + a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li>
<li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment">// '11'</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// "41,2,3"</span></span><br></pre></td></tr></table></figure>

<p>还需要注意这个表达式<code>&#39;a&#39; + + &#39;b&#39;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> + + <span class="string">'b'</span> <span class="comment">// -&gt; "aNaN"</span></span><br></pre></td></tr></table></figure>

<p>因为 + ‘b’ 等于 NaN，所以结果为 “aNaN”，你可能也会在一些代码中看到过 + ‘1’ 的形式来快速获取 number 类型。</p>
<p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> * <span class="string">'3'</span> <span class="comment">// 12</span></span><br><span class="line"><span class="number">4</span> * [] <span class="comment">// 0</span></span><br><span class="line"><span class="number">4</span> * [<span class="number">1</span>, <span class="number">2</span>] <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ol>
<li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li>
<li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a &gt; <span class="number">-1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在以上代码中，因为 <code>a</code> 是对象，所以会通过 <code>valueOf</code> 转换为原始类型再比较值。</p>
<h2 id="100-问题"><a href="#100-问题" class="headerlink" title="100 + 问题"></a><code>100 +</code> 问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'100'</span> + <span class="number">100</span>   <span class="comment">// "100100"</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> + <span class="string">'100'</span>   <span class="comment">// "100100"</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> + <span class="literal">true</span>    <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> + <span class="literal">false</span>   <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> + <span class="literal">undefined</span> <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> + <span class="literal">null</span>    <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h2 id="“a-common-string”为什么会有length属性"><a href="#“a-common-string”为什么会有length属性" class="headerlink" title="“a common string”为什么会有length属性"></a>“a common string”为什么会有length属性</h2><p>通过字面量的方式创建：var a = ‘string’;，这时它就是基本类型值；通过构造函数的方式创建：var a = new String(‘string’);这时它是对象类型。</p>
<p>基本类型是没有属性和方法的，但仍然可以使用对象才有的属性方法。这时因为在对基本类型使用属性方法的时候，后台会隐式的创建这个基本类型的对象，之后再销毁这个对象</p>
<h2 id="console-log-new-Boolean-false-输出什么-易混淆"><a href="#console-log-new-Boolean-false-输出什么-易混淆" class="headerlink" title="console.log(!!(new Boolean(false))输出什么 [易混淆]"></a>console.log(!!(new Boolean(false))输出什么 [易混淆]</h2><p>true   布尔的包装对象 Boolean 的对象实例，对象只有在 null 与 undefined 时，才会认定为布尔的 false 值，布尔包装对象本身是个对象，对象-&gt;布尔 都是 true，所以 new Boolean(false)其实是布尔的 true，看下面这段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))&#123;</span><br><span class="line">    alert(<span class="string">'true!!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有使用了 valueOf 后才是真正的转换布尔值，与上面包装对象与原始资料转换说明的相同:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!!(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))  <span class="comment">//true</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)).valueOf() <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="vs"><a href="#vs" class="headerlink" title="== vs ==="></a>== vs ===</h2><h3 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a>== 操作符</h3><ol>
<li>首先会判断两者类型是否相同。相同的话就是比大小了</li>
<li>类型不相同的话，那么就会进行类型转换</li>
<li>会先判断是否在对比 null 和 undefined，是的话就会返回 true</li>
<li>判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number</li>
<li>判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断</li>
<li>判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断</li>
<li>两边都是对象的话，那么只要不是同一对象的不同引用，都为false</li>
</ol>
<p>只要出现NaN，就一定是false，因为就连NaN自己都不等于NaN 对于NaN，判断的方法是使用全局函数 <code>isNaN()</code></p>
<p><img src="/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/7.png" alt></p>
<h3 id="操作符-1"><a href="#操作符-1" class="headerlink" title="=== 操作符"></a>=== 操作符</h3><p>不转类型，直接判断类型和值是否相同。 但是 NaN === NaN 还是false</p>
<h3 id="等于true还是false"><a href="#等于true还是false" class="headerlink" title="{} 等于true还是false"></a>{} 等于true还是false</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a == <span class="literal">true</span> <span class="comment">// -&gt; ?</span></span><br><span class="line">a == <span class="literal">false</span> <span class="comment">// -&gt; ?</span></span><br></pre></td></tr></table></figure>

<p>答案是两个都为false 因为a.toString() -&gt; ‘[object Object]’ -&gt; NaN</p>
<p>但是一般情况下对象的toString方法都被重写了，所以在判断类型的时候都会调用Object.prototype.toString.call()</p>
<h3 id="1-与-Number-1-有什么区别"><a href="#1-与-Number-1-有什么区别" class="headerlink" title="1 与 Number(1)有什么区别"></a>1 与 Number(1)有什么区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)  <span class="comment">// Number &#123;[[PrimitiveValue]]: 1&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> (a) <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> (b) <span class="comment">// object</span></span><br><span class="line">a == b <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>var a = 1 是一个常量，而 Number(1)是一个函数</li>
<li>new Number(1)返回的是一个对象</li>
<li>a==b 为 true 是因为所以在求值过程中，总是会强制转为原始数据类型而非对象，例如下面的代码:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// "object"</span></span><br><span class="line"><span class="number">123</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>)) <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">123</span> === <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title="[]==![]"></a>[]==![]</h3><ol>
<li>根据运算符优先级 ，！ 的优先级是大于 == 的，所以先会执行 ![]，！可将变量转换成boolean类型，null、undefined、NaN以及空字符串(‘’)取反都为true，其余都为false。所以 ! [] 运算后的结果就是 false，也就是 [] == ! [] 相当于 [] == false</li>
<li>根据上面提到的规则（如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1），则需要把 false 转成 0，也就是 [] == ! [] 相当于 [] == false 相当于 [] == 0</li>
<li>根据上面提到的规则（如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较，如果对象没有valueOf()方法，则调用 toString()）而对于空数组，[].toString() -&gt;  ‘’ (返回的是空字符串)也就是  [] == 0 相当于 ‘’ == 0</li>
<li>根据上面提到的规则（如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值）Number(‘’) -&gt; 返回的是 0，相当于 0 == 0 自然就返回 true了</li>
</ol>
<p>总结一下：</p>
<p>[] == ! []   -&gt;   [] == false  -&gt;  [] == 0  -&gt;   ‘’ == 0   -&gt;  0 == 0   -&gt;  true </p>
<p>那么对于 {} == !{} 也是同理的</p>
<p>关键在于  {}.toString() -&gt;   ‘[object Object]’ -&gt; NaN(返回的是NaN)</p>
<p>根据上面的规则（如果有一个操作数是NaN，则相等操作符返回 false）</p>
<p>总结一下：</p>
<p>{} == ! {}   -&gt;   {} == false  -&gt;  {} == 0  -&gt;   NaN == 0    -&gt;  false</p>
<h3 id="输出以下代码运行结果"><a href="#输出以下代码运行结果" class="headerlink" title="输出以下代码运行结果"></a>输出以下代码运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 + &quot;1&quot;</span><br><span class="line"></span><br><span class="line">2 * &quot;2&quot;</span><br><span class="line"></span><br><span class="line">[1, 2] + [2, 1]</span><br><span class="line"></span><br><span class="line">&quot;a&quot; + + &quot;b&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>1 + “1”<ul>
<li>加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来</li>
<li>所以值为：“11”</li>
</ul>
</li>
<li>2 * “2”<ul>
<li>乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值</li>
</ul>
</li>
<li>[1, 2] + [2, 1]<ul>
<li>Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法。</li>
<li>所以两个数组对象的toString方法相加，值为：”1,22,1”</li>
</ul>
</li>
<li>“a” + + “b”<ul>
<li>后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。</li>
<li>所以值为：”aNaN”</li>
</ul>
</li>
</ul>
<h2 id="如何判断一个数据是不是Array"><a href="#如何判断一个数据是不是Array" class="headerlink" title="如何判断一个数据是不是Array"></a>如何判断一个数据是不是Array</h2><ul>
<li><pre><code>Array.isArray(obj)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - ECMAScript 5种的函数，当使用ie8的时候就会出现问题。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
obj instanceof Array
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 当用来检测在不同的window或iframe里构造的数组时会失败。这是因为每一个iframe都有它自己的执行环境，彼此之间并不共享原型链，所以此时的判断一个对象是否为数组就会失败。此时我们有一个更好的方式去判断一个对象是否为数组。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
Object.prototype.toString.call(obj) == &apos;[object Array]&apos;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 这个方法比较靠谱</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
obj.constructor === Array
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - constructor属性返回对创建此对象的函数的引用</span><br><span class="line"></span><br><span class="line">## Object.prototype.toString</span><br><span class="line"></span><br><span class="line">如果是原始类型，他会将原始类型包装为引用类型，然后调用对应方法</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;JS</span><br><span class="line">function dd()&#123;&#125;</span><br><span class="line">var toString &#x3D; Object.prototype.toString;</span><br><span class="line">toString.call(dd);          &#x2F;&#x2F;[object Function]</span><br><span class="line">toString.call(new Object);  &#x2F;&#x2F;[object Object]</span><br><span class="line">toString.call(new Array);   &#x2F;&#x2F;[object Array]</span><br><span class="line">toString.call(new Date);    &#x2F;&#x2F;[object Date]</span><br><span class="line">toString.call(new String);  &#x2F;&#x2F;[object String]</span><br><span class="line">toString.call(Math);        &#x2F;&#x2F;[object Math]</span><br><span class="line">toString.call(undefined);   &#x2F;&#x2F;[object Undefined]</span><br><span class="line">toString.call(null);        &#x2F;&#x2F;[object Null]</span><br><span class="line">toString.call(123)          &#x2F;&#x2F;[object Number]</span><br><span class="line">toString.call(&#39;abc&#39;)        &#x2F;&#x2F;[object String]</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<h2 id="obj-toString-和Object-prototype-toString-call-obj"><a href="#obj-toString-和Object-prototype-toString-call-obj" class="headerlink" title="obj.toString() 和Object.prototype.toString.call(obj)"></a>obj.toString() 和Object.prototype.toString.call(obj)</h2><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p>
<p>这是因为toString为Object的原型方法，而Array ，function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…..），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。</p>
<h2 id="对象引用问题-1"><a href="#对象引用问题-1" class="headerlink" title="对象引用问题 - 1"></a>对象引用问题 - 1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x) 	<span class="comment">// --&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x)  <span class="comment">// --&gt; &#123;n: 2&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>优先级</strong>。<code>.</code>的优先级高于<code>=</code>，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。</li>
<li><strong>赋值操作是从右到左</strong>，所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2}</li>
</ol>
<h2 id="对象引用问题-2"><a href="#对象引用问题-2" class="headerlink" title="对象引用问题 - 2"></a>对象引用问题 - 2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeObjProperty</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.siteUrl = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">  o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.siteUrl = <span class="string">"http://www.google.com"</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> webSite = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">changeObjProperty(webSite);</span><br><span class="line"><span class="built_in">console</span>.log(webSite.siteUrl);</span><br></pre></td></tr></table></figure>

<p>答案： “<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com</a>“ 原因： o = new Object() 这句代码切断了原本对 o 的引用</p>
<h2 id="‘1’-‘2’-‘3’-map-parseInt-答案是多少？"><a href="#‘1’-‘2’-‘3’-map-parseInt-答案是多少？" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt) 答案是多少？"></a>[‘1’, ‘2’, ‘3’].map(parseInt) 答案是多少？</h2><p>答案 [1, NaN, NaN]</p>
<p>map会给函数传递3个参数： (elem, index, array)，当相与：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>(item, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>parseInt接收两个参数(string, radix)，其中radix代表进制。省略 radix 或 radix = 0，则数字将以十进制解析</p>
<p>因此，map 遍历 [“1”, “2”, “3”]，相应 parseInt 接收参数如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>);  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="考-Symbol"><a href="#考-Symbol" class="headerlink" title="考 Symbol"></a>考 Symbol</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">'123'</span>, c=<span class="number">123</span>;  </span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">'123'</span>), c=<span class="built_in">Symbol</span>(<span class="string">'123'</span>);  </span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">'123'</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">'456'</span>&#125;;  </span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">'123'</span>, c=<span class="number">123</span>;</span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉。</span></span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 c</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">'123'</span>), c=<span class="built_in">Symbol</span>(<span class="string">'123'</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// b 是 Symbol 类型，不需要转换。</span></span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。</span></span><br><span class="line">a[c]=<span class="string">'c'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 b</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">'123'</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">'456'</span>&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// b 不是字符串也不是 Symbol 类型，需要转换成字符串。</span></span><br><span class="line"><span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。</span></span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 不是字符串也不是 Symbol 类型，需要转换成字符串。</span></span><br><span class="line"><span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。</span></span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 c</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure>



<p>这个ToPrimitive可能不太好懂，我给你解释一下吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ToPrimitive(obj,preferredType)</span><br><span class="line"></span><br><span class="line">JS引擎内部转换为原始值ToPrimitive(obj,preferredType)函数接受两个参数，第一个obj为被转换的对象，第二个</span><br><span class="line">preferredType为希望转换成的类型（默认为空，接受的值为Number或String）</span><br><span class="line"></span><br><span class="line">在执行ToPrimitive(obj,preferredType)时如果第二个参数为空并且obj为Date的事例时，此时preferredType会</span><br><span class="line">被设置为String，其他情况下preferredType都会被设置为Number如果preferredType为Number，ToPrimitive执</span><br><span class="line">行过程如</span><br><span class="line">下：</span><br><span class="line">1. 如果obj为原始值，直接返回；</span><br><span class="line">2. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；</span><br><span class="line">3. 否则调用 obj.toString()，如果执行结果是原始值，返回之；</span><br><span class="line">4. 否则抛异常。</span><br><span class="line"></span><br><span class="line">如果preferredType为String，将上面的第2步和第3步调换，即：</span><br><span class="line">1. 如果obj为原始值，直接返回；</span><br><span class="line">2. 否则调用 obj.toString()，如果执行结果是原始值，返回之；</span><br><span class="line">3. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；</span><br><span class="line">4. 否则抛异常。</span><br></pre></td></tr></table></figure>

<p>首先我们要明白 <strong>obj.valueOf()</strong> 和 <strong>obj.toString()</strong> 还有原始值分别是什么意思,这是弄懂上面描述的前提之一:</p>
<p><strong>toString用来返回对象的字符串表示。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">console.log(obj.toString());&#x2F;&#x2F;[object Object]</span><br><span class="line"></span><br><span class="line">var arr2 &#x3D; [];</span><br><span class="line">console.log(arr2.toString());&#x2F;&#x2F;&quot;&quot;空字符串</span><br><span class="line">  </span><br><span class="line">var date &#x3D; new Date();</span><br><span class="line">console.log(date.toString());&#x2F;&#x2F;Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>

<p><strong>valueOf方法返回对象的原始值，可能是字符串、数值或bool值等，看具体的对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;obj&quot;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.valueOf());&#x2F;&#x2F;Object &#123;name: &quot;obj&quot;&#125;</span><br><span class="line"></span><br><span class="line">var arr1 &#x3D; [1];</span><br><span class="line">console.log(arr1.valueOf());&#x2F;&#x2F;[1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var date &#x3D; new Date();</span><br><span class="line">console.log(date.valueOf());&#x2F;&#x2F;1456638436303</span><br><span class="line">如代码所示，三个不同的对象实例调用valueOf返回不同的数据</span><br></pre></td></tr></table></figure>

<p><strong>原始值指的是[‘Null’,’Undefined’,’String’,’Boolean’,’Number’,’Symbol’]6种基本数据类型之一</strong></p>
<p>最后分解一下其中的过程：<br>+new Date():</p>
<blockquote>
<ol>
<li>运算符new的优先级高于一元运算符+，所以过程可以分解为：<br> var time=new Date()；<br>  +time</li>
</ol>
</blockquote>
<blockquote>
<p>2.根据上面提到的规则相当于：ToNumber(time)</p>
</blockquote>
<blockquote>
<p>3.time是个日期对象，根据ToNumber的转换规则，所以相当于：ToNumber(ToPrimitive(time))</p>
</blockquote>
<blockquote>
<p>4.根据ToPrimitive的转换规则：ToNumber(time.valueOf())，time.valueOf()就是 <strong>原始值</strong> 得到的是个时间戳，假设time.valueOf()=1503479124652</p>
</blockquote>
<blockquote>
<p>5.所以ToNumber(1503479124652)返回值是1503479124652这个数字。</p>
</blockquote>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-属性类型"><a href="#1-属性类型" class="headerlink" title="1.属性类型"></a>1.属性类型</h2><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><ul>
<li>Configurable：能否通过delete删除属性从而重新定义属性</li>
<li>Enumerable：表示能否通过for-in循环返回属性</li>
<li>Writable：表示能否修改属性的值</li>
<li>Value：属性的数据值，默认为undefined</li>
</ul>
<p>在调用Object.defineProperty()时，如果不指定，configurable、enumerable和writable特性的默认值都是false。</p>
<blockquote>
<p>IE8是第一个实现Object.defineProperty()方法的浏览器版本，但是问题多，如只能创建访问器属性，所以最好不要在IE8中使用这个方法。</p>
</blockquote>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><ul>
<li>Configurable</li>
<li>Enumerable</li>
<li>Get</li>
<li>Set</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book=&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2020</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> thie._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue &gt; <span class="number">2020</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2020</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述例子中_year、edition是数据属性，year是访问器属性。</p>
<p>可以通过<code>Object.getOwnPropertyDescriptor(object,属性名)</code>读取属性的特性</p>
<p><code>Object.hasOwnProperty()</code>可以检测一个属性是存在于实例中还是原型中。</p>
<p><code>in</code>操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</p>
<p><code>for-in</code>返回的是所有能够通过对象访问的、可枚举的属性</p>
<p><code>Object.keys()</code>返回对象上所有可枚举的实例属性。</p>
<p><code>Object.getOwnPropertyNames()</code>返回对象上所有的实例属性，无论可枚举不可枚举。</p>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>缺点：对象无法识别，因为所有的实例都指向一个原型</p>
<h2 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2. 构造函数模式"></a>2. 构造函数模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>优点：实例可以识别为一个特定的类型</p>
<p>缺点：每次创建实例时，每个方法都要被创建一次</p>
<h2 id="2-1-构造函数模式优化"><a href="#2-1-构造函数模式优化" class="headerlink" title="2.1 构造函数模式优化"></a>2.1 构造函数模式优化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getName = getName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>优点：解决了每个方法都要被重新创建的问题</p>
<p>缺点：这叫啥封装……</p>
<h2 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'keivn'</span>;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：方法不会重新创建</p>
<p>缺点：1. 所有的属性和方法都共享 2. 不能初始化参数</p>
<h2 id="3-1-原型模式优化"><a href="#3-1-原型模式优化" class="headerlink" title="3.1 原型模式优化"></a>3.1 原型模式优化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：封装性好了一点</p>
<p>缺点：重写了原型，丢失了constructor属性</p>
<h2 id="3-2-原型模式优化"><a href="#3-2-原型模式优化" class="headerlink" title="3.2 原型模式优化"></a>3.2 原型模式优化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'kevin',</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：实例可以通过constructor属性找到所属构造函数</p>
<p>缺点：原型模式该有的缺点还是有</p>
<h2 id="4-组合模式"><a href="#4-组合模式" class="headerlink" title="4. 组合模式"></a>4. 组合模式</h2><p>构造函数模式与原型模式双剑合璧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：该共享的共享，该私有的私有，使用最广泛的方式</p>
<p>缺点：有的人就是希望全部都写在一起，即更好的封装性</p>
<h2 id="4-1-动态原型模式"><a href="#4-1-动态原型模式" class="headerlink" title="4.1 动态原型模式"></a>4.1 动态原型模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>注意：使用动态原型模式时，不能用对象字面量重写原型</p>
<p>解释下为什么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: Person,</span><br><span class="line">            getName: function () &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 并没有该方法</span></span><br><span class="line">person1.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释掉上面的代码，这句是可以执行的。</span></span><br><span class="line">person2.getName();</span><br></pre></td></tr></table></figure>

<p>为了解释这个问题，假设开始执行<code>var person1 = new Person(&#39;kevin&#39;)</code>。</p>
<blockquote>
<p>当执行 var person1 = new Person(‘kevin’) 的时候，person1.的原型并不是指向 Person.prototype，而是指向 Person.prototype 指向的原型对象，我们假设这个原型对象名字为 O, 然后再修改 Person.prototype 的值为一个字面量，只是将一个新的值赋值给 Person.prototype, 并没有修改 O 对象，也不会切断已经建立的 person1 和 O 的原型关系，访问 person.getName 方法，依然会从 O 上查找</p>
</blockquote>
<p>如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。</p>
<p>我们回顾下 new 的实现步骤：</p>
<ol>
<li>首先新建一个对象</li>
<li>然后将对象的原型指向 Person.prototype指向的对象</li>
<li>然后 Person.apply(obj)</li>
<li>返回这个对象</li>
</ol>
<p>注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！</p>
<p>如果你就是想用字面量方式写代码，可以尝试下这种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: Person,</span><br><span class="line">            getName: function () &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line">person1.getName(); <span class="comment">// kevin</span></span><br><span class="line">person2.getName();  <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-寄生构造函数模式"><a href="#5-1-寄生构造函数模式" class="headerlink" title="5.1 寄生构造函数模式"></a>5.1 寄生构造函数模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>寄生构造函数模式，我个人认为应该这样读：</p>
<p>寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。</p>
<p>也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！</p>
<p>这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        values.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>);</span><br><span class="line"><span class="keyword">var</span> colors2 = SpecialArray(<span class="string">'red2'</span>, <span class="string">'blue2'</span>, <span class="string">'green2'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString()); <span class="comment">// red|blue|green</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors2);</span><br><span class="line"><span class="built_in">console</span>.log(colors2.toPipedString()); <span class="comment">// red2|blue2|green2</span></span><br></pre></td></tr></table></figure>

<p>你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。</p>
<p>但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。</p>
<p>在可以使用其他模式的情况下，不要使用这种模式。</p>
<p>但是值得一提的是，上面例子中的循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    values.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以替换成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.push.apply(values, arguments);</span><br></pre></td></tr></table></figure>

<h2 id="5-2-稳妥构造函数模式"><a href="#5-2-稳妥构造函数模式" class="headerlink" title="5.2 稳妥构造函数模式"></a>5.2 稳妥构造函数模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = person(<span class="string">'kevin'</span>);</span><br><span class="line"></span><br><span class="line">person1.sayName(); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">"daisy"</span>;</span><br><span class="line"></span><br><span class="line">person1.sayName(); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure>

<p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。</p>
<p>与寄生构造函数模式有两点不同：</p>
<ol>
<li>新创建的实例方法不引用 this</li>
<li>不使用 new 操作符调用构造函数</li>
</ol>
<p>稳妥对象最适合在一些安全的环境中。</p>
<p>稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。</p>
<p>类的声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'name'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'name'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="原型链与继承"><a href="#原型链与继承" class="headerlink" title="原型链与继承"></a>原型链与继承</h1><p>ES6之前中并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实例。构造函数和普通函数其实形式上一样，唯一区别是构造函数命名通常首字母是大写，并且调用的时候是new。</p>
<h3 id="一、普通对象和函数对象"><a href="#一、普通对象和函数对象" class="headerlink" title="一、普通对象和函数对象"></a>一、普通对象和函数对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">凡是通过 <span class="keyword">new</span> <span class="built_in">Function</span>() 创建的对象都是函数对象，其他的都是普通对象</span><br></pre></td></tr></table></figure>

<p>所有函数对象的<strong>proto</strong>都指向Function.prototype，它是一个空函数（Empty function）</p>
<p>函数对象包括：</p>
<blockquote>
<p>内置的函数对象：Array Date Number String等等</p>
<p>自定义函数对象：如function Person() {}; 此时Person就是函数对象</p>
</blockquote>
<p>这些构造器都是函数对象：</p>
<p><img src="/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/2.png" alt></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.constructor == <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">RegExp</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Error</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Date</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><code>Function.prototype</code>也是唯一一个<code>typeof XXX.prototype</code>为 <code>function</code>的<code>prototype</code>。其它的构造器的<code>prototype</code>都是一个对象</p>
<p><img src="/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/5.png" alt></p>
<h3 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">//true</span></span><br><span class="line">实例的构造函数属性（<span class="keyword">constructor</span>）指向构造函数</span><br></pre></td></tr></table></figure>

<h3 id="三、原型对象"><a href="#三、原型对象" class="headerlink" title="三、原型对象"></a>三、原型对象</h3><p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 <code>prototype</code> 属性了。对于 ECMAScript 中的引用类型而言，<code>prototype</code> 是保存着它们所有实例方法的真正所在。换句话所说，诸如 <code>toString()</code>和 <code>valuseOf()</code> 等方法实际上都保存在 <code>prototype</code> 名下，只不过是通过各自对象的实例访问罢了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype</span><br><span class="line"><span class="comment">//es5的方法,可以获得对象的原型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性</span><br><span class="line">其中函数对象也有__proto__，因为函数对象是<span class="built_in">Function</span>的实例对象</span><br></pre></td></tr></table></figure>

<p>==<strong>prototype是函数才会有的属性</strong>==</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">   name:  <span class="string">'Zaxlct'</span>,</span><br><span class="line">   age: <span class="number">28</span>,</span><br><span class="line">   job: <span class="string">'Software Engineer'</span>,</span><br><span class="line">   sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     alert(<span class="keyword">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person.prototype就是原型对象,还有一个默认属性:constructor</span></span><br><span class="line"><span class="comment">//这个属性（是一个指针）指向 prototype 属性所在的函数（Person）</span></span><br></pre></td></tr></table></figure>

<p>==Person.prototype.constructor == Person==</p>
<h3 id="四、构造器"><a href="#四、构造器" class="headerlink" title="四、构造器"></a>四、构造器</h3><p>所有的构造器都来自于 <code>Function.prototype</code>，甚至包括根构造器<code>Object</code>及<code>Function</code>自身。所有构造器都继承了Function.prototype·的属性及方法。如length、call、apply、bind</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象的构造器不仅仅有 Object，也可以是 Array，Date，Function等。</span></span><br><span class="line"><span class="comment">//所以我们也可以构造函数来创建 Array、 Date、Function</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">b.constructor === <span class="built_in">Array</span>;</span><br><span class="line">b.__proto__ === <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line">c.constructor === <span class="built_in">Date</span>;</span><br><span class="line">c.__proto__ === <span class="built_in">Date</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">d.constructor === <span class="built_in">Function</span>;</span><br><span class="line">d.__proto__ === <span class="built_in">Function</span>.prototype;</span><br></pre></td></tr></table></figure>

<h3 id="五、原型链"><a href="#五、原型链" class="headerlink" title="五、原型链"></a>五、原型链</h3><ol>
<li><p><code>person1.__proto__</code> 是什么？</p>
<p> Person.prototype</p>
</li>
<li><p><code>Person.__proto__</code> 是什么？</p>
<p> Function.prototype</p>
</li>
<li><p><code>Person.prototype.__proto__</code> 是什么？</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。</span><br><span class="line">因为一个普通对象的构造函数 === <span class="built_in">Object</span></span><br><span class="line">所以Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.__proto__</code> 是什么？</p>
<p> Function.prototype</p>
<p> <strong>Object.<strong>proto</strong></strong> 可以理解为是一个指针，指向了构造函数的原型对象，由于Objec是一个构造函数，函数继承自Function.prototype,所以此处 Objec.<strong>proto</strong> === Function.prototype;</p>
<p> <strong>Object.prototype</strong> 是作为构造函数的Object的原型对象，比较有意思的是，由于Function.prototype也是一个对象，所以它也继承自Object,所以Function.prototype.<strong>proto</strong> === Object.prototype;</p>
<p> 所以，你要问他们有什么关系 Object.<strong>proto</strong>.<strong>proto</strong> === Object.prototype</p>
</li>
<li><p><code>Object.prototype__proto__</code> 是什么？</p>
<p> null</p>
</li>
<li><p><code>Function__proto__===Function.prototype</code>//true</p>
</li>
</ol>
<p><img src="/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/1.png" alt></p>
<h3 id="六、原型的原型"><a href="#六、原型的原型" class="headerlink" title="六、原型的原型"></a>六、原型的原型</h3><p><img src="/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/3.png" alt></p>
<p>蓝色的线就是<strong><code>原型链</code></strong>,原型链是通过<strong>proto</strong>来串起来的</p>
<p>==原型对象是通过Object构造函数生成的==</p>
<p>==<strong>null</strong>==有俩个用处:</p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象</li>
<li>作为对象原型链的终点==Object.getPrototypeOf(Object.prototype) //null==</li>
</ul>
<h3 id="七、补充"><a href="#七、补充" class="headerlink" title="七、补充"></a>七、补充</h3><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//这里其实person中并没有constructor属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性</span></span><br><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>

<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h4 id="真的是继承吗"><a href="#真的是继承吗" class="headerlink" title="真的是继承吗?"></a>真的是继承吗?</h4><p>一般我们所说”每一个对象都会从原型’继承’属性”,然而继承意味着复制操作,但是Javascript默认不会复制对象的属性,相反,Javascript只是在俩个对象之间创建一个关联,这样,一个对象就可以通过委托访问另一个对象的属性和函数,所以与其叫继承，委托的说法反而更准确些。</p>
<h3 id="八、梳理流程"><a href="#八、梳理流程" class="headerlink" title="八、梳理流程"></a>八、梳理流程</h3><p>JS对象的圈子里有这么个游戏规则:</p>
<blockquote>
<p>如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.</p>
</blockquote>
<p>如果让原型对象指向另一个类型的实例…..有趣的事情便发生了.</p>
<p>即: constructor1.prototype = instance2</p>
<p>鉴于上述游戏规则生效,如果试图引用constructor1构造的实例instance1的某个属性p1:</p>
<p>1).首先会在instance1内部属性中找一遍;</p>
<p>2).接着会在instance1.<strong>proto</strong>(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;</p>
<p>3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.<strong>proto</strong>(constructor2.prototype)中寻找…直至Object的原型对象</p>
<blockquote>
<p>搜索轨迹: instance1–&gt; instance2 –&gt; constructor2.prototype…–&gt;Object.prototype</p>
</blockquote>
<p>这种搜索的轨迹,形似一条长链, 又因prototype在这个游戏规则中充当链接的作用,于是我们把这种实例与原型的链条称作 <strong>原型链</strong> . 下面有个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sonProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承 Father</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//Son.prototype被重写,导致Son.prototype.constructor也一同被重写</span></span><br><span class="line">Son.prototype.getSonVaule = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sonProperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance.getFatherValue());<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>instance实例通过原型链找到了Father原型中的getFatherValue方法.</p>
<p>注意: 此时instance.constructor指向的是Father,这是因为Son.prototype中的constructor被重写的缘故.</p>
<p>判断原型与实例的这种继承关系:</p>
<blockquote>
<p>第一种是使用 <strong>instanceof</strong> 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回true.</p>
<p>判断实例对象的<strong>proto</strong>属性与构造函数的prototype是不是用一个引用。如果不是，他会沿着对象的<strong>proto</strong>向上查找的，直到顶端Object。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> Father);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> Son);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二种是使用 <strong>isPrototypeOf()</strong> 方法, 同样只要是原型链中出现过的原型,isPrototypeOf() 方法就会返回true, 如下所示.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(Father.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(Son.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h4><blockquote>
<p>原理：把子类的prototype（原型对象）直接设置为父类的实例</p>
<p>缺点：因为子类只进行一次原型更改，所以子类的所有实例保存的是同一个父类的值。 当子类对象上进行值修改时，如果是修改的原始类型的值，那么会在实例上新建这样一个值； 但如果是引用类型的话，他就会去修改子类上唯一一个父类实例里面的这个引用类型，这会影响所有子类实例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'kevin'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// kevin</span></span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：</p>
<ol>
<li><p>当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">'kevin'</span>, <span class="string">'daisy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'yayu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数。实际上没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
</li>
</ol>
<p>因为子类只进行一次原型更改，所以子类的所有实例保存的是同一个父类的值。 当子类对象上进行值修改时，如果是修改的原始类型的值，那么会在实例上新建这样一个值； 但如果是引用类型的话，他就会去修改子类上唯一一个父类实例里面的这个引用类型，这会影响所有子类实例</p>
<p>有鉴于此, 实践中很少会单独使用原型链。</p>
<p>为此,下面将有一些尝试以弥补原型链的不足。</p>
<h4 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h4><blockquote>
<p>基本思想:在子类构造函数中 使用<code>Parent.call(this)</code>的方法继承父类属性。</p>
<p>原理： 将子类的this使用父类的构造函数跑一遍</p>
<p>缺点： Parent原型链上的属性和方法并不会被子类继承</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>);<span class="comment">//继承了Father,且向父类型传递参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red,blue,green" 可见引用类型值是独立的</span></span><br></pre></td></tr></table></figure>

<p>很明显,借用构造函数一举解决了原型链的两大问题:</p>
<p>其一, 保证了原型链中引用类型值的独立,不再被所有实例共享;</p>
<p>其二, 子类型创建时也能够向父类型传递参数.</p>
<p>随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Father)中定义的方法,对子类型而言也是不可见的。考虑此,借用构造函数的技术也很少单独使用.</p>
<p>缺点:</p>
<ul>
<li>方法都在构造函数中定义，每次创建实例都会创建一遍方法</li>
<li>只能继承父类实例的属性和方法，不能继承原型上的属性和方法</li>
</ul>
<h4 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h4><blockquote>
<p>基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</p>
<p>组合构造函数中使用call继承和原型链继承。</p>
<p>原理： 子类构造函数中使用<code>Parent.call(this);</code>的方式可以继承写在父类构造函数中this上绑定的各属性和方法； 使用<code>Child.prototype = new Parent()</code>的方式可以继承挂在在父类原型上的各属性和方法</p>
<p>缺点： 父类构造函数在子类构造函数中执行了一次，在子类绑定原型时又执行了一次</p>
</blockquote>
<p>这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下所示.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,name);<span class="comment">//继承实例属性，第一次调用Father()</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//继承父类方法,第二次调用Father()</span></span><br><span class="line">Son.prototype.contructor = Son;</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName();<span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中最常用的继承模式. 而且, instanceof 和 isPrototypeOf( )也能用于识别基于组合继承创建的对象.</p>
<p>同时我们还注意到组合继承其实==调用了两次父类构造函数==, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢, 这个我们将在后面讲到.</p>
<h5 id="3-1-组合继承优化1："><a href="#3-1-组合继承优化1：" class="headerlink" title="3.1 组合继承优化1："></a>3.1 组合继承优化1：</h5><p>因为这时父类构造函数的方法已经被执行过了，只需要关心原型链上的属性和方法了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son.prototype = Father.prototype;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>因为原型上有一个属性为<code>constructor</code>，此时直接使用父类的prototype的话那么会导致 实例的constructor为Father，即不能区分这个实例对象是Son的实例还是父类的实例对象。</li>
<li>子类不可直接在prototype上添加属性和方法，因为会影响父类的原型</li>
</ul>
<p><code>注意：这个时候instanceof是可以判断出实例为Son的实例的，因为instanceof的原理是沿着对象的__proto__判断是否有一个原型是等于该构造函数的原型的。这里把Son的原型直接设置为了父类的原型，那么: 实例.__proto__ === Son.prototype === Father.prototype</code></p>
<h5 id="3-2组合继承方式-优化2-添加中间对象【最通用版本】："><a href="#3-2组合继承方式-优化2-添加中间对象【最通用版本】：" class="headerlink" title="3.2组合继承方式 优化2 - 添加中间对象【最通用版本】："></a>3.2组合继承方式 优化2 - 添加中间对象【最通用版本】：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'child'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype); <span class="comment">//提供__proto__</span></span><br><span class="line">Child.prototype.constrctor = Child;</span><br></pre></td></tr></table></figure>

<p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong></p>
<h4 id="封装一个原生的继承方法"><a href="#封装一个原生的继承方法" class="headerlink" title="封装一个原生的继承方法"></a>封装一个原生的继承方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">Parent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">Child</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendsClass</span>(<span class="params">Parent, Child</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = Parent.prototype</span><br><span class="line">  Child.prototype = <span class="keyword">new</span> F()</span><br><span class="line">  Child.prototype.constrctor = Child</span><br><span class="line">  <span class="keyword">return</span> Child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h4><p>该方法最初由道格拉斯·克罗克福德于2006年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript中的原型式继承) 的文章中提出. 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型. 大意如下：</p>
<blockquote>
<p>原理：就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p>
<p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从本质上讲, object() 对传入其中的对象执行了一次浅复制. 下面我们来看看为什么是浅复制.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line">alert(person.friends);<span class="comment">//"Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中,可以作为另一个对象基础的是person对象,于是我们把它传入到object()函数中,然后该函数就会返回一个新对象. 这个新对象将person作为原型,因此它的原型中就包含引用类型值属性. 这意味着</p>
<p>person.friends不仅属于person所有,而且也会被anotherPerson以及yetAnotherPerson共享.</p>
<p>在 ECMAScript5 中,通过新增 <strong>Object.create()</strong> 方法规范化了上面的原型式继承.</p>
<p><strong>Object.create()</strong> 接收两个参数:</p>
<ul>
<li>一个用作新对象原型的对象</li>
<li>(可选的)一个为新对象定义额外属性的对象</li>
</ul>
<p><strong>Object.create()</strong> 只有一个参数时功能与上述object方法相同, 它的第二个参数与Object.defineProperties()方法的第二个参数格式相同: 每个属性都是通过自己的描述符定义的.以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"Van"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name : &#123;</span><br><span class="line">        value : <span class="string">"Louis"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);<span class="comment">//"Louis"</span></span><br></pre></td></tr></table></figure>

<p>目前支持 <strong>Object.create()</strong> 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome.</p>
<p><strong>提醒:</strong> 原型式继承中, 包含引用类型值的属性始终都会共享相应的值, 就像使用原型模式一样.</p>
<h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h4><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h4 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h4><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure>

<p>组合继承最大的缺点是会调用两次父构造函数。</p>
<p>一次是设置子类型实例的原型的时候：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>

<p>一次在创建子类型实例的时候：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br></pre></td></tr></table></figure>

<p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(<span class="keyword">this</span>, name);</span><br></pre></td></tr></table></figure>

<p>在这里，我们又会调用了一次 Parent 构造函数。</p>
<p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p>
<p>那么我们该如何精益求精，避免这一次重复调用呢？</p>
<p>如果我们不使用 Child.prototype = new Parent() ，而是==间接的让 Child.prototype 访问到 Parent.prototype== 呢？</p>
<p>看看如何实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="comment">// var F = function () &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// F.prototype = Parent.prototype;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.prototype = new F();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> temp = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line">temp.constructor = Child</span><br><span class="line">Child.prototype = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>

<p>最后我们封装一下这个继承方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(parent.prototype);</span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure>

<p>为什么不让 Child.prototype 直接访问到 Parent.prototype ？一定要通过寄生的方式呢。。。</p>
<blockquote>
<p>你这样的话，增加 Child.prototype.testProp = 1; 同时会影响 Parent.prototype 的<br>如果不模拟，直接上 es5 的话应该是下面这样吧<br>Child.prototype = Object.create(Parent.prototype);</p>
</blockquote>
<p>关键在于直接访问的时候，会产生多余的属性值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/4.png" alt></p>
<p>你会发现有两个 [‘red’, ‘blue’, ‘green’] 数组，实际上，Parent 中的那个是没有必要的</p>
<p>为了避免这种情况，才采用了间接调用</p>
<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h3 id="ES5-ES6-的继承除了写法以外还有什么区别？"><a href="#ES5-ES6-的继承除了写法以外还有什么区别？" class="headerlink" title="ES5/ES6 的继承除了写法以外还有什么区别？"></a>ES5/ES6 的继承除了写法以外还有什么区别？</h3><ul>
<li>class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。</li>
<li>class 声明内部会启用严格模式。</li>
<li>class 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li>
<li>class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。</li>
<li>必须使用 new 调用 class。</li>
<li>class 内部无法重写类名。</li>
</ul>
<h3 id="js中new和object-create区别"><a href="#js中new和object-create区别" class="headerlink" title="js中new和object.create区别"></a>js中new和object.create区别</h3><h3 id="下面的代码会输出什么？"><a href="#下面的代码会输出什么？" class="headerlink" title="下面的代码会输出什么？"></a>下面的代码会输出什么？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span></span><br><span class="line">  <span class="keyword">this</span>.msg = <span class="string">"use 'this.' set in function"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">B.prototype = A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b.name);</span><br><span class="line"><span class="built_in">console</span>.log(b.msg);</span><br></pre></td></tr></table></figure>

<p>答案是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>b.name</code>返回 <code>A</code>，是因为<code>b</code>上面没有<code>name</code>属性，他就会沿着原型链向上查找，然而 <code>b.__proto__</code> 为<code>函数A</code>，每一个函数都有一个属性为name，其值是函数的名字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* 这是一个名为'abc'的函数 */</span> &#125;</span><br><span class="line">abc.name <span class="comment">// -&gt; 'abc'</span></span><br></pre></td></tr></table></figure>

<p><code>b.msg</code> 为什么是<code>undefined</code>哪？ 因为<code>b.__proto__</code> 是 <code>函数A</code>，那怎么修改才能拿到<code>msg</code>哪？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>修改后的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tom</span><br><span class="line">VM731:12 use &#39;this.&#39; set in function</span><br></pre></td></tr></table></figure>



<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h2 id="this的指向有哪几种情况"><a href="#this的指向有哪几种情况" class="headerlink" title="this的指向有哪几种情况"></a>this的指向有哪几种情况</h2><blockquote>
<p>this代表函数调用相关联的对象，通常也称之为执行上下文</p>
</blockquote>
<ol>
<li>作为函数直接调用，非严格模式下，this指向window，严格模式下，this指向undefined</li>
<li>作为某对象的方法调用，this通常指向调用的对象</li>
<li>使用apply、call、bind 可以绑定this的指向</li>
<li>在构造函数中，this指向新创建的对象</li>
<li>箭头函数没有单独的this值，this在箭头函数创建时确定，它与声明所在的上下文相同</li>
</ol>
<h2 id="如果对一个函数进行多次-bind，那么上下文会是什么呢？"><a href="#如果对一个函数进行多次-bind，那么上下文会是什么呢？" class="headerlink" title="如果对一个函数进行多次 bind，那么上下文会是什么呢？"></a>如果对一个函数进行多次 bind，那么上下文会是什么呢？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// =&gt; ?</span></span><br></pre></td></tr></table></figure>

<p>不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply()</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>

<h2 id="多个this规则出现时，this最终指向哪里？"><a href="#多个this规则出现时，this最终指向哪里？" class="headerlink" title="多个this规则出现时，this最终指向哪里？"></a>多个this规则出现时，this最终指向哪里？</h2><p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 </p>
<p><img src="/2020/02/28/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/8.jpg" alt></p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName();      <span class="comment">//-&gt; 2    Foo对象上的getName() ，这里不会是3，因为只有Foo的实例对象才会是3，Foo上面是没有3的</span></span><br><span class="line">getName();          <span class="comment">//-&gt; 4    window上的getName，console.log(5)的那个函数提升后，在console.log(4)的那里被重新赋值</span></span><br><span class="line">Foo().getName();    <span class="comment">//-&gt; 1    在Foo函数中，getName是全局的getName，覆盖后输出 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName();  <span class="comment">//-&gt; 2    Foo后面不带括号而直接 '.'，那么点的优先级会比new的高，所以把 Foo.getName 作为构造函数</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName();<span class="comment">//-&gt; 3    此时是Foo的实例，原型上会有输出3这个方法</span></span><br></pre></td></tr></table></figure>



<p>箭头函数里面的this是继承它作用域父级的this， 即声明箭头函数处的this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) </span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.b()   <span class="comment">// a</span></span><br><span class="line">a.c()   <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = a.b</span><br><span class="line">d()     <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var name1 &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">	let name1 &#x3D; &#39;kin&#39;;</span><br><span class="line">	let a &#x3D; &#123;</span><br><span class="line">		name1: &#39;jack&#39;,</span><br><span class="line">		fn: () &#x3D;&gt; &#123;</span><br><span class="line">      var name1 &#x3D; &#39;black&#39;</span><br><span class="line">      console.log(this.name1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().fn() &#x2F;&#x2F; ?</span><br></pre></td></tr></table></figure>

<p>答案： 输出1</p>
<p>因为fn处绑定的是箭头函数，箭头函数并不创建this，它只会从自己的作用域链的上一层继承this。这里它的上一层是test()，非严格模式下test中this值为window。</p>
<ul>
<li>如果在绑定fn的时候使用了function，那么答案会是 ‘jack’</li>
<li>如果第一行的 var 改为了 let，那么答案会是 undefind， 因为let不会挂到window上</li>
</ul>

    </div>
    <div>
      
        <div>
      
          <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
      
</div>
      
    </div>
    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/26/%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" rel="prev" title="音乐小程序项目总结">
      <i class="fa fa-chevron-left"></i> 音乐小程序项目总结
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#变量类型和类型转换"><span class="nav-text">变量类型和类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-变量类型"><span class="nav-text">JS 变量类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS中使用typeof能得到哪些类型？"><span class="nav-text">JS中使用typeof能得到哪些类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof-能正确判断对象的原理是什么？"><span class="nav-text">instanceof 能正确判断对象的原理是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeof"><span class="nav-text">typeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-toString"><span class="nav-text">Object.prototype.toString</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个类型判断函数"><span class="nav-text">实现一个类型判断函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转Boolean"><span class="nav-text">转Boolean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象转基本类型"><span class="nav-text">对象转基本类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较运算符"><span class="nav-text">比较运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100-问题"><span class="nav-text">100 + 问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“a-common-string”为什么会有length属性"><span class="nav-text">“a common string”为什么会有length属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#console-log-new-Boolean-false-输出什么-易混淆"><span class="nav-text">console.log(!!(new Boolean(false))输出什么 [易混淆]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vs"><span class="nav-text">&#x3D;&#x3D; vs &#x3D;&#x3D;&#x3D;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符"><span class="nav-text">&#x3D;&#x3D; 操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符-1"><span class="nav-text">&#x3D;&#x3D;&#x3D; 操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等于true还是false"><span class="nav-text">{} 等于true还是false</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-与-Number-1-有什么区别"><span class="nav-text">1 与 Number(1)有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-text">[]&#x3D;&#x3D;![]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出以下代码运行结果"><span class="nav-text">输出以下代码运行结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何判断一个数据是不是Array"><span class="nav-text">如何判断一个数据是不是Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#obj-toString-和Object-prototype-toString-call-obj"><span class="nav-text">obj.toString() 和Object.prototype.toString.call(obj)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象引用问题-1"><span class="nav-text">对象引用问题 - 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象引用问题-2"><span class="nav-text">对象引用问题 - 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#‘1’-‘2’-‘3’-map-parseInt-答案是多少？"><span class="nav-text">[‘1’, ‘2’, ‘3’].map(parseInt) 答案是多少？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#考-Symbol"><span class="nav-text">考 Symbol</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象"><span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-属性类型"><span class="nav-text">1.属性类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据属性"><span class="nav-text">数据属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问器属性"><span class="nav-text">访问器属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建对象"><span class="nav-text">创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-工厂模式"><span class="nav-text">1. 工厂模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-构造函数模式"><span class="nav-text">2. 构造函数模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-构造函数模式优化"><span class="nav-text">2.1 构造函数模式优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-原型模式"><span class="nav-text">3. 原型模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-原型模式优化"><span class="nav-text">3.1 原型模式优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-原型模式优化"><span class="nav-text">3.2 原型模式优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-组合模式"><span class="nav-text">4. 组合模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-动态原型模式"><span class="nav-text">4.1 动态原型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-寄生构造函数模式"><span class="nav-text">5.1 寄生构造函数模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-稳妥构造函数模式"><span class="nav-text">5.2 稳妥构造函数模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原型链与继承"><span class="nav-text">原型链与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、普通对象和函数对象"><span class="nav-text">一、普通对象和函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、构造函数"><span class="nav-text">二、构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、原型对象"><span class="nav-text">三、原型对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、构造器"><span class="nav-text">四、构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、原型链"><span class="nav-text">五、原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、原型的原型"><span class="nav-text">六、原型的原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、补充"><span class="nav-text">七、补充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constructor-NaN"><span class="nav-text">constructor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#proto"><span class="nav-text">proto</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#真的是继承吗"><span class="nav-text">真的是继承吗?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八、梳理流程"><span class="nav-text">八、梳理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-原型链继承"><span class="nav-text">1.原型链继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-借用构造函数"><span class="nav-text">2. 借用构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-组合继承"><span class="nav-text">3. 组合继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-组合继承优化1："><span class="nav-text">3.1 组合继承优化1：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2组合继承方式-优化2-添加中间对象【最通用版本】："><span class="nav-text">3.2组合继承方式 优化2 - 添加中间对象【最通用版本】：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装一个原生的继承方法"><span class="nav-text">封装一个原生的继承方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-原型式继承"><span class="nav-text">4. 原型式继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-寄生式继承"><span class="nav-text">5. 寄生式继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-寄生组合式继承"><span class="nav-text">6. 寄生组合式继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES5-ES6-的继承除了写法以外还有什么区别？"><span class="nav-text">ES5&#x2F;ES6 的继承除了写法以外还有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js中new和object-create区别"><span class="nav-text">js中new和object.create区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下面的代码会输出什么？"><span class="nav-text">下面的代码会输出什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析"><span class="nav-text">分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this"><span class="nav-text">this</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#this的指向有哪几种情况"><span class="nav-text">this的指向有哪几种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果对一个函数进行多次-bind，那么上下文会是什么呢？"><span class="nav-text">如果对一个函数进行多次 bind，那么上下文会是什么呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多个this规则出现时，this最终指向哪里？"><span class="nav-text">多个this规则出现时，this最终指向哪里？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题"><span class="nav-text">面试题</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhou Jun"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Zhou Jun</p>
  <div class="site-description" itemprop="description">FOCUS</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dannykbsoul" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dannykbsoul" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:346925954@qq.com" title="E-Mail → mailto:346925954@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/zjsouljoy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;zjsouljoy" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://youtube.com/zhou%20jun" title="YouTube → https:&#x2F;&#x2F;youtube.com&#x2F;zhou jun" rel="noopener" target="_blank"><i class="fa fa-fw fa-youtube"></i>YouTube</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">130k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">1:58</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>
-->

<script>
      var now = new Date(); 
      function createtime() { 
          var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 
          now.setTime(now.getTime()+250); 
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
          document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
      } 
  setInterval("createtime()",250);
  </script>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
