<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Union Find算法</title>
    <url>/2020/02/21/Union-Find%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Union-Find算法也就是常说的并查集算法，主要用来解决图论中<code>动态连通性</code>问题。</p>
<p>连通具有以下几个性质：</p>
<ol>
<li>⾃反性：节点 p 和 p 是连通的。</li>
<li>对称性：如果节点 p 和 q 连通，那么 q 和 p 也连通。</li>
<li>传递性：如果节点 p 和 q 连通， q 和 r 连通，那么 p 和 r 也连通。</li>
</ol>
<p><img src="/.com//2.jpg" alt="2"></p>
<p>如上图所示，如果要将p、q连通，则可以把p的根结点连到q的根结点上，但是也会出现一个<code>问题</code>：如果每次都是随意的将一个节点的根结点连到另一个节点的根结点上，那么在查找节点的时候会导致O(n)的时间复杂度，而不是O(logn)。</p>
<p>对于⼀般的树可能出现极端不平衡的情况，使得树⼏乎退化成链表，树的⾼度最坏情况下可能变成N。为了解决此问题，我们其实是希望，⼩⼀些的树接到⼤⼀些的树下⾯，这样就能避免头重脚轻，更平衡⼀些。可以引用变量来计算每次需要合并的俩个子树的节点数，这样每次个数小的合并到个数大的根结点上，最终可以让整个数达到平衡树，时间复杂度可以降到O(logn)。</p>
<p><code>路径压缩</code>可以进一步的压缩树的高度，使数高保持为常数，如下图所示：</p>
<p><img src="/.com//3.jpg" alt="2"></p>
<h3 id="990-Satisfiability-of-Equality-Equations"><a href="#990-Satisfiability-of-Equality-Equations" class="headerlink" title="990. Satisfiability of Equality Equations"></a><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">990. Satisfiability of Equality Equations</a></h3><p>​    Given an array equations of strings that represent relationships between variables, each string <code>equations[i]</code> has length <code>4</code> and takes one of two different forms: <code>&quot;a==b&quot;</code> or <code>&quot;a!=b&quot;</code>.  Here, <code>a</code> and <code>b</code> are lowercase letters (not necessarily different) that represent one-letter variable names.</p>
<p>Return <code>true</code> if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: If we assign say, a &#x3D; 1 and b &#x3D; 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We could assign a &#x3D; 1 and b &#x3D; 1 to satisfy both equations.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= equations.length &lt;= 500</code></li>
<li><code>equations[i].length == 4</code></li>
<li><code>equations[i][0]</code> and <code>equations[i][3]</code> are lowercase letters</li>
<li><code>equations[i][1]</code> is either <code>&#39;=&#39;</code> or <code>&#39;!&#39;</code></li>
<li><code>equations[i][2]</code> is <code>&#39;=&#39;</code></li>
</ol>
<p><strong>思路</strong>：</p>
<p>Union-Find</p>
<p><strong>code</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">equations</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> equationsPossible = <span class="function"><span class="keyword">function</span>(<span class="params">equations</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> string=<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>,</span><br><span class="line">          parent=<span class="built_in">Array</span>(<span class="number">26</span>),<span class="comment">//父节点</span></span><br><span class="line">          size=<span class="built_in">Array</span>(<span class="number">26</span>), <span class="comment">//各个树的"重量"</span></span><br><span class="line">          count=<span class="number">26</span>; <span class="comment">//连通分量个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;parent.length;i++) parent[i]=i;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">p,q</span>)</span>&#123; <span class="comment">//合并</span></span><br><span class="line">        <span class="keyword">let</span> rootP=find(p),</span><br><span class="line">            rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP===rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(size[rootP]&lt;size[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            size[rootQ]+=size[rootP];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            size[rootP]+=size[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// count--;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">connected</span>(<span class="params">p,q</span>)</span>&#123; <span class="comment">//是否属于一个连通分量</span></span><br><span class="line">        <span class="keyword">let</span> rootP=find(p),</span><br><span class="line">            rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP===rootQ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">x</span>)</span>&#123; <span class="comment">//路径压缩</span></span><br><span class="line">        <span class="keyword">while</span>(x!==parent[x])&#123;</span><br><span class="line">            parent[x]=parent[parent[x]];</span><br><span class="line">            x=parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    equations.forEach(<span class="function"><span class="params">str</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> c1=str.charAt(<span class="number">0</span>),</span><br><span class="line">            c2=str.charAt(<span class="number">3</span>),</span><br><span class="line">            isEqual=str.charAt(<span class="number">1</span>)===<span class="string">'='</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> c1Index=string.indexOf(c1),</span><br><span class="line">            c2Index=string.indexOf(c2);</span><br><span class="line">        <span class="keyword">if</span>(isEqual)&#123;</span><br><span class="line">            union(c1Index,c2Index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;equations.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> str=equations[i];</span><br><span class="line">        <span class="keyword">let</span> c1=str.charAt(<span class="number">0</span>),</span><br><span class="line">            c2=str.charAt(<span class="number">3</span>),</span><br><span class="line">            isEqual=str.charAt(<span class="number">1</span>)===<span class="string">'='</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> c1Index=string.indexOf(c1),</span><br><span class="line">            c2Index=string.indexOf(c2);</span><br><span class="line">        <span class="keyword">if</span>(!isEqual&amp;&amp;connected(c1Index,c2Index))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<p>使⽤ Union-Find 算法，主要是如何把原问题转化成图的动态连通性问题。对于算式合法性问题，可以直接利⽤等价关系，对于棋盘包围问题，则是利⽤⼀个虚拟节点，营造出动态连通特性。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>LRU算法</title>
    <url>/2020/02/20/LRU%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>最近最少使用算法（LRU）是大部分操作系统为最大化页面命中率而广泛采用的一种页面置换算法。该算法的思路是，发生缺页中断时，选择未使用时间最长的页面置换出去。从程序运行的原理来看，最近最少使用算法是比较接近理想的一种页面置换算法，这种算法既充分利用了内存中页面调用的历史信息，又正确反映了程序的局部问题。下面将采用双向链表+哈希表实现。</p>
<h3 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache</a></h3><p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</p>
<a id="more"></a>

<p><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a <strong>positive</strong> capacity.</p>
<p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* capacity *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; evicts key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; evicts key 1</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; returns 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; returns 4</span><br></pre></td></tr></table></figure>



<p><strong>思路</strong>：</p>
<ul>
<li>哈希表</li>
<li>双向链表</li>
</ul>
<p>哈希表和双向链表结合可以使得存取的时间复杂度都为O(1)</p>
<p>哈希表查找快，但是数据⽆固定顺序；链表有顺序之分，插⼊删除快，但是查找慢。</p>
<p><strong>code</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">capacity</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> LRUCache = <span class="function"><span class="keyword">function</span>(<span class="params">capacity</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">    <span class="keyword">this</span>.count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.head=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.tail=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.hashtable=&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.hashtable[key])&#123;</span><br><span class="line">        <span class="keyword">let</span> node=<span class="keyword">this</span>.hashtable[key];</span><br><span class="line">        <span class="keyword">if</span>(node===<span class="keyword">this</span>.head) <span class="keyword">return</span> <span class="keyword">this</span>.head.value;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node===<span class="keyword">this</span>.tail)&#123;</span><br><span class="line">            <span class="keyword">this</span>.tail=<span class="keyword">this</span>.tail.prev;</span><br><span class="line">            <span class="keyword">this</span>.head.prev=node;</span><br><span class="line">            node.next=<span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head=node;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.head.value;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.prev.next=node.next;</span><br><span class="line">            node.next.prev=node.prev;</span><br><span class="line">            <span class="keyword">this</span>.head.prev=node;</span><br><span class="line">            node.next=<span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head=node;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.head.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype.put = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.hashtable[key])&#123;</span><br><span class="line">        <span class="keyword">this</span>.hashtable[key].value=value;</span><br><span class="line">        <span class="keyword">this</span>.get(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//哈希表指向双向链表中的节点</span></span><br><span class="line">        <span class="keyword">this</span>.hashtable[key]=&#123;key,value,<span class="attr">pre</span>:<span class="literal">null</span>,<span class="attr">next</span>:<span class="literal">null</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head)&#123;</span><br><span class="line">            <span class="keyword">this</span>.head.prev=<span class="keyword">this</span>.hashtable[key];</span><br><span class="line">            <span class="keyword">this</span>.hashtable[key].next=<span class="keyword">this</span>.head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head=<span class="keyword">this</span>.hashtable[key];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.tail) <span class="keyword">this</span>.tail=<span class="keyword">this</span>.hashtable[key];</span><br><span class="line">        <span class="keyword">if</span>(++<span class="keyword">this</span>.count&gt;<span class="keyword">this</span>.capacity)&#123;</span><br><span class="line">            <span class="keyword">let</span> key=<span class="keyword">this</span>.tail.key;</span><br><span class="line">            <span class="keyword">this</span>.tail=<span class="keyword">this</span>.tail.prev;</span><br><span class="line">            <span class="keyword">this</span>.hashtable[key]=<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new LRUCache(capacity)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"> * obj.put(key,value)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>双向链表</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
</search>
