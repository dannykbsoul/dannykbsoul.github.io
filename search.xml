<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从输入URL到页面加载发生了什么?</title>
    <url>/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="1-根据域名-进行DNS域名解析"><a href="#1-根据域名-进行DNS域名解析" class="headerlink" title="1.根据域名,进行DNS域名解析"></a>1.根据域名,进行DNS域名解析</h2><p>URL一般包括几大部分：</p>
<ul>
<li><code>protocol</code>，协议头，譬如有http，ftp等</li>
<li><code>host</code>，主机域名或IP地址</li>
<li><code>port</code>，端口号</li>
<li><code>path</code>，目录路径</li>
<li><code>query</code>，即查询参数</li>
<li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</li>
</ul>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/11.png" alt></p>
<h2 id="2-拿到解析的IP地址，建立TCP连接"><a href="#2-拿到解析的IP地址，建立TCP连接" class="headerlink" title="2.拿到解析的IP地址，建立TCP连接"></a>2.拿到解析的IP地址，建立TCP连接</h2><h2 id="3-向IP地址，发送HTTP请求"><a href="#3-向IP地址，发送HTTP请求" class="headerlink" title="3.向IP地址，发送HTTP请求"></a>3.向IP地址，发送HTTP请求</h2><p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/12.png" alt></p>
<p>SSL(Secure Sockets Layer 安全套接层):主要用于web的安全传输协议,在传输层对网络连接进行加密,保障在Internet上数据传输的安全。</p>
<p>https与http的区别就是：<strong>在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析</strong></p>
<p>http端口号80</p>
<p>https端口号443</p>
<blockquote>
<p>http请求报文是由三部分组成:<code>请求行</code>、<code>请求报头</code>和<code>请求正文</code></p>
<p>请求正文:    当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。</p>
</blockquote>
<blockquote>
<p>get和post的区别:</p>
<ol>
<li>都是基于http协议的，本质都是TCP连接，没有区别，可以在URL写上参数，然后POST请求，也可以在body上写参数，然后方法使用GET请求</li>
<li>一般说的GET请求浏览器地址栏输入的参数有限制，首先说明一点，HTTP协议没有BODY和URL长度的限制，对其限制的大多是浏览器和服务器的原因。服务器是因为处理长URL要消耗比较多的资源，为了性能和安全（防止恶意构造长URL来攻击）考虑，会给URL长度加限制。</li>
<li>虽然说POST比GET相对安全，但是从传输角度来说，都是不安全的，HTTP在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文，想要安全只有HTTPS。</li>
</ol>
</blockquote>
<p><code>五层因特尔协议栈</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>应用层(dns,http) DNS解析成IP并发送http请求</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>传输层(tcp,udp) 建立tcp连接（三次握手）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>网络层(IP,ARP) IP寻址</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>数据链路层(PPP) 封装成帧</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/13.png" alt></p>
<h2 id="4-服务器处理请求并返回HTTP报文"><a href="#4-服务器处理请求并返回HTTP报文" class="headerlink" title="4.服务器处理请求并返回HTTP报文"></a>4.服务器处理请求并返回HTTP报文</h2><blockquote>
<p>http响应报文也是由三部分组成:<code>状态码</code>、<code>响应报头</code>和<code>响应报文</code></p>
<p>状态码:</p>
<ul>
<li><p>1xx：指示信息–表示请求已接收，继续处理。</p>
<blockquote>
<p><code>100 Continue</code>：该状态码说明服务器收到了请求的初始部分，并且请客户端继续发送。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>101(切换协议)</code> 请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
</blockquote>
<ul>
<li><p>2xx：成功–表示请求已被成功接收、理解、接受。</p>
<blockquote>
<p><code>200(成功)</code>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>201(已创建)</code>请求成功并且服务器创建了新的资源。</p>
<p><code>202(已接受)</code>服务器已接受请求，但尚未处理。</p>
<p><code>204(无内容)</code>服务器成功处理了请求，但没有返回任何内容。等同于请求执行成功，但是没有数据，浏览器不用刷新页面也不用导向新的页面。</p>
<p><code>206(部分内容)</code>服务器成功处理了部分 GET 请求。</p>
</blockquote>
<ul>
<li><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p>
<blockquote>
<p><code>301(永久移动)</code>请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或HEAD请求的响应）时，会自动将请求者转到新位置。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>302(临时移动)</code>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<p><code>304(未修改)</code>自从上次请求后，请求的网页未修改过，请客户端使用本地缓存。 服务器返回此响应时，不会返回网页内容。</p>
<p>浏览器需要向服务器询问一次，如果服务器端认为没有内容更新，直接返回304状态码，无需返回body内容，浏览器就会直接取缓存内容输出，这样省掉了没必要的数据传输，也就提升了访问速度。</p>
</blockquote>
<ul>
<li><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p>
<blockquote>
<p><code>400(错误请求)</code>服务器不理解请求的语法。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>401(未授权)</code>请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p>
<p><code>402</code> 该状态码是为了将来可能的需求而预留的。</p>
<p><code>403(禁止)</code>服务器拒绝请求。</p>
<p><code>404(未找到)</code>服务器找不到请求的网页。</p>
</blockquote>
<ul>
<li><p>5xx：服务器端错误–服务器未能实现合法的请求。</p>
<blockquote>
<p><code>500(服务器内部错误)</code>服务器遇到错误，无法完成请求。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>503(服务不可用)</code>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</p>
</blockquote>
</blockquote>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/14.png" alt></p>
<p>cookie以及优化:</p>
<blockquote>
<p>一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在cookie中设置httponly（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）<br>另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。</p>
<p>譬如以下场景：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line">然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有<span class="number">20</span>个静态资源）</span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line">也就是说，这<span class="number">20</span>个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure>

<p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p>
<ol>
<li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li>
<li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的cookie的，所以就避免了浪费</li>
</ol>
<p><code>dns-prefetch</code>:<code>DNS</code> 预解析技术，当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行<code>DNS</code> 的解析，减少用户等待时间，提高用户体验。 <img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/15.png" alt></p>
<p>以上是天猫中dns-prefetch的使用<img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/16.png" alt></p>
</blockquote>
<h3 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h3><p>tcp/ip层面:</p>
<ul>
<li>长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li>
<li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li>
</ul>
<p>http层面:</p>
<ul>
<li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器每进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接。</li>
<li>http1.1起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li>
</ul>
<h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><p>http1.1和http2.0区别:</p>
<ul>
<li>http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li>
<li>http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li>
</ul>
<p>新特性:</p>
<ul>
<li>多路复用（即一个tcp/ip连接可以请求多个资源）</li>
<li>首部压缩（http头部压缩，减少体积）</li>
<li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li>
<li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li>
<li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li>
</ul>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/17.png" alt></p>
<p>当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有”要请求资源”的副本，就可以直接从浏览器缓存中提取，而不是从原始服务器中提取这个资源，<code>常见的http缓存只能缓存get请求响应的资源</code>，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/18.png" alt></p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/19.png" alt></p>
<p>Pragma和Cache-control共存时，Pragma的优先级是比Cache-Control高的。</p>
<p>在chrome浏览器中返回的200状态会有两种情况：<br>1、from memory cache<br>(从内存中获取/一般缓存更新频率较高的js、图片、字体等资源)</p>
<p>2、from disk cache<br>(从磁盘中获取/一般缓存更新频率较低的js、css等资源)</p>
<p>这两种情况是chrome自身的一种缓存策略，这也是为什么chrome浏览器响应的快的原因。其他浏览返回的是已缓存状态，没有标识是从哪获取的缓存。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回<span class="number">304</span>状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回<span class="number">200</span>状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/20.png" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">协商缓存的执行流程是这样的：当浏览器第一次向服务器发送请求时，会在响应头中返回协商缓存的头属性：ETag和Last-Modified,其中ETag返回的是一个hash值，Last-Modified返回的是GMT格式的最后修改时间。然后浏览器在第二次发送请求的时候，会在请求头中带上与ETag对应的If-Not-Match，其值就是响应头中返回的ETag的值，Last-Modified对应的If-Modified-Since。服务器在接收到这两个参数后会做比较，如果返回的是<span class="number">304</span>状态码，则说明请求的资源没有修改，浏览器可以直接在缓存中取数据，否则，服务器会直接返回数据。</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/21.png" alt></p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/22.png" alt></p>
<p><strong>注意：</strong><br>ETag/If-Not-Match是在HTTP/1.1出现的，主要是解决以下问题：</p>
<ol>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件被修改了，但是内容并没有任何变化，而Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ol>
<h3 id="为什么使用HTTP缓存"><a href="#为什么使用HTTP缓存" class="headerlink" title="为什么使用HTTP缓存:"></a>为什么使用HTTP缓存:</h3><ol>
<li>减少了冗余的数据传输，节省了网费。</li>
<li>缓解了服务器的压力，大大提高了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<p>注意点：</p>
<ul>
<li><p>强缓存情况下，只要缓存还没过期，就会直接从缓存中取数据，就算服务器端有数据变化，也不会从服务器端获取了，这样就无法获取到修改后的数据。决解的办法有：在修改后的资源加上随机数,确保不会从缓存中取。</p>
<p>  例如：<br>  <a href="http://www.kimshare.club/kim/common.css?v=22324432" target="_blank" rel="noopener">http://www.kimshare.club/kim/common.css?v=22324432</a><br>  <a href="http://www.kimshare.club/kim/common.2312331.css" target="_blank" rel="noopener">http://www.kimshare.club/kim/common.2312331.css</a></p>
</li>
<li><p>尽量减少304的请求，因为我们知道，协商缓存每次都会与后台服务器进行交互，所以性能上不是很好。从性能上来看尽量多使用强缓存。</p>
</li>
<li><p>在Firefox浏览器下，使用Cache-Control: no-cache 是不生效的，其识别的是no-store。这样能达到其他浏览器使用Cache-Control: no-cache的效果。所以为了兼容Firefox浏览器，经常会写成Cache-Control: no-cache，no-store。</p>
</li>
<li><p>与缓存相关的几个header属性有：Vary、Date/Age。</p>
</li>
</ul>
<h3 id="SUMMARY"><a href="#SUMMARY" class="headerlink" title="SUMMARY"></a>SUMMARY</h3><ul>
<li>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行协商缓存策略。</li>
<li>对于协商缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</li>
</ul>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/23.png" alt="4845448-4b270d197649b733"></p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/24.png" alt></p>
<h2 id="5-浏览器解析渲染页面"><a href="#5-浏览器解析渲染页面" class="headerlink" title="5.浏览器解析渲染页面"></a>5.浏览器解析渲染页面</h2><p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/25.png" alt></p>
<p>浏览器渲染过程大体分为如下三部分：</p>
<h3 id="1-浏览器会解析三个东西："><a href="#1-浏览器会解析三个东西：" class="headerlink" title="1.浏览器会解析三个东西："></a>1.浏览器会解析三个东西：</h3><ul>
<li><p>一是HTML/SVG/XHTML，HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构。</p>
</li>
<li><p>二是CSS，解析CSS会产生CSS规则树，它和DOM结构比较像。</p>
</li>
<li><p>三是Javascript脚本，等到Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。</p>
</li>
</ul>
<h3 id="2-解析完成后，浏览器引擎会通过DOM-Tree和CSS-Rule-Tree来构造Rendering-Tree。"><a href="#2-解析完成后，浏览器引擎会通过DOM-Tree和CSS-Rule-Tree来构造Rendering-Tree。" class="headerlink" title="2.解析完成后，浏览器引擎会通过DOM Tree和CSS Rule Tree来构造Rendering Tree。"></a>2.解析完成后，浏览器引擎会通过DOM Tree和CSS Rule Tree来构造Rendering Tree。</h3><ul>
<li>Rendering Tree 渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息。</li>
<li>CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element（也就是每个Frame）。</li>
<li>然后，计算每个Frame 的位置，这又叫layout和reflow过程。</li>
</ul>
<h3 id="3-最后通过调用操作系统Native-GUI的API绘制。"><a href="#3-最后通过调用操作系统Native-GUI的API绘制。" class="headerlink" title="3.最后通过调用操作系统Native GUI的API绘制。"></a>3.最后通过调用操作系统Native GUI的API绘制。</h3><h3 id="构建DOM"><a href="#构建DOM" class="headerlink" title="构建DOM"></a>构建DOM</h3><p>浏览器会遵守一套步骤将HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/26.png" alt></p>
<ul>
<li><p>浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p>
</li>
<li><p>将字符串转换成Token，例如：<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>等。<strong>Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息</strong>。事实上，这就是Token要标识“起始标签”和“结束标签”等标识的作用。例如“title”Token的起始标签和结束标签之间的节点肯定是属于“head”的子节点。 </p>
<p>  <img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/27.png" alt></p>
<p>  上图给出了节点之间的关系，例如：“Hello”Token位于“title”开始标签与“title”结束标签之间，表明“Hello”Token是“title”Token的子节点。同理“title”Token是“head”Token的子节点。</p>
</li>
<li><p>生成节点对象并构建DOM</p>
<p>  事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。<strong>注意：带有结束标签标识的Token不会创建节点对象。</strong></p>
</li>
</ul>
<p>接下来我们举个例子，假设有段HTML文本：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面这段HTML会解析成这样：</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/28.png" alt></p>
<h3 id="构建CSSOM"><a href="#构建CSSOM" class="headerlink" title="构建CSSOM"></a>构建CSSOM</h3><p>DOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。</p>
<p>构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。 </p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/29.png" alt></p>
<p> 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归CSSOM树，然后确定具体的元素到底是什么样式。</p>
<p><strong>注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去</strong>。</p>
<h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/30.png" alt></p>
<p>在这一过程中，不是简单的将两者合并就行了。<strong>渲染树只会包括需要显示的节点和这些节点的样式信息</strong>，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</p>
<p>我们或许有个疑惑：<strong>浏览器如果渲染过程中遇到JS文件怎么处理</strong>？</p>
<p>渲染过程中，如果遇到<code>&lt;script&gt;</code>就停止渲染，执行JS代码。因为浏览器有GUI渲染线程与JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。</p>
<p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载JS文件，这也是都建议将script标签放在body标签底部的原因。当然在当下，并不是说script标签必须放在底部，因为你可以给script标签添加defer或者 async属性（下文会介绍这两者的区别）。</p>
<p><strong>JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建</strong>。</p>
<p>原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。</p>
<p>这是什么情况？</p>
<p>这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，<strong>在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM</strong>。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/31.png" alt></p>
<h3 id="布局与绘制"><a href="#布局与绘制" class="headerlink" title="布局与绘制"></a>布局与绘制</h3><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p>
<p>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。</p>
<p>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</p>
<h3 id="JS中的三种加载模式"><a href="#JS中的三种加载模式" class="headerlink" title="JS中的三种加载模式"></a>JS中的三种加载模式</h3><p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/32.png" alt></p>
<ul>
<li><p>正常模式：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  这种情况下JS会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。</p>
</li>
<li><p>async 模式：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  async模式下，JS不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS脚本会<strong>立即执行</strong>。</p>
</li>
<li><p>defer 模式：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  defer模式下，JS的加载是异步的，执行是<strong>被推迟的</strong>。等整个文档解析完成、DOMContentLoaded事件即将被触发时，被标记了defer的JS文件才会开始依次执行。</p>
</li>
</ul>
<p>从应用的角度来说，一般当我们的脚本与DOM元素和其它脚本之间的依赖关系不强时，我们会选用async；当脚本依赖于DOM元素和其它脚本的执行结果时，我们会选用defer。</p>
<h3 id="基于渲染流程的-CSS-优化建议"><a href="#基于渲染流程的-CSS-优化建议" class="headerlink" title="基于渲染流程的 CSS 优化建议"></a>基于渲染流程的 CSS 优化建议</h3><p>CSS引擎查找样式表，对每条规则都按从右到左的顺序去匹配。 看如下规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#myList</span>  <span class="selector-tag">li</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这样的写法其实很常见。大家平时习惯了从左到右阅读的文字阅读方式，会本能地以为浏览器也是从左到右匹配 CSS 选择器的，因此会推测这个选择器并不会费多少力气：#myList 是一个id选择器，它对应的元素只有一个，查找起来应该很快。定位到了myList元素，等于是缩小了范围后再去查找它后代中的li元素，没毛病。</p>
<p>事实上，<strong>CSS选择符是从右到左进行匹配的</strong>。我们这个看似“没毛病”的选择器，实际开销相当高：浏览器必须遍历页面上每个li元素，并且每次都要去确认这个li元素的父元素id是不是myList。</p>
<p>经典的通配符：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>入门CSS的时候，不少同学拿通配符清除默认样式（我曾经也是通配符用户的一员）。但这个家伙很恐怖，它会匹配所有元素，所以浏览器必须去遍历每一个元素！</p>
<p>这样一看，一个小小的CSS选择器，也有不少的门道！好的CSS选择器书写习惯，可以为我们带来非常可观的性能提升。根据上面的分析，我们至少可以总结出如下性能提升的方案：</p>
<ul>
<li><p>避免使用通配符，只对需要用到的元素进行选择。</p>
</li>
<li><p>关注可以通过继承实现的属性，避免重复匹配重复定义。</p>
</li>
<li><p>少用标签选择器。如果可以，用类选择器替代，举个🌰：</p>
<p>  错误示范：</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#myList</span> <span class="selector-tag">li</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>  课代表：</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myList_li</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要画蛇添足，id和class选择器不应该被多余的标签选择器拖后腿。举个🌰：</p>
<p>  错误示范</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myList</span><span class="selector-id">#title</span></span><br></pre></td></tr></table></figure>

<p>  课代表</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#title</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。</p>
</li>
</ul>
<h3 id="DOM为什么这么慢？"><a href="#DOM为什么这么慢？" class="headerlink" title="DOM为什么这么慢？"></a>DOM为什么这么慢？</h3><p><strong>因为收了“过路费”</strong></p>
<blockquote>
<p>把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》</p>
</blockquote>
<p>JS 是很快的，在JS中修改DOM对象也是很快的。在JS的世界里，一切是简单的、迅速的。但DOM操作并非JS 一个人的独舞，而是两个模块之间的协作。</p>
<p>上一节我们提到，JS 引擎和渲染引擎（浏览器内核）是独立实现的。当我们用JS去操作 DOM 时，本质上是JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/33.png" alt></p>
<p>过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。</p>
<p>很多时候，我们对 DOM 的操作都不会局限于访问，而是为了修改它。当我们对 DOM 的修改会引发它外观（样式）上的改变时，就会触发<strong>回流</strong>或<strong>重绘</strong>。</p>
<p>这个过程本质上还是因为我们对 DOM 的修改触发了渲染树（Render Tree）的变化所导致的：</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/34.png" alt></p>
<ul>
<li>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</li>
<li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</li>
</ul>
<p>由此我们可以看出，<strong>重绘不一定导致回流，回流一定会导致重绘</strong>。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>减少 DOM 操作：少交“过路费”、避免过度渲染</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM操作测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时我有一个假需求——我想往 container 元素里写10000句一样的话。如果我这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).innerHTML+=<span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有两个明显的可优化点。</p>
<ol>
<li><p><strong>过路费交太多了</strong>。我们每一次循环都调用 DOM 接口重新获取了一次 container 元素，相当于每次循环都交了一次过路费。前后交了 10000 次过路费，但其中 9999 次过路费都可以用<strong>缓存变量</strong>的方式节省下来：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只获取一次container</span></span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  container.innerHTML += <span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不必要的 DOM 更改太多了</strong>。我们的 10000 次循环里，修改了 10000 次 DOM 树。我们前面说过，对 DOM 的修改会引发渲染树的改变、进而去走一个（可能的）回流或重绘的过程，而这个过程的开销是很“贵”的。这么贵的操作，我们竟然重复执行了 N 多次！其实我们可以通过<strong>就事论事</strong>的方式节省下来不必要的渲染：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="keyword">let</span> content = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  <span class="comment">// 先对内容进行操作</span></span><br><span class="line">  content += <span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 内容处理好了,最后再触发DOM的更改</span></span><br><span class="line">container.innerHTML = content</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。</p>
</blockquote>
<p>在我们上面的例子里，字符串变量 content 就扮演着一个 DOM Fragment 的角色。其实无论字符串变量也好，DOM Fragment 也罢，它们本质上都作为脱离了真实 DOM 树的<strong>容器</strong>出现，用于缓存批量化的 DOM 操作。</p>
<p>前面我们直接用 innerHTML 去拼接目标内容，这样做固然有用，但却不够优雅。相比之下，DOM Fragment 可以帮助我们用更加结构化的方式去达成同样的目的，从而在维持性能的同时，保住我们代码的可拓展和可维护性。我们现在用 DOM Fragment 来改写上面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="comment">// 创建一个DOM Fragment对象作为容器</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123;</span><br><span class="line">  <span class="comment">// span此时可以通过DOM API去创建</span></span><br><span class="line">  <span class="keyword">let</span> oSpan = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>)</span><br><span class="line">  oSpan.innerHTML = <span class="string">'我是一个小测试'</span></span><br><span class="line">  <span class="comment">// 像操作真实DOM一样操作DOM Fragment对象</span></span><br><span class="line">  content.appendChild(oSpan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内容处理好了,最后再触发真实DOM的更改</span></span><br><span class="line">container.appendChild(content)</span><br></pre></td></tr></table></figure>

<p>我们运行这段代码，可以得到与前面两种写法相同的运行结果。<br>可以看出，DOM Fragment 对象允许我们像操作真实 DOM 一样去调用各种各样的 DOM API，我们的代码质量因此得到了保证。并且它的身份也非常纯粹：当我们试图将其 append 进真实 DOM 时，它会在乖乖交出自身缓存的所有后代节点后<strong>全身而退</strong>，完美地完成一个容器的使命，而不会出现在真实的 DOM 结构中。这种结构化、干净利落的特性，使得 DOM Fragment 作为经典的性能优化手段大受欢迎，这一点在 jQuery、Vue 等优秀前端框架的源码中均有体现。</p>
<h3 id="渲染的时机"><a href="#渲染的时机" class="headerlink" title="渲染的时机"></a>渲染的时机</h3><p>大家现在思考一个这样的问题：假如我想要在异步任务里进行DOM更新，我该把它包装成micro还是macro呢？</p>
<p>我们先假设它是一个macro任务，比如我在script脚本中用setTimeout来处理它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task是一个用于修改DOM的回调</span></span><br><span class="line">setTimeout(task, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>现在task被推入的macro队列。但因为script脚本本身是一个macro任务，所以本次执行完script脚本之后，下一个步骤就要去处理micro队列了，再往下就去执行了一次render，对不对？</p>
<p>但本次render我的目标task其实并没有执行，想要修改的DOM也没有修改，因此这一次的render其实是一次无效的render。</p>
<p>macro不ok，我们转向micro试试看。我用Promise来把task包装成是一个micro任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(task)</span><br></pre></td></tr></table></figure>

<p>那么我们结束了对script脚本的执行，是不是紧接着就去处理micro-task队列了？micro-task处理完，DOM 修改好了，紧接着就可以走render流程了——不需要再消耗多余的一次渲染，不需要再等待一轮事件循环，直接为用户呈现最即时的更新结果。</p>
<p>因此，我们更新DOM的时间点，应该尽可能靠近渲染的时机。<strong>当我们需要在异步任务中实现DOM修改时，把它包装成micro任务是相对明智的选择</strong>。</p>
<h3 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h3><p>回流(reflow)</p>
<p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>
<p>会导致回流的操作：</p>
<ul>
<li><p>最“贵”的操作：改变 DOM 元素的几何属性</p>
<p>  这个改变几乎可以说是“牵一发动全身”——当一个DOM元素的几何属性发生变化时，所有和它相关的节点（比如父子节点、兄弟节点等）的几何属性都需要进行重新计算，它会带来巨大的计算量。</p>
<p>  常见的几何属性有 width、height、padding、margin、left、top、border 等等。</p>
</li>
<li><p>“价格适中”的操作：改变 DOM 树的结构</p>
<p>  这里主要指的是节点的增减、移动等操作。浏览器引擎布局的过程，顺序上可以类比于树的前序遍历——它是一个从上到下、从左到右的过程。通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。</p>
</li>
<li><p>最容易被忽略的操作：获取一些特定属性的值</p>
<p>  当你要用到像这样的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 时，你就要注意了！</p>
<p>  “像这样”的属性，到底是像什么样？——这些值有一个共性，就是需要通过<strong>即时计算</strong>得到。因此浏览器为了获取这些值，也会进行回流。</p>
</li>
</ul>
<p>重绘(Repaint)</p>
<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>
<h3 id="如何规避回流与重绘"><a href="#如何规避回流与重绘" class="headerlink" title="如何规避回流与重绘"></a>如何规避回流与重绘</h3><p>CSS</p>
<ul>
<li>避免使用<code>table</code>布局。</li>
<li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li>
<li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li>
</ul>
<p>JavaScript</p>
<ul>
<li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
<li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li>
<li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<h4 id="1-将导致回流与重绘的元素缓存起来，避免频繁改动"><a href="#1-将导致回流与重绘的元素缓存起来，避免频繁改动" class="headerlink" title="1.将导致回流与重绘的元素缓存起来，避免频繁改动"></a>1.将导致回流与重绘的元素缓存起来，避免频繁改动</h4><p>有时我们想要通过多次计算得到一个元素的布局位置，我们可能会这样做：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#el</span> &#123;</span></span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"el"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 获取el元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'el'</span>)</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 这里循环判定比较简单，实际中或许会拓展出比较复杂的判定需求</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span></span><br><span class="line"><span class="actionscript">      el.style.top  = el.offsetTop  + <span class="number">10</span> + <span class="string">"px"</span>;</span></span><br><span class="line"><span class="actionscript">      el.style.left = el.offsetLeft + <span class="number">10</span> + <span class="string">"px"</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样做，每次循环都需要获取多次“敏感属性”，是比较糟糕的。我们可以将其以 JS 变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存offsetLeft与offsetTop的值</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'el'</span>) </span><br><span class="line"><span class="keyword">let</span> offLeft = el.offsetLeft, offTop = el.offsetTop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JS层面进行计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  offLeft += <span class="number">10</span></span><br><span class="line">  offTop  += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性将计算结果应用到DOM上</span></span><br><span class="line">el.style.left = offLeft + <span class="string">"px"</span></span><br><span class="line">el.style.top = offTop  + <span class="string">"px"</span></span><br></pre></td></tr></table></figure>

<h4 id="2-避免逐条改变样式，使用类名去合并样式"><a href="#2-避免逐条改变样式，使用类名去合并样式" class="headerlink" title="2.避免逐条改变样式，使用类名去合并样式"></a>2.避免逐条改变样式，使用类名去合并样式</h4><p>比如我们可以把这段单纯的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure>

<p>优化成一个有 class 加持的样子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.basic_style</span> &#123;</span></span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 200px;</span><br><span class="line">      border: 10px solid red;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span></span><br><span class="line"><span class="actionscript">  container.classList.add(<span class="string">'basic_style'</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前者每次单独操作，都去触发一次渲染树更改，从而导致相应的回流与重绘过程。</p>
<p>合并之后，等于我们将所有的更改一次性发出，用一个style请求解决掉了。</p>
<h4 id="3-将-DOM-“离线”"><a href="#3-将-DOM-“离线”" class="headerlink" title="3.将 DOM “离线”"></a>3.将 DOM “离线”</h4><p>我们上文所说的回流和重绘，都是在“该元素位于页面上”的前提下会发生的。一旦我们给元素设置 display: none，将其从页面上“拿掉”，那么我们的后续操作，将无法触发回流与重绘——这个将元素“拿掉”的操作，就叫做 DOM 离线化。</p>
<p>仍以我们上文的代码片段为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br></pre></td></tr></table></figure>

<p>离线化后就是这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.display = <span class="string">'none'</span></span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br><span class="line">container.style.display = <span class="string">'block'</span></span><br></pre></td></tr></table></figure>

<p>有的同学会问，拿掉一个元素再把它放回去，这不也会触发一次昂贵的回流吗？这话不假，但我们把它拿下来了，后续不管我操作这个元素多少次，每一步的操作成本都会非常低。当我们只需要进行很少的 DOM 操作时，DOM 离线化的优越性确实不太明显。一旦操作频繁起来，这“拿掉”和“放回”的开销都将会是非常值得的。</p>
<h4 id="4-Flush-队列：浏览器并没有那么简单"><a href="#4-Flush-队列：浏览器并没有那么简单" class="headerlink" title="4.Flush 队列：浏览器并没有那么简单"></a>4.Flush 队列：浏览器并没有那么简单</h4><p>以我们现在的知识基础，理解上面的优化操作并不难。那么现在我问大家一个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure>

<p>这段代码里，浏览器进行了多少次的回流或重绘呢？</p>
<p>“width、height、border是几何属性，各触发一次回流；color只造成外观的变化，会触发一次重绘。”——如果你立刻这么想了，说明你是个能力不错的同学，认真阅读了前面的内容。那么我们现在立刻跑一跑这段代码，看看浏览器怎么说：</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/35.png" alt></p>
<p>这里为大家截取有“Layout”和“Paint”出镜的片段（这个图是通过 Chrome 的 Performance 面板得到的，后面会教大家用这个东西）。我们看到浏览器只进行了一次回流和一次重绘——和我们想的不一样啊，为啥呢？</p>
<p>因为现代浏览器是很聪明的。浏览器自己也清楚，如果每次 DOM 操作都即时地反馈一次回流或重绘，那么性能上来说是扛不住的。于是它自己缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。因此我们看到，上面就算我们进行了 4 次 DOM 更改，也只触发了一次 Layout 和一次 Paint。</p>
<p>大家这里尤其小心这个“不得已”的时候。前面我们在介绍回流的“导火索”的时候，提到过有一类属性很特别，它们有很强的“即时性”。当我们访问这些属性时，浏览器会为了获得此时此刻的、最准确的属性值，而提前将 flush 队列的任务出队——这就是所谓的“不得已”时刻。具体是哪些属性值，我们已经在“最容易被忽略的操作”这个小模块介绍过了，此处不再赘述。</p>
<h2 id="6-关闭TCP连接"><a href="#6-关闭TCP连接" class="headerlink" title="6.关闭TCP连接"></a>6.关闭TCP连接</h2><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><h3 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS?"></a>什么是DNS?</h3><p>全称 Domain Name System ,即域名系统。</p>
<blockquote>
<p>万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS协议运行在UDP协议之上，使用端口号53。</p>
</blockquote>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>简单的说,通过域名,最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">www.dnscache.com (域名)  - DNS解析 -&gt; <span class="number">11.222</span><span class="number">.33</span><span class="number">.444</span> (IP地址)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>有dns的地方,就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对DNS结果做一定程度的缓存。</p>
<p>DNS查询过程如下:</p>
<ol>
<li>首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。</li>
<li>如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。</li>
<li>如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。</li>
<li>如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。</li>
</ol>
<h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><h3 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN?"></a>什么是CDN?</h3><p>全称 Content Delivery Network,即内容分发网络。</p>
<blockquote>
<p>10年前，还没有火车票代售点一说，12306.cn更是无从说起。那时候火车票还只能在火车站的售票大厅购买，而我所在的小县城并不通火车，火车票都要去市里的火车站购买，而从我家到县城再到市里，来回就是4个小时车程，简直就是浪费生命。后来就好了，小县城里出现了火车票代售点，甚至乡镇上也有了代售点，可以直接在代售点购买火车票，方便了不少，全市人民再也不用在一个点苦逼的排队买票了。</p>
</blockquote>
<p>简单的理解CDN就是这些代售点(缓存服务器)的承包商,他为买票者提供了便利,帮助他们在最近的地方(最近的CDN节点)用最短的时间(最短的请求时间)买到票(拿到资源),这样去火车站售票大厅排队的人也就少了。也就减轻了售票大厅的压力(起到分流作用,减轻服务器负载压力)。</p>
<p>用户在浏览网站的时候，CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了。</p>
<h3 id="CDN缓存-1"><a href="#CDN缓存-1" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>关于CDN缓存,在浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cache-control: max-age   <span class="comment">//后面会提到</span></span><br></pre></td></tr></table></figure>

<p>的字段来设置CDN边缘节点数据缓存时间。</p>
<p>当浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p>
<h3 id="CDN-优势"><a href="#CDN-优势" class="headerlink" title="CDN 优势"></a>CDN 优势</h3><ol>
<li>CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。</li>
<li>大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载。</li>
</ol>
<h2 id="浏览器缓存-http缓存"><a href="#浏览器缓存-http缓存" class="headerlink" title="浏览器缓存(http缓存)"></a>浏览器缓存(http缓存)</h2><p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p>
<h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</p>
<ol>
<li><p><strong>Service Worker</strong></p>
<p> Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p> Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p>
</li>
<li><p><strong>Memory Cache</strong></p>
<p> Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 <strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了</strong>。</p>
<p> <strong>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</strong><br> 这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p>
<p> 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。</p>
<p> <img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/2.png" alt></p>
<p> 内存缓存中有一块重要的缓存资源是preloader相关指令（例如<code>&lt;link rel=&quot;prefetch&quot;&gt;</code>）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。</p>
<p> 需要注意的事情是，<strong>内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验</strong>。</p>
</li>
<li><p><strong>Disk Cache</strong></p>
<p> Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，<strong>比之 Memory Cache 胜在容量和存储时效性上</strong>。</p>
<p> 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p>
<p> <strong>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？</strong></p>
<ul>
<li>对于大文件来说，大概率是不存储在内存中的，反之优先</li>
<li>当前系统内存使用率高的话，文件优先存储进硬盘</li>
</ul>
</li>
<li><p><strong>Push Cache</strong></p>
<p> Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</strong>，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p>
<ul>
<li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li>
<li>可以推送 no-cache 和 no-store 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
</li>
</ol>
<p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p>
<p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，<strong>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置HTTP Header来实现的</strong>。</p>
<h3 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h3><p>浏览器发起HTTP请求 – 服务器响应该请求，<strong>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢</strong>？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，<strong>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的</strong>。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/3.png" alt></p>
<ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ul>
<p>根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</strong></p>
<ol>
<li><p><strong>Expires</strong></p>
<p> <strong>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点</strong>。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>
<p> <strong>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效</strong>。<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code>表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。</p>
</li>
<li><p><strong>Cache-Control</strong></p>
<p> 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当<code>Cache-Control:max-age=300</code>时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p>
<p> Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p>
<p> <img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/7.png" alt></p>
<ol>
<li><p><strong>public</strong>：<strong>所有内容都将被缓存（客户端和代理服务器都可缓存）</strong>。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。</p>
</li>
<li><p><strong>private</strong>：<strong>所有内容只有客户端可以缓存</strong>，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</p>
</li>
<li><p><strong>no-cache</strong>：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。<strong>需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</strong></p>
</li>
<li><p><strong>no-store</strong>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p>
</li>
<li><p><strong>max-age</strong>：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效</p>
</li>
<li><p><strong>s-maxage</strong>（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。<strong>s-maxage的优先级高于max-age</strong>。如果存在s-maxage，则会覆盖掉max-age和Expires header。</p>
</li>
<li><p><strong>max-stale</strong>：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。</p>
</li>
<li><p><strong>min-fresh</strong>：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/4.png" alt></p>
<p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。</p>
</li>
</ol>
</li>
<li><p><strong>Expires和Cache-Control两者对比</strong></p>
<blockquote>
<p>其实这两者差别不大，区别就在于Expires是http1.0的产物，Cache-Control是http1.1的产物，<strong>两者同时存在的话，Cache-Control优先级高于Expires</strong>；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p>
</blockquote>
</li>
</ol>
<p>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，<strong>那我们如何获知服务器端内容是否已经发生了更新呢</strong>？此时我们需要用到协商缓存策略。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况</strong>：</p>
<ul>
<li>协商缓存生效，返回304和Not Modified</li>
<li>商缓存失效，返回200和请求结果</li>
</ul>
<p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p>
<ol>
<li><p><strong>Last-Modified和If-Modified-Since</strong></p>
<p> 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；</p>
<p> 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。</p>
<p> <img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/5.png" alt></p>
<p> <strong>但是Last-Modified存在一些弊端</strong>：</p>
<ul>
<li><p>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成Last-Modified被修改，服务端不能命中缓存导致发送相同的资源</p>
</li>
<li><p>因为Last-Modified只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</p>
<p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在HTTP/1.1出现了 <code>ETag</code> 和<code>If-None-Match</code></p>
</li>
</ul>
</li>
<li><p><strong>ETag和If-None-Match</strong></p>
<p> <strong>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成</strong>。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p>
<p> <img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/6.png" alt></p>
</li>
<li><p><strong>两者之间对比</strong></p>
<ul>
<li><p>首先在精确度上，Etag要优于Last-Modified。</p>
<p>  Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</p>
</li>
<li><p>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</p>
</li>
<li><p>第三在优先级上，服务器校验优先考虑Etag。</p>
</li>
</ul>
</li>
</ol>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p><strong>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存</strong>。具体流程图如下：</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1.png" alt></p>
<p><strong>如果什么缓存策略都没设置，那么浏览器会怎么处理？</strong></p>
<p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。</p>
<h3 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h3><h3 id="1-频繁变动的资源"><a href="#1-频繁变动的资源" class="headerlink" title="1.频繁变动的资源"></a>1.频繁变动的资源</h3><blockquote>
<p>Cache-Control: no-cache</p>
</blockquote>
<p>对于频繁变动的资源，首先需要使用<code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>
<h3 id="2-不常变化的资源"><a href="#2-不常变化的资源" class="headerlink" title="2.不常变化的资源"></a>2.不常变化的资源</h3><blockquote>
<p>Cache-Control: max-age=31536000</p>
</blockquote>
<p>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 <code>max-age=31536000</code> (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。<br>在线提供的类库 (如 <code>jquery-3.3.1.min.js</code>, <code>lodash.min.js</code> 等) 均采用这个模式。</p>
<h3 id="用户行为对浏览器缓存的影响"><a href="#用户行为对浏览器缓存的影响" class="headerlink" title="用户行为对浏览器缓存的影响"></a>用户行为对浏览器缓存的影响</h3><p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p>
<ul>
<li>打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li>
<li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。</li>
<li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了 <code>Pragma: no-cache</code>),服务器直接返回 200 和最新内容。</li>
</ul>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>我们先来通过表格学习下这几种存储方式的区别：</p>
<p>从下表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">cookie</th>
<th align="center">localStorage</th>
<th align="center">sessionStorage</th>
<th align="center">indexDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据生命周期</td>
<td align="center">一般由服务器生成，可以设置过期时间</td>
<td align="center">除非被清理，否则一直存在</td>
<td align="center">页面关闭就清理</td>
<td align="center">除非被清理，否则一直存在</td>
</tr>
<tr>
<td align="center">数据存储大小</td>
<td align="center">4K</td>
<td align="center">5M</td>
<td align="center">5M</td>
<td align="center">无限</td>
</tr>
<tr>
<td align="center">与服务端通信</td>
<td align="center">每次都会携带在 header 中，对于请求性能影响</td>
<td align="center">不参与</td>
<td align="center">不参与</td>
<td align="center">不参与</td>
</tr>
</tbody></table>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p><strong>Cookie 的本职工作并非本地存储，而是“维持状态”</strong>。 因为<strong>HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存</strong>。通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie。</p>
<p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/8.png" alt></p>
<p>cookie生成方式有两种：</p>
<ol>
<li><p>http response header中的set-cookie</p>
<p> domain被设置为设置Cookie页面的主机名，我们也可以手动设置domain的值。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2018</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;<span class="comment">//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>js中可以通过document.cookie可以读写cookie，以键值对的形式展示</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">'age=20;domain=.baidu.com'</span></span><br></pre></td></tr></table></figure>

<p> <strong>Domain标识指定了哪些域名可以接受Cookie</strong>。如果没有设置domain，就会自动绑定到执行语句的当前域。 如果设置为”.baidu.com”，则所有以”baidu.com”结尾的域名都可以访问该Cookie。</p>
</li>
</ol>
<p>缺陷：</p>
<ol>
<li><p>Cookie 不够大</p>
<p> 这里需注意：各浏览器的cookie每一个<code>name=value</code>的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。</p>
</li>
<li><p>过多的 Cookie 会带来巨大的性能浪费</p>
<p> cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过cdn（存储静态文件的）的域名和主站的域名分开来解决。</p>
</li>
<li><p>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。</p>
</li>
</ol>
<p>对于 <code>cookie</code> 来说，我们还需要注意安全性。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value</td>
<td align="center">如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td>
</tr>
<tr>
<td align="center">http-only</td>
<td align="center">不能通过 JS 访问 Cookie，减少 XSS 攻击</td>
</tr>
<tr>
<td align="center">secure</td>
<td align="center">只能在协议为 HTTPS 的请求中携带</td>
</tr>
<tr>
<td align="center">same-site</td>
<td align="center">规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</td>
</tr>
</tbody></table>
<p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。</p>
<p><strong>HTML5中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage和localStorage</strong>。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><ul>
<li>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</li>
<li>大小为5M左右</li>
<li>仅在客户端使用，不和服务端进行通信</li>
<li>接口封装较好</li>
</ul>
<p>基于上面的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度(根据第一请求返回时，将一些不变信息直接存储在本地)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(<span class="built_in">window</span>.localStorage)&#123;</span></span><br><span class="line"><span class="actionscript">  localStorage.setItem（<span class="string">'name'</span>,<span class="string">'world'</span>）</span></span><br><span class="line"><span class="actionscript">  localStorage.setItem（<span class="string">'gender'</span>,<span class="string">'female'</span>）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">var</span> name=localStorage.getItem(<span class="string">'name'</span>)</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">var</span> gender=localStorage.getItem(<span class="string">'gender'</span>)</span></span><br><span class="line"><span class="javascript">		<span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).innerHTML=name</span></span><br><span class="line"><span class="javascript">		<span class="built_in">document</span>.getElementById(<span class="string">'gender'</span>).innerHTML=gender</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用场景：图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/9.png" alt></p>
<h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，<strong>即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享</strong>；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。</p>
<ul>
<li>会话级别的浏览器存储</li>
<li>大小为5M左右</li>
<li>仅在客户端使用，不和服务端进行通信</li>
<li>接口封装较好</li>
</ul>
<p>基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。</p>
<h2 id="sessionStorage-、localStorage-和-cookie-之间的区别"><a href="#sessionStorage-、localStorage-和-cookie-之间的区别" class="headerlink" title="sessionStorage 、localStorage 和 cookie 之间的区别"></a>sessionStorage 、localStorage 和 cookie 之间的区别</h2><p>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p>
<ul>
<li>共同点：都是保存在浏览器端，且都遵循同源策略。</li>
<li>不同点：在于生命周期与作用域的不同</li>
</ul>
<p>作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了<code>协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下</code>。</p>
<p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p>
<p>localStorage和sessionStorage都具有相同的操作方法，例如有<code>setItem</code>,<code>getItem</code>,<code>removeItem</code>,<code>clear</code>等。</p>
<p>localStorage和sessionStorage的key和length属性实现遍历，例如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> storage = <span class="built_in">window</span>.localStorage; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len = storage.length; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> key = storage.key(i); </span><br><span class="line">    <span class="keyword">var</span> value = storage.getItem(key); </span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">"="</span> + value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p>
<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 是一种低级API，<strong>用于客户端存储大量结构化数据(包括文件和blobs)</strong>。该API使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p>
<ul>
<li><p>键值对储存</p>
<p>  IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
</li>
<li><p>异步</p>
<p>  IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
</li>
<li><p>支持事务</p>
<p>  IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
</li>
<li><p>同源限制</p>
<p>  IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
</li>
<li><p>储存空间大</p>
<p>  IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
</li>
<li><p>支持二进制储存</p>
<p>  IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
</li>
</ul>
<p>操作：在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。</p>
<ol>
<li><p>建立打开IndexedDB —-<code>window.indexedDB.open(&quot;testDB&quot;)</code></p>
<p> 我们得到的是一个<code>IDBOpenDBRequest</code>对象，而我们希望得到的DB对象在其result属性中</p>
<p> <img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/10.png" alt></p>
<p> 除了result，IDBOpenDBRequest接口定义了几个重要属性:</p>
<p> onerror: 请求失败的回调函数句柄</p>
<p> onsuccess:请求成功的回调函数句柄</p>
<p> onupgradeneeded:请求数据库版本变化句柄</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openDB</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> request=<span class="built_in">window</span>.indexedDB.open(name)<span class="comment">//建立打开IndexedDB</span></span><br><span class="line">	request.onerror=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'open indexdb error'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	request.onsuccess=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">		myDB.db=e.target.result<span class="comment">//这是一个 IDBDatabase对象，这就是IndexedDB对象</span></span><br><span class="line">		<span class="built_in">console</span>.log(myDB.db)<span class="comment">//此处就可以获取到db实例</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myDB=&#123;</span><br><span class="line">	name:<span class="string">'testDB'</span>,</span><br><span class="line">	version:<span class="string">'1'</span>,</span><br><span class="line">	db:<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">openDB(myDB.name)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭IndexedDB—-<code>indexdb.close()</code></p>
</li>
<li><p>删除IndexedDB—-<code>window.indexedDB.deleteDatabase(indexdb)</code></p>
</li>
</ol>
<h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><h1 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h1><h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>cookie: 登录网站，第一天输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。</p>
<p>session: session一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。</p>
<h2 id="cookie-1"><a href="#cookie-1" class="headerlink" title="cookie"></a>cookie</h2><p>服务器通过设置<code>set-cookie</code>这个响应头，将cookie信息返回给浏览器，浏览器将响应头中的cookie信息保存在本地，当下次向服务器发送HTTP请求时，浏览器会自动将保存的这些cookie信息添加到请求头中。</p>
<p>通过cookie，服务器就会识别出浏览器，从而保证返回的数据是这个用户的。</p>
<ul>
<li>通过<code>set-cookie</code>设置</li>
<li>下次请求会自动带上</li>
<li>键值对，可设置多个</li>
</ul>
<h3 id="cookie属性"><a href="#cookie属性" class="headerlink" title="cookie属性"></a>cookie属性</h3><ul>
<li>max-age<ul>
<li>过期时间有多长</li>
<li>默认在浏览器关闭时失效</li>
</ul>
</li>
<li>expires<ul>
<li>到哪个时间点过期</li>
</ul>
</li>
<li>secure<ul>
<li>表示这个cookie只会在https的时候才会发送</li>
</ul>
</li>
<li>HttpOnly<ul>
<li>设置后无法通过在js中使用document.cookie访问</li>
<li>保障安全，防止攻击者盗用用户cookie</li>
</ul>
</li>
<li>domain<ul>
<li>表示该cookie对于哪个域是有效的。</li>
</ul>
</li>
</ul>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><ul>
<li>存放在服务器的一种用来存放用户数据的类似HashTable的结构</li>
<li>浏览器第一次发送请求时，服务器自动生成了HashTable和SessionID来唯一标识这个hash表，并将sessionID存放在cookie中通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的sessionID随着cookie发送到服务器上，服务器从请求中提取sessionID，并和保存的所有sessionID进行对比，找到这个用户对应的hash表。<ul>
<li>一般这个值是有时间限制的，超时后销毁，默认30min</li>
</ul>
</li>
<li>当用户在应用程序的web页面间挑转时，存储在session对象中的变量不会丢失而是在整个用户会话中一直存在下去。</li>
<li>session依赖于cookie，因为sessionID是存放在cookie中的。</li>
</ul>
<h2 id="sesssion与cookie的区别"><a href="#sesssion与cookie的区别" class="headerlink" title="sesssion与cookie的区别"></a>sesssion与cookie的区别</h2><ul>
<li>cookie存在客户端，session存在于服务端。</li>
<li>cookie在客户端中存放，容易伪造，不如session安全</li>
<li>session会消耗大量服务器资源，cookie在每次HTTP请求中都会带上，影响网络性能</li>
<li>域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而<a href="http://www.a.com的Session在api.a.com下都不能用" target="_blank" rel="noopener">www.a.com的Session在api.a.com下都不能用</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>跨域解决方案</title>
    <url>/2020/03/08/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><strong>同源策略</strong></p>
<p>同源要求</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://www.example.com/dir2/other.html：同源</span><br><span class="line">http://example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</span><br></pre></td></tr></table></figure>

<p>限制范围</p>
<ul>
<li>cookie、localstorage和 indexDB无法读取</li>
<li>DOM 无法获得</li>
<li>Ajax 请求不能发送</li>
</ul>
<a id="more"></a>

<h1 id="一、JSONP"><a href="#一、JSONP" class="headerlink" title="一、JSONP"></a>一、JSONP</h1><p><strong>JSONP(JSON with Padding)</strong> 是一种跨域请求方式。主要原理是利用了<code>script</code>标签可以跨域请求的特性，由其 <code>src</code> 属性发送请求到服务器，服务器返回 <code>JavaScript</code>代码，浏览器接受响应，然后就直接执行了，这和通过 <code>script</code> 标签引用外部文件的原理是一样的。</p>
<p><strong>JSONP</strong>由两部分组成：<code>回调函数</code>和<code>数据</code>，回调函数一般是在浏览器控制，作为参数发往服务器端（当然，你也可以固定回调函数的名字，但客户端和服务器端的名称一定要一致）。当服务器响应时，服务器端就会把该函数和数据拼成字符串返回。 </p>
<p><strong>JSONP</strong>的请求过程：</p>
<ul>
<li>请求阶段：浏览器创建一个 <code>script</code> 标签，并给其<code>src</code> 赋值(类似 <code>http://example.com/api/?callback=jsonpCallback</code>）。</li>
<li>发送请求：当给<code>script</code>的<code>src</code>赋值时，浏览器就会发起一个请求。</li>
<li>数据响应：服务端将要返回的<code>数据</code>作为参数和<code>函数名称</code>拼接在一起(格式类似”<code>jsonpCallback({name: &#39;abc&#39;})</code>”)返回。当浏览器接收到了响应数据，由于发起请求的是 <code>script</code>，所以相当于直接调用 <code>jsonpCallback</code> 方法，并且传入了一个参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo 函数将会被调用 传入后台返回的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'通过jsonp获取后台数据:'</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过手动创建一个 script 标签发送一个 get 请求</span></span><br><span class="line"><span class="comment"> * 并利用浏览器对 &lt;script&gt; 不进行跨域限制的特性绕过跨域问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]; <span class="comment">// 获取head元素 把js放里面</span></span><br><span class="line">    <span class="keyword">let</span> js = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    js.src = <span class="string">'http://domain:port/testJSONP?a=1&amp;b=2&amp;callback=foo'</span>; <span class="comment">// 设置请求地址</span></span><br><span class="line">    head.appendChild(js); <span class="comment">// 这一步会发送请求</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台代码</span></span><br><span class="line"><span class="comment">// 因为是通过 script 标签调用的 后台返回的相当于一个 js 文件</span></span><br><span class="line"><span class="comment">// 根据前端传入的 callback 的函数名直接调用该函数</span></span><br><span class="line"><span class="comment">// 返回的是 'foo(3)'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testJSONP</span>(<span class="params">callback, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;a + b&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
<p><strong>使用注意</strong></p>
<p>基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了(所以如今它也基本被淘汰了)</p>
<p><img src="/2020/03/08/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1.png" alt></p>
<h1 id="二、CORS"><a href="#二、CORS" class="headerlink" title="二、CORS"></a>二、CORS</h1><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。</p>
<p>浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<p><strong>两种请求</strong>：</p>
<ol>
<li>简单请求<ul>
<li>请求方式为HEAD、POST或者GET</li>
<li>http头信息不超出以下字段：Accept、Accept-Language、Content-Language、Last-Event-ID、 Content-Type(限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain)</li>
</ul>
</li>
<li>非简单请求</li>
</ol>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>在头信息之中，增加一个Origin字段。</p>
<p><strong>Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</strong></p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<ul>
<li>Access-Control-Allow-Origin :该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求</li>
<li>Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</li>
<li>Access-Control-Expose-Headers:该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</li>
</ul>
<p>如果要把cookie发送到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段，另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://api.alice.com/cors'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">   Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">   Access-Control-Request-Method: PUT</span><br><span class="line">   Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">   Host: api.alice.com</span><br><span class="line">   Accept-Language: en-US</span><br><span class="line">   Connection: keep-alive</span><br><span class="line">   User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>

<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p>
<p>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>
<ul>
<li>Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header</li>
</ul>
<p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="built_in">Date</span>: Mon, <span class="number">01</span> Dec <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> GMT</span><br><span class="line">Server: Apache/<span class="number">2.0</span><span class="number">.61</span> (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br><span class="line">Keep-Alive: timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>

<p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
]]></content>
  </entry>
  <entry>
    <title>DOM事件机制</title>
    <url>/2020/03/07/DOM%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>面试的时候经常会被问到，事件代理是利用了事件的什么机制？一般我们都会说，是利用了事件冒泡机制，但具体冒泡机制在事件代理的过程了起到了什么关键作用，我想大部分人也是不了解的。静下心来，仔细看了下有关事件和事件代理问题，自己终于找到了合适的答案。</p>
<p>在揭晓答案之前，还是来看一下事件的基本知识</p>
<p>事件操作在项目中使用频繁，jQuery封装了我们对DOM的事件操作，NodeJS中也有 <code>events</code> 这个事件操作模块，几乎各种语言都有事件模型，事件使用频繁，事件模型可以使我们从复杂的业务中抽象出独立的逻辑，跨越模块与模块之间传递数据，以达到类似解耦的概念。</p>
<p>不同的环境有不同的事件模型，在浏览器中，DOM事件模型比较特殊，重温一下DOM事件模型，再来自定义一个事件模型。</p>
<a id="more"></a>

<h2 id="DOM事件发展"><a href="#DOM事件发展" class="headerlink" title="DOM事件发展"></a>DOM事件发展</h2><p>DOM事件：用户或浏览器执行的动作，如<code>click</code><br>事件处理程序：是响应某个事件的函数，如 <code>onclick()</code>也叫事件侦听器</p>
<p>DOM有4次版本更新，与DOM版本变更，产生了3种不同的DOM事件定义 DOM0级、DOM2级、DOM3级。由于DOM1级中没有事件的相关内容，所以没有DOM1级事件。</p>
<h3 id="DOM0级事件"><a href="#DOM0级事件" class="headerlink" title="DOM0级事件"></a>DOM0级事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">"alert('click')"</span>&gt;</span>HTML事件处理程序<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>问题</p>
<ol>
<li>HTML代码域JavaScript代码紧密的耦合在一起，没有实现相互分离，在进行代码的更新与维护的时候就显得异常困难。</li>
<li>扩展事件处理程序的作用域链在不同浏览器当中会导致不同的结果。</li>
<li>如果不采用调用函数的方式，而是像例子中那样直接书写代码，那么代码的通用性很差，会使得整站的代码量很大，通用性差。如果提取出来，存放在函数当中，那么，会面临另一个问题——当函数还没有被定义，只是HTML、CSS代码加载完毕，用户进行点击，会完全没有反应。</li>
</ol>
<p>DOM0中基本事件模型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.innerHTML);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>问题<br>当希望为同一个元素/标签绑定多个同类型事件的时候（如，为上面的这个p标签绑定3个点击事件），是不被允许的。</p>
<h3 id="DOM2级事件"><a href="#DOM2级事件" class="headerlink" title="DOM2级事件"></a>DOM2级事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.addEventListener(event-name, callback, useCapture)</span><br></pre></td></tr></table></figure>

<p><code>event-name</code>: 事件名称，可以是标准的DOM事件<br><code>callbakc</code>: 回调函数，当事件触发时，函数会被注入一个参数为当前的事件对象 <code>event</code><br><code>useCapture</code>: 是否以捕获的方式触发，默认为true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, test, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    alert((e.target || e.srcElement).innerHTML);</span><br><span class="line">    btn.removeEventListener(<span class="string">"click"</span>, test)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IE9-:attachEvent()与detachEvent()。</span></span><br><span class="line"><span class="comment">//IE9+/chrom/FF:addEventListener()和removeEventListener()</span></span><br></pre></td></tr></table></figure>

<p>IE9以下的IE浏览器不支持 <code>addEventListener()和removeEventListener()</code>，使用 <code>attachEvent()与detachEvent()</code> 代替，因为IE9以下是不支持事件捕获的，所以也没有第三个参数，第一个事件名称前要加<code>on</code>。</p>
<h3 id="DOM3级事件"><a href="#DOM3级事件" class="headerlink" title="DOM3级事件"></a>DOM3级事件</h3><p>在DOM2级事件的基础上添加了更多的事件类型</p>
<ol>
<li>UI事件，当用户与页面上的元素交互时触发，如：load、scroll</li>
<li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li>
<li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</li>
<li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li>
<li>文本事件，当在文档中输入文本时触发，如：textInput</li>
<li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li>
<li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</li>
<li>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified<br> 同时DOM3级事件也允许使用者自定义一些事件。<br> 关于自定义事件，低版本的处理方式是不一样的，本篇主要介绍DOM事件流和自定义事件模型，这里就不展开讨论了，具体可参考<a href="http://www.zhangxinxu.com/wordpress/2012/04/js-dom%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/" target="_blank" rel="noopener">漫谈js自定义事件、DOM/伪DOM自定义事件</a></li>
</ol>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><h3 id="为什么是有事件流？"><a href="#为什么是有事件流？" class="headerlink" title="为什么是有事件流？"></a>为什么是有事件流？</h3><p>假如在一个button上注册了一个click事件，又在其它父元素div上注册了一个click事件，那么当我们点击button，是先触发父元素上的事件，还是button上的事件呢，这就需要一种约定去规范事件的执行顺序，就是事件执行的流程。</p>
<p>浏览器在发展的过程中出现实了两种不同的规范</p>
<ul>
<li>IE9以下的IE浏览器使用的是事件冒泡，先从具体的接收元素，然后逐步向上传播到不具体的元素。</li>
<li>Netscapte采用的是事件捕获，先由不具体的元素接收事件，最具体的节点最后才接收到事件。</li>
<li>而W3C制定的Web标准中，是同时采用了两种方案，事件捕获和事件冒泡都可以。</li>
</ul>
<h2 id="事件阶段"><a href="#事件阶段" class="headerlink" title="事件阶段"></a>事件阶段</h2><p>既然有了事件捕获和事件冒泡，那就应该约定是事件的流向，是先捕获还是先冒泡，所以W3C标准中规定了事件流的三个阶段的顺序：</p>
<ol>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ol>
<p><img src="http://img.aitter.cn/121ba0d37798d6d23227d2dd49d0e58c_articlex.png" alt="img"><br>有了捕获和冒泡这两种模式，我们就可以很好的控制父元素和子元素的事件执行顺序了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span> id=<span class="string">"wrap"</span>&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box box1"</span> id=<span class="string">"box1"</span>&gt;box1</span><br><span class="line">		&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box box2"</span> id=<span class="string">"box2"</span>&gt;box2</span><br><span class="line">			&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box box3"</span> id=<span class="string">"box3"</span>&gt;box3&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;</span><br><span class="line">	&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	&lt;div class="loger" id="loger"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">var useCapture = true; /</span><span class="regexp">/是否使用捕获模式</span></span><br><span class="line"><span class="regexp">var type = useCapture ? '捕获':'冒泡';</span></span><br><span class="line"><span class="regexp">var logerBox = document.getElementById('loger');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 捕获 与 冒泡</span></span><br><span class="line"><span class="regexp">Array.from(document.querySelectorAll('.box')).forEach(v =&gt; &#123;</span></span><br><span class="line"><span class="regexp">	var id = v.id;</span></span><br><span class="line"><span class="regexp">	v.addEventListener('click',function(e)&#123;</span></span><br><span class="line"><span class="regexp">		logerBox.innerHTML += '&lt;p&gt;'+type+': '+id+'&lt;/</span>p&gt;<span class="string">';</span></span><br><span class="line"><span class="string">		//e.stopPropagation()</span></span><br><span class="line"><span class="string">	&#125;, useCapture);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>当我想事件的执行顺序是先父元素再子元素时，就使用事件捕获模式<br>点击box3时<br><img src="http://img.aitter.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-22%20%E4%B8%8A%E5%8D%8810.46.02.png" alt="img"><br>如果是想先子元素上的事件先执行再执行父元素的上的事件时，使用冒泡模式<br>点击box3时<br><img src="http://img.aitter.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-22%20%E4%B8%8A%E5%8D%8810.46.35.png" alt="img"></p>
<p>这里我们是同时让这三个元素上的事件都执行了，那么我们要想实现点击某个元素，只触发这个元素本身的事件，而不影响父元素或子元素呢？</p>
<p>所以这里需要一种方法，不让事件向下捕获或向上冒泡</p>
<p>所以有了 <code>e.stopPropagation()</code> 方法，用于阻止事件的继续传递。</p>
<p>执行这条语句，无论我们是使用捕获模式还是冒泡模式，事件都不会继续传递，只会响应我们点击的元素。<br>点击box3时<br><img src="http://img.aitter.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-22%20%E4%B8%8A%E5%8D%8810.46.56.png" alt="img"></p>
<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>那么利用事件冒泡或捕获的机制，我们可以对事件绑定做一些优化。<br>在JS中，如果我们注册的事件越来越多，页面的性能就越来越差，因为：</p>
<ul>
<li>函数是对象，会占用内存，内存中的对象越多，浏览器性能越差</li>
<li>注册的事件一般都会指定DOM元素，事件越多，导致DOM元素访问次数越多，会延迟页面交互就绪时间。</li>
<li>删除子元素的时候不用考虑删除绑定事件</li>
</ul>
<p>为了减少事件的注册，我们使用一个代理元素是代理它内部所有子元素事件</p>
<p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>
<p>优点：</p>
<ul>
<li><p>减少内存消耗，提高性能</p>
<p>  假设有一个列表，列表之中有大量的列表项，我们需要在点击每个列表项的时候响应一个事件</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 例4</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item n<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。借助事件代理，我们只需要给父容器ul绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的click行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。</p>
</li>
<li><p>动态绑定事件</p>
<p>  在很多时候，我们需要通过用户操作动态的增删列表项元素，如果一开始给每个子元素绑定事件，那么在列表发生变化时，就需要重新给新增的元素绑定事件，给即将删去的元素解绑事件，如果用事件代理就会省去很多这样麻烦。</p>
</li>
</ul>
<p>还是上面的例子，执行下面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'wrap'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(e.target.classList.contains(<span class="string">'box'</span>))&#123;</span><br><span class="line">		logerBox.innerHTML += <span class="string">'&lt;p&gt;'</span>+type+<span class="string">': '</span>+e.target.id+<span class="string">'&lt;/p&gt;'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, useCapture)</span><br></pre></td></tr></table></figure>



<h2 id="答案揭晓"><a href="#答案揭晓" class="headerlink" title="答案揭晓"></a>答案揭晓</h2><p>上面的例子中，无论<code>useCapture</code>是true或是false，都能正确触发事件，那是不是说事件代理和事件冒泡没有关系呢？</p>
<p>SF上关于这个问题的争论 <a href="https://segmentfault.com/a/1190000000470398" target="_blank" rel="noopener">事件委托和冒泡机制有关系吗？</a></p>
<p>先来看两个问题<br>在同一个元素上同时绑定事件冒泡事件和事件捕获事件，谁先触发？<br>在同一个元素上同时绑定事件冒泡事件，第一个阻止事件传播，第二个会触发吗？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'box3'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'box3-stop:'</span>,e.target.id)</span><br><span class="line">	e.stopPropagation();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'box3'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'box3-冒泡:'</span>, e.target.id)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'box3'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'box3-捕获:'</span>, e.target.id)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'box3'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'box3-冒泡:'</span>, e.target.id)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'box3'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'box3-stop:'</span>,e.target.id)</span><br><span class="line">	e.stopPropagation();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*点击输出：</span></span><br><span class="line"><span class="comment">box3-stop: box3</span></span><br><span class="line"><span class="comment">box3-冒泡: box3</span></span><br><span class="line"><span class="comment">box3-捕获: box3</span></span><br><span class="line"><span class="comment">box3-冒泡: box3</span></span><br><span class="line"><span class="comment">box3-stop: box3*/</span></span><br></pre></td></tr></table></figure>

<p>其实要回答这两个问题，首先要弄清楚捕获和冒泡的适用性，捕获和冒泡发生在嵌套元素绑定了相同的事件类型，才需要捕获和冒泡的机制去控制，单个元素上绑定的事件，在触发的时候，其实就是事件三个阶段中的目标阶段，此时，这个元素本身的事件的触发顺序，只和绑定顺序有关，和是否捕获，是否冒泡，是否阻止了事件传播都没有关系。<strong>stopImmediatePropagation 既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发。而 stopPropagation 只能实现前者的效果</strong>。</p>
<p>再来看看 <code>e.target</code> 与 <code>e.currentTarget</code><br><code>e.target</code> 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口。<br><code>e.currentTarget</code> 返回其监听器触发事件的节点，即当前处理该事件的元素、文档或窗口。在捕获和冒泡阶段，该属性是非常有用的，因为在这两个节点，它不同于 target 属性。</p>
<p>在事件代理中，<code>e.target</code> 是当前点击的目标元素，而 <code>e.currentTarget</code> 始终是事件的代理元素</p>
<p><strong>event.currentTarget始终是监听事件者，而event.target是事件的真正发出者</strong>。</p>
<p>回到上面的问题：无论<code>useCapture</code>是 <code>true</code> 或是 <code>false</code> ，都能正确触发事件，那是不是说事件代理和事件冒泡没有关系呢？</p>
<p>嵌套关系 box1 &gt; box2 &gt; box3</p>
<ol>
<li>代理事件使用事件冒泡，先给box2注册一个click事件，并阻止冒泡，点击box3和box2，这里就不能触发代理事件了，说明子元素是利用了事件冒泡向上查找到事件，并将本身的 <code>e.target</code> 传递给了事件函数，box2阻止了冒泡，所以在事件向上流动中断了，就无法触发事件代理函数了。</li>
<li>代理事件使用事件捕获，先给box2注册一个click事件，并阻止捕获，点击box3和box2，这里仍然可以正常触发代理事件，原因其实是父元素上的事件是捕获还是冒泡，其实子元素是不关心的，子元素事件流动一直都是冒泡行为。父元素的捕获或冒泡只会影响父元素的父级元素。</li>
</ol>
<h3 id="取消默认操作"><a href="#取消默认操作" class="headerlink" title="取消默认操作"></a>取消默认操作</h3><p>取消默认操作 w3c 的方法是 e.preventDefault()，IE 则是使用 e.returnValue = false;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelHandler</span>(<span class="params">event</span>)</span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> event = event || <span class="built_in">window</span>.event;  <span class="comment">//用于IE  </span></span><br><span class="line">  <span class="keyword">if</span>(event.preventDefault) event.preventDefault();  <span class="comment">//标准技术  </span></span><br><span class="line">  <span class="keyword">if</span>(event.returnValue) event.returnValue = <span class="literal">false</span>;  <span class="comment">//IE  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//用于处理使用对象属性注册的处理程序  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>事件轮询机制</title>
    <url>/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h1><p>JavaScript是一门==<strong>单线程</strong>、<strong>非阻塞</strong>==的脚本语言，目的是为了实现与浏览器交互。</p>
<a id="more"></a>

<blockquote>
<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
</blockquote>
<blockquote>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
</blockquote>
<blockquote>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
</blockquote>
<h1 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h1><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>当我们调用一个方法的时候，js会生成一个与这个方法相对应的执行环境，也叫执行上下文，这个执行环境存在着这个方法的私有作用域、参数、this对象等等。因为js是单线程的，同一时间只能执行一个方法，所以当一系列的方法被依次调用的时候，js会先解析这些方法，把其中的<strong>同步任务</strong>按照执行顺序排队到一个地方，这个地方叫做执行栈。</p>
<h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><p>当我们发出一个ajax请求，他并不会立刻返回结果，为了防止浏览器出现假死或者空白，主线程会把这个异步任务挂起(pending)，继续执行执行栈中的其他任务，等异步任务返回结果后，js会将这个<strong>异步任务</strong>按照执行顺序，加入到与执行栈不同的另一个队列，也就是事件队列。</p>
<p><img src="/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/1.png" alt></p>
<h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">10000000</span>)</span><br></pre></td></tr></table></figure>

<p>流程：</p>
<ul>
<li><code>task()</code>进入Event Table并注册,计时开始。</li>
<li>执行<code>sleep</code>函数，很慢，非常慢，计时仍在继续。</li>
<li>3秒到了，计时事件<code>timeout</code>完成，<code>task()</code>进入Event Queue，但是<code>sleep</code>也太慢了吧，还没执行完，只好等着。</li>
<li><code>sleep</code>终于执行完了，<code>task()</code>终于从Event Queue进入了主线程执行。</li>
</ul>
<p>即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</p>
<h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><p>对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，对于<code>setInterval(fn,ms)</code>来说，我们已经知道不是每过<code>ms</code>秒会执行一次<code>fn</code>，而是每过<code>ms</code>秒，会有<code>fn</code>进入Event Queue。一旦<strong>setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了</strong>。</p>
<h4 id="Promise与process-nextTick-callback"><a href="#Promise与process-nextTick-callback" class="headerlink" title="Promise与process.nextTick(callback)"></a>Promise与process.nextTick(callback)</h4><p><code>process.nextTick(callback)</code>类似node.js版的”setTimeout”，在事件循环的下一次循环中调用callback回调函数。</p>
<p>除了广义的同步任务和异步任务，还有进一步的细分：</p>
<h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2><p>(macro)task（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p>
<p>浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，<strong>会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染</strong>，流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(macro)task-&gt;渲染-&gt;(macro)task-&gt;...</span><br></pre></td></tr></table></figure>

<p>(macro)task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)</p>
<h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>microtask（又称为微任务），<strong>可以理解是在当前 task 执行结束后立即执行的任务</strong>。也就是说，在当前task任务后，下一个task之前，在渲染之前。</p>
<p>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。</p>
<p>microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)</p>
<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p>在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：</p>
<ul>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>
</ul>
<p><img src="/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/2.png" alt></p>
<h4 id="Promise和async中的立即执行"><a href="#Promise和async中的立即执行" class="headerlink" title="Promise和async中的立即执行"></a>Promise和async中的立即执行</h4><p>我们知道Promise中的异步体现在<code>then</code>和<code>catch</code>中，所以写在Promise中的代码是被当做同步任务立即执行的。而在async/await中，在出现await出现之前，其中的代码也是立即执行的。那么出现了await时候发生了什么呢？</p>
<h4 id="await做了什么"><a href="#await做了什么" class="headerlink" title="await做了什么?"></a>await做了什么?</h4><p><strong>实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">	<span class="keyword">await</span> async2();</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve(async2()).then(() =&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/3.png" alt></p>
<p>当执行栈中的任务清空，主线程会先检查微任务队列中是否有任务，如果有，就将微任务队列中的任务依次执行，直到微任务队列为空，之后再检查宏任务队列中是否有任务，如果有，则每次取出第一个宏任务加入到执行栈中，之后再清空执行栈，检查微任务，以此循环… …</p>
<h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请写出输出内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>==<strong>分析：</strong>==</p>
<ol>
<li><p>首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。所以，上面例子的第一步执行如下图所示：</p>
<p> <img src="/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/4.png" alt></p>
</li>
<li><p>然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 <code>console</code> 语句，直接输出 <code>script start</code>。输出之后，script 任务继续往下执行，遇到 <code>setTimeout</code>，其作为一个宏任务源，则会先将其任务分发到对应的队列中：</p>
<p> <img src="/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/5.png" alt></p>
</li>
<li><p>script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出<code>async1 start</code>。</p>
<p> 遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出<code>async2</code>，然后将await后面的代码也就是<code>console.log(&#39;async1 end&#39;)</code>加入到microtask中的Promise队列中，接着跳出async1函数来执行后面的代码。</p>
<p> <img src="/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/6.png" alt></p>
</li>
<li><p>script任务继续往下执行，遇到Promise实例。由于Promise中的函数是立即执行的，而后续的 <code>.then</code> 则会被分发到 microtask 的 <code>Promise</code> 队列中去。所以会先输出 <code>promise1</code>，然后执行 <code>resolve</code>，将 <code>promise2</code> 分配到对应队列。</p>
<p> <img src="/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/7.png" alt></p>
</li>
<li><p>script任务继续往下执行，最后只有一句输出了 <code>script end</code>，至此，全局任务就执行完毕了。</p>
<p> 根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。</p>
<p> 因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中， <code>Promise</code> 队列有的两个任务<code>async1 end</code>和<code>promise2</code>，因此按先后顺序输出 <code>async1 end，promise2</code>。当所有的 Microtasks 执行完毕之后，表示第一轮的循环就结束了。</p>
</li>
<li><p>第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 <code>setTimeout</code>，取出直接输出即可，至此整个流程结束。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>第一轮事件循环流程分析如下：</p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li>
<li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</li>
<li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li>
<li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。我们记为<code>then1</code>。</li>
<li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">宏任务Event Queue</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td align="center">setTimeout1</td>
<td align="center">process1</td>
</tr>
<tr>
<td align="center">setTimeout2</td>
<td align="center">then1</td>
</tr>
</tbody></table>
<ul>
<li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li>
<li>我们发现了<code>process1</code>和<code>then1</code>两个微任务。</li>
<li>执行<code>process1</code>,输出6。</li>
<li>执行<code>then1</code>，输出8。</li>
</ul>
<p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从<code>setTimeout1</code>宏任务开始：</p>
<ul>
<li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。<code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">宏任务Event Queue</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td align="center">setTimeout2</td>
<td align="center">process2</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">then2</td>
</tr>
</tbody></table>
<ul>
<li>第二轮事件循环宏任务结束，我们发现有<code>process2</code>和<code>then2</code>两个微任务可以执行。</li>
<li>输出3。</li>
<li>输出5。</li>
<li>第二轮事件循环结束，第二轮输出2，4，3，5。</li>
<li>第三轮事件循环开始，此时只剩setTimeout2了，执行。</li>
<li>直接输出9。</li>
<li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li>
<li>直接执行<code>new Promise</code>，输出11。</li>
<li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">宏任务Event Queue</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">process3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">then3</td>
</tr>
</tbody></table>
<ul>
<li>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>。</li>
<li>输出10。</li>
<li>输出12。</li>
<li>第三轮事件循环结束，第三轮输出9，11，10，12。</li>
</ul>
<p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a1 start'</span>)</span><br><span class="line">    <span class="keyword">await</span> a2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">a1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'promise2.then'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise2.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">script start</span><br><span class="line">a1 start</span><br><span class="line">a2</span><br><span class="line">promise2</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">a1 end</span><br><span class="line">promise2.then</span><br><span class="line">promise3   <span class="comment">//这俩个别弄反了，等微任务做完了会再去执行宏任务。</span></span><br><span class="line">setTimeout <span class="comment">//</span></span><br></pre></td></tr></table></figure>



<h2 id="promise与setTimeout-判断执行顺序"><a href="#promise与setTimeout-判断执行顺序" class="headerlink" title="promise与setTimeout 判断执行顺序"></a>promise与setTimeout 判断执行顺序</h2><p>promise和setTimeout都会将事件放入异步队列，但setTimeout即便是写0，也会有4ms的延迟</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'begin'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout 1'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'promise 1'</span>);</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'promise 2'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure>

<p>答案</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">end</span><br><span class="line">setTimeout <span class="number">1</span></span><br><span class="line">a</span><br><span class="line">promise <span class="number">1</span></span><br><span class="line">b</span><br><span class="line">promise <span class="number">2</span></span><br><span class="line">setTimeout2</span><br></pre></td></tr></table></figure>

<h2 id="async函数的使用"><a href="#async函数的使用" class="headerlink" title="async函数的使用"></a>async函数的使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">func, times, wait</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">const</span> repeatFunc = repeat(alert, <span class="number">4</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 会alert4次 helloworld, 每次间隔3秒</span></span><br><span class="line">repeatFunc(<span class="string">'hellworld'</span>);</span><br><span class="line"><span class="comment">// 会alert4次 worldhellp, 每次间隔3秒</span></span><br><span class="line">repeatFunc(<span class="string">'worldhello'</span>)</span><br></pre></td></tr></table></figure>

<p>我自己的实现，没有成功。这种实现是setTimeout新建了两个，然而只清理了一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">func, times, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(<span class="literal">null</span>, args);</span><br><span class="line">      count ++;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'count'</span>, count, <span class="string">"times"</span>, times)</span><br><span class="line">      <span class="keyword">if</span>( count &gt;= times) &#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">const</span> repeatFunc = repeat(<span class="built_in">console</span>.log, <span class="number">4</span>, <span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 会alert4次 helloworld, 每次间隔3秒</span></span><br><span class="line">repeatFunc(<span class="string">'hellworld'</span>);</span><br><span class="line"><span class="comment">// 会alert4次 worldhellp, 每次间隔3秒</span></span><br><span class="line">repeatFunc(<span class="string">'worldhello'</span>);</span><br></pre></td></tr></table></figure>

<p>正确解法：使用 async/await来实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">seconds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(res, seconds);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">func, times, s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            func.apply(<span class="literal">null</span>, args);</span><br><span class="line">            <span class="keyword">await</span> wait(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> log = <span class="built_in">console</span>.log</span><br><span class="line"><span class="keyword">let</span> repeatFunc = repeat(log,<span class="number">4</span>,<span class="number">3000</span>)</span><br><span class="line">repeatFunc(<span class="string">'HelloWorld'</span>)</span><br><span class="line">repeatFunc(<span class="string">'WorldHello'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="async执行练习"><a href="#async执行练习" class="headerlink" title="async执行练习"></a>async执行练习</h2><ul>
<li>await后面的才是异步的，之前都是同步的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);    <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;     </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>);        <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);    <span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);    <span class="comment">// 8</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);      <span class="comment">// 4</span></span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);  <span class="comment">// 7</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);      <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>



<h3 id="关于-setTimeOut、setImmediate、process-nextTick-的比较"><a href="#关于-setTimeOut、setImmediate、process-nextTick-的比较" class="headerlink" title="关于 setTimeOut、setImmediate、process.nextTick()的比较"></a>关于 setTimeOut、setImmediate、process.nextTick()的比较</h3><h4 id="setTimeout-1"><a href="#setTimeout-1" class="headerlink" title="setTimeout()"></a>setTimeout()</h4><p>将事件插入到了事件队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。 当主线程时间执行过长，无法保证回调会在事件指定的时间执行。 浏览器端每次setTimeout会有4ms的延迟，当连续执行多个setTimeout，有可能会阻塞进程，造成性能问题。</p>
<h4 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h4><p>事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行。和setTimeout(fn,0)的效果差不多。 服务端node提供的方法。浏览器端最新的api也有类似实现:window.setImmediate,但支持的浏览器很少。</p>
<h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h4><p>插入到事件队列尾部，但在下次事件队列之前会执行。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。 大致流程：当前”执行栈”的尾部–&gt;下一次Event Loop（主线程读取”任务队列”）之前–&gt;触发process指定的回调函数。 服务器端node提供的办法。用此方法可以用于处于异步延迟的问题。 可以理解为：此次不行，预约下次优先执行。</p>
<h1 id="Node中的Event-Loop"><a href="#Node中的Event-Loop" class="headerlink" title="Node中的Event Loop"></a>Node中的Event Loop</h1><h2 id="一、线程与进程"><a href="#一、线程与进程" class="headerlink" title="一、线程与进程"></a>一、线程与进程</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>我们经常说JS是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？</p>
<p>官方的说法是：<strong>进程是CPU资源分配的最小单位；线程是CPU调度的最小单位</strong>。这两句话并不好理解，我们先来看张图：<br><a href="https://camo.githubusercontent.com/0194774edbffee2453bf37a17e92b325db680867/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f392f313638333333633134633835643739343f773d34343326683d31363226663d706e6726733d3239343733" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/0194774edbffee2453bf37a17e92b325db680867/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f392f313638333333633134633835643739343f773d34343326683d31363226663d706e6726733d3239343733" alt="img"></a></p>
<ul>
<li>进程好比图中的工厂，有单独的专属自己的工厂资源。</li>
<li>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说<strong>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</strong>；</li>
<li>工厂的空间是工人们共享的，这象征<strong>一个进程的内存空间是共享的，每个线程都可用这些共享内存</strong>。</li>
<li>多个工厂之间独立存在。</li>
</ul>
<h3 id="2-多进程与多线程"><a href="#2-多进程与多线程" class="headerlink" title="2.多进程与多线程"></a>2.多进程与多线程</h3><ul>
<li>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li>
<li>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li>
</ul>
<p>以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p>
<h2 id="二、浏览器内核"><a href="#二、浏览器内核" class="headerlink" title="二、浏览器内核"></a>二、浏览器内核</h2><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p>
<p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>
<ul>
<li>GUI 渲染线程</li>
<li>JavaScript引擎线程</li>
<li>定时触发器线程</li>
<li>事件触发线程</li>
<li>异步http请求线程</li>
</ul>
<h3 id="1-GUI渲染线程"><a href="#1-GUI渲染线程" class="headerlink" title="1.GUI渲染线程"></a>1.GUI渲染线程</h3><ul>
<li>主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。</li>
<li>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。</li>
<li>该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。</li>
</ul>
<h3 id="2-JS引擎线程"><a href="#2-JS引擎线程" class="headerlink" title="2.JS引擎线程"></a>2.JS引擎线程</h3><ul>
<li>该线程当然是主要负责处理 JavaScript脚本，执行代码。</li>
<li>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。</li>
<li>当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。</li>
</ul>
<h3 id="3-定时器触发线程"><a href="#3-定时器触发线程" class="headerlink" title="3.定时器触发线程"></a>3.定时器触发线程</h3><ul>
<li>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。</li>
<li>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。</li>
</ul>
<h3 id="4-事件触发线程"><a href="#4-事件触发线程" class="headerlink" title="4.事件触发线程"></a>4.事件触发线程</h3><ul>
<li>主要负责将准备好的事件交给 JS引擎线程执行。</li>
</ul>
<p>比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。</p>
<h3 id="5-异步http请求线程"><a href="#5-异步http请求线程" class="headerlink" title="5.异步http请求线程"></a>5.异步http请求线程</h3><ul>
<li>负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。</li>
<li>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。</li>
</ul>
<h2 id="三、Node-中的-Event-Loop"><a href="#三、Node-中的-Event-Loop" class="headerlink" title="三、Node 中的 Event Loop"></a>三、Node 中的 Event Loop</h2><h3 id="1-Node简介"><a href="#1-Node简介" class="headerlink" title="1.Node简介"></a>1.Node简介</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。</p>
<p><a href="https://camo.githubusercontent.com/58779606d55020cd7c815402ccdaea48dcd94aec/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31312f313638336438313637346630373665623f773d35343326683d32323326663d706e6726733d3831373535" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/58779606d55020cd7c815402ccdaea48dcd94aec/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31312f313638336438313637346630373665623f773d35343326683d32323326663d706e6726733d3831373535" alt="img"></a></p>
<ul>
<li>V8引擎解析JavaScript脚本。</li>
<li>解析后的代码，调用Node API。</li>
<li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>V8引擎再将结果返回给用户。</li>
</ul>
<h3 id="2-六个阶段"><a href="#2-六个阶段" class="headerlink" title="2.六个阶段"></a>2.六个阶段</h3><p>其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>
<p><a href="https://camo.githubusercontent.com/992acfd5750f98c9a56a9a96e95111bdf7cc7669/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343162643938363063316565393f773d33353926683d33333126663d706e6726733d3130353037" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/992acfd5750f98c9a56a9a96e95111bdf7cc7669/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343162643938363063316565393f773d33353926683d33333126663d706e6726733d3130353037" alt="img"></a></p>
<p>流程：</p>
<ol>
<li>执行全局Script的同步代码</li>
<li>执行microtask微任务，先执行所有nextTick Queue中的所有任务，再执行other microtask中的所有任务</li>
<li>开始执行macrotask宏任务，共6个阶段，从第一个阶段开始执行相应每一个阶段macrotask中的所有宏任务，⚠️注意，这里是所有每个阶段宏任务队列的所有任务，在浏览器的Event Loop中只取宏队列中的第一个任务出来执行，每一个阶段的macrotask任务执行完毕后，开始执行微任务，也就是步骤2</li>
<li>Timers Queue -&gt; microtask Queue -&gt;I/O Queue -&gt; microtask Queue -&gt; Check Queue -&gt; microtask Queue -&gt; Close Callback Queue -&gt; microtask Queue -&gt; Timers Queue……</li>
</ol>
<p>从上图中，大致看出node中的事件循环的顺序：</p>
<p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p>
<ul>
<li>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li>
<li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li>
<li>idle, prepare 阶段：仅node内部使用</li>
<li>poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</li>
<li>check 阶段：执行 setImmediate() 的回调</li>
<li>close callbacks 阶段：执行 socket 的 close 事件回调</li>
</ul>
<p>注意：<strong>上面六个阶段都不包括 process.nextTick()</strong>(下文会介绍)</p>
<p>接下去我们详细介绍<code>timers</code>、<code>poll</code>、<code>check</code>这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。</p>
<h4 id="1-timer"><a href="#1-timer" class="headerlink" title="(1) timer"></a>(1) timer</h4><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。<br>同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行</strong>。</p>
<h4 id="2-poll"><a href="#2-poll" class="headerlink" title="(2) poll"></a>(2) poll</h4><p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p>
<p>1.回到 timer 阶段执行回调</p>
<p>2.执行 I/O 回调</p>
<p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p>
<ul>
<li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>
<li>如果 poll 队列为空时，会有两件事发生<ul>
<li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li>
<li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li>
</ul>
</li>
</ul>
<p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p>
<h4 id="3-check阶段"><a href="#3-check阶段" class="headerlink" title="(3) check阶段"></a>(3) check阶段</h4><p>setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。<br>我们先来看个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line"><span class="comment">//start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出start end，并将2个timer依次放入timer队列）,会先去执行微任务（<strong>这点跟浏览器端的一样</strong>），所以打印出promise3</li>
<li>然后进入timers阶段，执行timer1的回调函数，打印timer1，并将promise.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；这点跟浏览器端相差比较大，<strong>timers阶段有几个setTimeout/setInterval都会依次执行</strong>，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于Node与浏览器的 Event Loop 差异，下文还会详细介绍）。</li>
</ul>
<h3 id="3-Micro-Task-与-Macro-Task"><a href="#3-Micro-Task-与-Macro-Task" class="headerlink" title="3.Micro-Task 与 Macro-Task"></a>3.Micro-Task 与 Macro-Task</h3><p>Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。</p>
<ul>
<li>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。</li>
<li>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。</li>
</ul>
<h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4.注意点"></a>4.注意点</h3><h4 id="1-setTimeout-和-setImmediate"><a href="#1-setTimeout-和-setImmediate" class="headerlink" title="(1) setTimeout 和 setImmediate"></a>(1) setTimeout 和 setImmediate</h4><p>二者非常相似，区别主要在于调用时机不同。</p>
<ul>
<li><p>setImmediate 设计在poll阶段完成时执行，即check阶段；</p>
</li>
<li><p>setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> <span class="title">immediate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</p>
</li>
<li><p>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的<br>  进入事件循环也是需要成本的，如果在准备时候花费了大于1ms的时间，那么在timer阶段就会直接执行 setTimeout回调</p>
</li>
<li><p>如果准备时间花费小于1ms，那么就是setImmediate回调先执行了</p>
</li>
</ul>
<p>但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。</p>
<h4 id="2-process-nextTick"><a href="#2-process-nextTick" class="headerlink" title="(2) process.nextTick"></a>(2) process.nextTick</h4><p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line"> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">   process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</span></span><br></pre></td></tr></table></figure>

<h2 id="四、Node与浏览器的-Event-Loop-差异"><a href="#四、Node与浏览器的-Event-Loop-差异" class="headerlink" title="四、Node与浏览器的 Event Loop 差异"></a>四、Node与浏览器的 Event Loop 差异</h2><p><strong>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务</strong>。<br><a href="https://camo.githubusercontent.com/71b607cd363565c5d61299d31d9fd72b889de645/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343162616431636461373431663f773d3130353126683d33343426663d706e6726733d3932363835" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/71b607cd363565c5d61299d31d9fd72b889de645/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343162616431636461373431663f773d3130353126683d33343426663d706e6726733d3932363835" alt="img"></a></p>
<p>接下我们通过一个例子来说明两者区别：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>浏览器端运行结果：<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></p>
<p>浏览器端的处理过程如下：</p>
<p><a href="https://camo.githubusercontent.com/b325e476f0336804b8bdbcd7e4e3674a52dfbd80/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343164363339326538663533373f773d36313126683d33343126663d67696626733d373232393739" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/b325e476f0336804b8bdbcd7e4e3674a52dfbd80/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343164363339326538663533373f773d36313126683d33343126663d67696626733d373232393739" alt="img"></a></p>
<p>Node端运行结果分两种情况：</p>
<ul>
<li>如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li>
<li>如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。<ul>
<li>如果是第二个定时器还未在完成队列中，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li>
<li>如果是第二个定时器已经在完成队列中，则最后的结果为<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code>(下文过程解释基于这种情况下)</li>
</ul>
</li>
</ul>
<p>1.全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；</p>
<p>2.首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；</p>
<p>3.至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2</p>
<p>Node端的处理过程如下：<br><a href="https://camo.githubusercontent.com/34b3491060826045c67bd57c6dcf97222620a722/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343164356638353436383034373f773d35393826683d33333326663d67696626733d343637363635" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/34b3491060826045c67bd57c6dcf97222620a722/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f31322f313638343164356638353436383034373f773d35393826683d33333326663d67696626733d343637363635" alt="img"></a></p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p>
<ul>
<li>Node端，microtask 在事件循环的各个阶段之间执行</li>
<li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'start'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line">-------------------</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">start: <span class="number">4.474</span>ms</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>流程：</p>
<ol>
<li>先执行script整体代码，遇到setTimeout放入Timer Queue中，遇到setImmediate放入Check Queue中</li>
<li>第一段的script宏任务执行完毕，此时输出为3、4、6、8，开始执行微任务，process.nextTick永远优先于其他微任务，接着输出为7、5</li>
<li>这时开始去Timer Queue中查看有没有任务，如果此时setTimeout delay已经到了，放入了Queue中，则剩下的顺序为2、1</li>
<li>否则，按顺序查找到了Check Queue，执行1，经过一轮循环再次到了Timer Queue，发现setTimeout在里面，执行2</li>
<li>每次Queue中都会穿插着微任务队列执行。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>洗牌算法</title>
    <url>/2020/03/03/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>缘起：如何真正的打乱数组?</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码看似可以打乱，但是不是真正的打乱。做下测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> times = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    arr.sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">JSON</span>.stringify(arr);</span><br><span class="line">    res[key] ? res[key]++ : res[key] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了方便展示，转换成百分比</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> res) &#123;</span><br><span class="line">    res[key] = res[key] / times * <span class="number">100</span> + <span class="string">'%'</span></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'[2,1,3]'</span>: <span class="string">'25.027%'</span>,</span><br><span class="line">    <span class="string">'[1,2,3]'</span>: <span class="string">'25.05%'</span>,</span><br><span class="line">    <span class="string">'[1,3,2]'</span>: <span class="string">'12.361%'</span>,</span><br><span class="line">    <span class="string">'[3,2,1]'</span>: <span class="string">'12.447%'</span>,</span><br><span class="line">    <span class="string">'[2,3,1]'</span>: <span class="string">'12.545%'</span>,</span><br><span class="line">    <span class="string">'[3,1,2]'</span>: <span class="string">'12.57%'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出末尾数字是3的概率为50%，而不是想象中的33%。</p>
<p>究其原因是因为<code>sort函数底层是使用插入排序实现的</code></p>
<p>所以初始为[1,2,3]的时候，插入排序从2开始，和前面做比较，此时有50%的几率顺序50%的几率逆序，所以</p>
<p>[1,2,3] [2,1,3]出现几率都为50% 50%。接下来的操作如下图所示：</p>
<table>
<thead>
<tr>
<th align="left">数组</th>
<th>i = 1</th>
<th>i = 2</th>
<th>总计</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[1, 2, 3]</td>
<td>50% [1, 2, 3]</td>
<td>50% [1, 2, 3]</td>
<td>25% [1, 2, 3]</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td>25% [1, 3, 2]</td>
<td>12.5% [1, 3, 2]</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td>25% [3, 1, 2]</td>
<td>12.5% [3, 1, 2]</td>
</tr>
<tr>
<td align="left"></td>
<td>50% [2, 1, 3]</td>
<td>25% [2, 1, 3]</td>
<td>50% [2, 1, 3]</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td>25% [2, 3, 1]</td>
<td>12.5% [2, 3, 1]</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td>25% [3, 2, 1]</td>
<td>12.5% [3, 2, 1]</td>
</tr>
</tbody></table>
<p>洗牌算法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length; i; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i);</span><br><span class="line">        [arr[i - <span class="number">1</span>], arr[random]] = [arr[random], arr[i - <span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------</span><br><span class="line">&#123; <span class="string">'[3,1,2]'</span>: <span class="string">'16.825000000000003%'</span>,</span><br><span class="line">  <span class="string">'[2,1,3]'</span>: <span class="string">'16.739%'</span>,</span><br><span class="line">  <span class="string">'[1,2,3]'</span>: <span class="string">'16.688%'</span>,</span><br><span class="line">  <span class="string">'[1,3,2]'</span>: <span class="string">'16.72%'</span>,</span><br><span class="line">  <span class="string">'[3,2,1]'</span>: <span class="string">'16.697%'</span>,</span><br><span class="line">  <span class="string">'[2,3,1]'</span>: <span class="string">'16.331%'</span> &#125;</span><br></pre></td></tr></table></figure>

<p>洗牌算法，或者说随机乱置算法的<strong>正确性衡量标准是：对于每种可能的结果出现的概率必须相等，也就是说要足够随机。</strong></p>
<p>蒙特卡罗方法验证正确性：采样越多，越近似最优解。</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h1><a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> getInstance() &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经new过1个实例</span></span><br><span class="line">        <span class="keyword">if</span> (!Singleton.instance) &#123;</span><br><span class="line">            <span class="comment">// 若这个唯一的实例不存在，那么先创建它</span></span><br><span class="line">            Singleton.instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果这个唯一的实例已经存在，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> Singleton.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = Singleton.getInstance()</span><br><span class="line"><span class="keyword">const</span> s2 = Singleton.getInstance()</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">s1 === s2</span><br></pre></td></tr></table></figure>

<p>闭包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleton</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Single = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Single();</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> Single();</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2);</span><br></pre></td></tr></table></figure>

<h2 id="实现一个全局的模态框"><a href="#实现一个全局的模态框" class="headerlink" title="实现一个全局的模态框"></a>实现一个全局的模态框</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>单例模式弹框<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#modal</span> &#123;</span></span><br><span class="line">    height: 200px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    line-height: 200px;</span><br><span class="line">    position: fixed;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'open'</span>&gt;</span>打开弹框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'close'</span>&gt;</span>关闭弹框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 核心逻辑，这里采用了闭包思路来实现单例模式</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> Modal = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> modal = <span class="literal">null</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      if (!modal) &#123;</span><br><span class="line"><span class="javascript">        modal = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="actionscript">        modal.innerHTML = <span class="string">'我是一个全局唯一的Modal'</span></span></span><br><span class="line"><span class="actionscript">        modal.id = <span class="string">'modal'</span></span></span><br><span class="line"><span class="actionscript">        modal.style.display = <span class="string">'none'</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(modal)</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> modal</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line"><span class="actionscript">  <span class="comment">// ES6</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">// class Modal &#123;</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//   static getInstance() &#123;</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//     console.log(Modal.instance)</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//     if (!Modal.instance) &#123;</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//       Modal.instance = document.createElement('div')</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//       Modal.instance.innerHTML = '我是一个全局唯一的Modal'</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//       Modal.instance.id = 'modal'</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//       Modal.instance.style.display = 'none'</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//       document.body.appendChild(Modal.instance)</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//     &#125;</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//     return Modal.instance</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">// &#125;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">  <span class="comment">// 点击打开按钮展示模态框</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">'open'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> modal = <span class="keyword">new</span> Modal()</span></span><br><span class="line"><span class="actionscript">    modal.style.display = <span class="string">'block'</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">  <span class="comment">// 点击关闭按钮隐藏模态框</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">'close'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> modal = <span class="keyword">new</span> Modal()</span></span><br><span class="line">    if (modal) &#123;</span><br><span class="line"><span class="actionscript">      modal.style.display = <span class="string">'none'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="2-观察者模式"><a href="#2-观察者模式" class="headerlink" title="2.观察者模式"></a>2.观察者模式</h1><blockquote>
<p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns</p>
</blockquote>
<h2 id="实现一个Event-Bus-Event-Emitter"><a href="#实现一个Event-Bus-Event-Emitter" class="headerlink" title="实现一个Event Bus/ Event Emitter"></a>实现一个Event Bus/ Event Emitter</h2><p>Event Bus（Vue、Flutter 等前端框架中有出镜）和 Event Emitter（Node中有出镜）出场的“剧组”不同，但是它们都对应一个共同的角色——<strong>全局事件总线</strong>。<br>全局事件总线，严格来说不能说是观察者模式，而是发布-订阅模式。</p>
<h3 id="在Vue中使用Event-Bus来实现组件间的通讯"><a href="#在Vue中使用Event-Bus来实现组件间的通讯" class="headerlink" title="在Vue中使用Event Bus来实现组件间的通讯"></a>在Vue中使用Event Bus来实现组件间的通讯</h3><p>创建一个 Event Bus（本质上也是 Vue 实例）并导出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventBus</span><br></pre></td></tr></table></figure>

<p>在主文件里引入EventBus，并挂载到全局：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'EventBus的文件路径'</span></span><br><span class="line">Vue.prototype.bus = bus</span><br></pre></td></tr></table></figure>

<p>订阅事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里func指someEvent这个事件的监听函数</span></span><br><span class="line"><span class="keyword">this</span>.bus.$on(<span class="string">'someEvent'</span>, func)</span><br></pre></td></tr></table></figure>

<p>发布（触发）事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里params指someEvent这个事件被触发时回调函数接收的入参</span></span><br><span class="line"><span class="keyword">this</span>.bus.$emit(<span class="string">'someEvent'</span>, params)</span><br></pre></td></tr></table></figure>

<p>大家会发现，整个调用过程中，没有出现具体的发布者和订阅者，全程只有bus这个东西一个人在疯狂刷存在感。这就是全局事件总线的特点——所有事件的发布/订阅操作，必须经由事件中心，禁止一切“私下交易”！</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">//用于存储事件与回调之间的对应关系</span></span><br><span class="line">        <span class="keyword">this</span>.eventPool = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// on方法用于安装事件监听器，它接受目标事件名和回调函数作为参数</span></span><br><span class="line">    on(eventName, cb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventPool[eventName] ? <span class="keyword">this</span>.eventPool[eventName].push(cb) : <span class="keyword">this</span>.eventPool[eventName] = [cb];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// emit方法用于触发目标事件，它接受事件名和监听函数入参作为参数</span></span><br><span class="line">    emit(eventName, ...args) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventPool[eventName] &amp;&amp; <span class="keyword">this</span>.eventPool[eventName].forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(...args));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 移除某个事件回调队列里的指定回调函数</span></span><br><span class="line">    off(eventName, cb) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eventPool[eventName]) &#123;</span><br><span class="line">            <span class="keyword">let</span> index = <span class="keyword">this</span>.eventPool[eventName].indexOf(cb);</span><br><span class="line">            <span class="keyword">this</span>.eventPool[eventName].splice(index, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.eventPool[eventName].length === <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>.eventPool[eventName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为事件注册单次监听器</span></span><br><span class="line">	<span class="comment">//将订阅的方法再包裹一层函数，在执行后将此函数移除即可。</span></span><br><span class="line">    once(eventName, cb) &#123;</span><br><span class="line">        <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.on(eventName, <span class="function"><span class="keyword">function</span> <span class="title">_cb</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            cb(...args);</span><br><span class="line">            self.off(eventName, _cb);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">event.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'f1触发'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">event.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'f2触发'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'f3触发'</span>);</span><br><span class="line">&#125;</span><br><span class="line">event.emit(<span class="string">'click'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(event.eventPool);</span><br><span class="line">event.once(<span class="string">'once'</span>, f3);</span><br><span class="line"><span class="built_in">console</span>.log(event.eventPool);</span><br><span class="line">event.emit(<span class="string">'once'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(event.eventPool);</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">f1触发</span><br><span class="line">f2触发</span><br><span class="line">&#123; <span class="attr">click</span>: [ [<span class="built_in">Function</span>: f1], [<span class="built_in">Function</span>: f2] ] &#125;</span><br><span class="line">&#123; <span class="attr">click</span>: [ [<span class="built_in">Function</span>: f1], [<span class="built_in">Function</span>: f2] ],</span><br><span class="line">  once: [ [<span class="built_in">Function</span>: _cb] ] &#125;</span><br><span class="line">f3触发</span><br><span class="line">&#123; <span class="attr">click</span>: [ [<span class="built_in">Function</span>: f1], [<span class="built_in">Function</span>: f2] ] &#125;</span><br></pre></td></tr></table></figure>

<h2 id="观察者模式与发布-订阅模式的区别是什么？"><a href="#观察者模式与发布-订阅模式的区别是什么？" class="headerlink" title="观察者模式与发布-订阅模式的区别是什么？"></a>观察者模式与发布-订阅模式的区别是什么？</h2><p><img src="/2020/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.png" alt="1"></p>
<p><img src="/2020/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.png" alt="2"></p>
<p><strong>发布者直接触及到订阅者</strong>的操作，叫观察者模式。</p>
<p><strong>发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式</strong>。</p>
<p>观察者模式，解决的其实是模块间的耦合问题，有它在，即便是两个分离的、毫不相关的模块，也可以实现数据通信。但观察者模式仅仅是减少了耦合，<strong>并没有完全地解决耦合问题</strong>——被观察者必须去维护一套观察者的集合，这些观察者必须实现统一的方法供被观察者调用，两者之间还是有着说不清、道不明的关系。</p>
<p>而发布-订阅模式，则是快刀斩乱麻了——发布者完全不用感知订阅者，不用关心它怎么实现回调方法，事件的注册和触发都发生在独立于双方的第三方平台（事件总线）上。发布-订阅模式下，实现了完全地解耦。</p>
<h1 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3.代理模式"></a>3.代理模式</h1><p>代理模式，式如其名——在某些情况下，出于种种考虑/限制，一个对象<strong>不能直接访问</strong>另一个对象，需要一个<strong>第三者</strong>（代理）牵线搭桥从而间接达到访问目的，这样的模式就是代理模式。</p>
<h3 id="1-ES6-proxy"><a href="#1-ES6-proxy" class="headerlink" title="1.ES6 proxy"></a>1.ES6 proxy</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'c'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'我是自定义的一个结果'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="number">4</span>) &#123;</span><br><span class="line">      target[key] = <span class="string">'我是自定义的一个结果'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.c) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(p.c) <span class="comment">// 我是自定义的一个结果</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">'李白'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 李白</span></span><br><span class="line">obj.age = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'李白'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// 李白</span></span><br><span class="line">p.age = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.age); <span class="comment">// 我是自定义的一个结果</span></span><br></pre></td></tr></table></figure>

<h3 id="2-事件代理，可能是代理模式最常见的一种应用方式"><a href="#2-事件代理，可能是代理模式最常见的一种应用方式" class="headerlink" title="2.事件代理，可能是代理模式最常见的一种应用方式"></a>2.事件代理，可能是代理模式最常见的一种应用方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件代理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接1号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接2号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接3号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接4号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接5号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>链接6号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-缓存代理"><a href="#3-缓存代理" class="headerlink" title="3.缓存代理"></a>3.缓存代理</h3><p>缓存代理比较好理解，它应用于一些计算量较大的场景里。在这种场景下，我们需要“用空间换时间”——当我们需要用到某个已经计算过的值的时候，不想再耗时进行二次计算，而是希望能从内存里去取出现成的计算结果。这种场景下，就需要一个代理来帮我们在进行计算的同时，进行计算结果的缓存了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addAll方法会对你传入的所有参数做求和操作</span></span><br><span class="line"><span class="keyword">const</span> addAll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进行了一次新计算'</span>)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> len = <span class="built_in">arguments</span>.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        result += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为求和方法创建代理</span></span><br><span class="line"><span class="keyword">const</span> proxyAddAll = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 求和结果的缓存池</span></span><br><span class="line">    <span class="keyword">const</span> resultCache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将入参转化为一个唯一的入参字符串</span></span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查本次入参是否有对应的计算结果</span></span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">in</span> resultCache) &#123;</span><br><span class="line">            <span class="comment">// 如果有，则返回缓存池里现成的结果</span></span><br><span class="line">            <span class="keyword">return</span> resultCache[args]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultCache[args] = addAll(...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>



<h1 id="4-迭代器模式"><a href="#4-迭代器模式" class="headerlink" title="4.迭代器模式"></a>4.迭代器模式</h1><blockquote>
<p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。 ——《设计模式：可复用面向对象软件的基础》</p>
</blockquote>
<p>实现迭代器函数(generator)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写一个迭代器生成函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">iteratorGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'1号选手'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'2号选手'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'3号选手'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = iteratorGenerator()</span><br><span class="line"></span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br></pre></td></tr></table></figure>

<p>原生实现：</p>
<p>关键点在于next()和return的对象，done用来控制遍历的结束。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratorGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">    len = list.length;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> done = i &gt;= len;</span><br><span class="line">      <span class="keyword">let</span> value = done ? <span class="literal">undefined</span> : list[i++];</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">list[<span class="built_in">Symbol</span>.iterator] = iteratorGenerator</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> list) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5.工厂模式"></a>5.工厂模式</h1><p>将创建对象的过程单独封装，这样的操作就是工厂模式。同时它的应用场景也非常容易识别：有构造函数的地方，我们就应该想到简单工厂；在写了大量构造函数、调用了大量的 new、自觉非常不爽的情况下，我们就应该思考是不是可以掏出工厂模式重构我们的代码了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将创建对象的过程封装起来</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  create(name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Product(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="keyword">new</span> Factory();</span><br><span class="line"><span class="keyword">let</span> p1 = factory.create(<span class="string">'p1'</span>),</span><br><span class="line">  	p2 = factory.create(<span class="string">'p2'</span>);</span><br><span class="line">p1.init();</span><br><span class="line">p2.init()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2020/03/02/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>纯函数：</p>
<blockquote>
<p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。</p>
</blockquote>
<a id="more"></a>

<h1 id="1-函数柯里化和偏函数"><a href="#1-函数柯里化和偏函数" class="headerlink" title="1.函数柯里化和偏函数"></a>1.函数柯里化和偏函数</h1><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>柯里化 (Currying) 的定义:</p>
<blockquote>
<p>In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.</p>
</blockquote>
<p>在数学和计算机科学中，柯里化是一种将使用<code>多个参数的一个函数转换成一系列使用一个参数的函数的技术</code>。</p>
<p>通俗的说法：</p>
<blockquote>
<p>用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数</p>
</blockquote>
<p>做一个闭包，返回一个函数，这个函数每次执行会改写闭包里面记录参数的数组。当这个函数判断参数个数够了，就去执行它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = fn.length;</span><br><span class="line">    args = args || [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _args = [...args].concat([...arguments]);</span><br><span class="line">        <span class="keyword">if</span> (_args.length &lt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> curry.call(<span class="keyword">this</span>, fn, _args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args);</span><br><span class="line">            <span class="comment">//之所以写成 this 是因为希望根据环境的不同而设置不同的 this 值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>) <span class="comment">// ["a", "b", "c"]</span></span><br><span class="line">fn(<span class="string">"a"</span>, <span class="string">"b"</span>)(<span class="string">"c"</span>) <span class="comment">// ["a", "b", "c"]</span></span><br><span class="line">fn(<span class="string">"a"</span>)(<span class="string">"b"</span>)(<span class="string">"c"</span>) <span class="comment">// ["a", "b", "c"]</span></span><br><span class="line">fn(<span class="string">"a"</span>)(<span class="string">"b"</span>, <span class="string">"c"</span>) <span class="comment">// ["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>

<p>ES6写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> curry = <span class="function">(<span class="params">fn, arr = []</span>) =&gt;</span> fn.length === arr.length ? fn(...arr) : <span class="function">(<span class="params">...args</span>) =&gt;</span> curry(fn, [...arr, ...args]);</span><br></pre></td></tr></table></figure>

<p>以上的更像是柯里化与偏函数的结合体</p>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>偏函数 (Partial application) 的定义:</p>
<blockquote>
<p>In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity.</p>
</blockquote>
<p>在计算机科学中，局部应用是指固定一个函数的一些参数，然后产生另一个更小元的函数。</p>
<p>什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。</p>
<h3 id="柯里化和偏函数的区别"><a href="#柯里化和偏函数的区别" class="headerlink" title="柯里化和偏函数的区别"></a>柯里化和偏函数的区别</h3><p>柯里化是将一个多参数函数转化成多个单参数函数，也就是将一个n元函数转换成n个一元函数</p>
<p>偏函数是将一个n元的函数转换成一个n-x元函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="keyword">var</span> _ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> position = <span class="number">0</span>, len = args.length;</span><br><span class="line">        <span class="keyword">var</span> _args = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            _args.push(args[i] === _ ? <span class="built_in">arguments</span>[position++] : args[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(position &lt; <span class="built_in">arguments</span>.length) _args.push(<span class="built_in">arguments</span>[position++]);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> subtract = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> b - a; &#125;;</span><br><span class="line">subFrom20 = partial(subtract, _, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subFrom20(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(subFrom20(<span class="number">4</span>));</span><br><span class="line"><span class="comment">//占位符功能</span></span><br></pre></td></tr></table></figure>



<h1 id="2-惰性函数"><a href="#2-惰性函数" class="headerlink" title="2.惰性函数"></a>2.惰性函数</h1><ul>
<li>惰性函数的实现原理就是重新定义函数。</li>
<li>惰性思想的精髓:能一次搞定的事，我绝不做第二次</li>
</ul>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我们现在需要写一个 foo 函数，这个函数返回首次调用时的 Date 对象，注意是首次。</p>
<h2 id="解决一：普通方法"><a href="#解决一：普通方法" class="headerlink" title="解决一：普通方法"></a>解决一：普通方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t) <span class="keyword">return</span> t;</span><br><span class="line">    t = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题有两个，一是污染了全局变量，二是每次调用 foo 的时候都需要进行一次判断。</p>
<h2 id="解决二：闭包"><a href="#解决二：闭包" class="headerlink" title="解决二：闭包"></a>解决二：闭包</h2><p>我们很容易想到用闭包避免污染全局变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t) <span class="keyword">return</span> t;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>然而还是没有解决调用时都必须进行一次判断的问题。</p>
<h2 id="解决三：函数对象"><a href="#解决三：函数对象" class="headerlink" title="解决三：函数对象"></a>解决三：函数对象</h2><p>函数也是一种对象，利用这个特性，我们也可以解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (foo.t) <span class="keyword">return</span> foo.t;</span><br><span class="line">    foo.t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> foo.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依旧没有解决调用时都必须进行一次判断的问题。</p>
<h2 id="解决四：惰性函数"><a href="#解决四：惰性函数" class="headerlink" title="解决四：惰性函数"></a>解决四：惰性函数</h2><p>不错，惰性函数就是解决每次都要进行判断的这个问题，解决原理很简单，重写函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> foo();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="更多应用"><a href="#更多应用" class="headerlink" title="更多应用"></a>更多应用</h2><p>DOM 事件添加中，为了兼容现代浏览器和 IE 浏览器，我们需要对浏览器环境进行一次判断：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span> (<span class="params">type, el, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        el.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</span><br><span class="line">        el.attachEvent(<span class="string">'on'</span> + type, fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题在于我们每当使用一次 addEvent 时都会进行一次判断。</p>
<p>利用惰性函数，我们可以这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span> (<span class="params">type, el, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, el, fn</span>) </span>&#123;</span><br><span class="line">            el.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, el, fn</span>) </span>&#123;</span><br><span class="line">            el.attachEvent(<span class="string">'on'</span> + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEvent(type, el, fn) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以使用闭包的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">type, el, fn</span>) </span>&#123;</span><br><span class="line">            el.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">type, el, fn</span>) </span>&#123;</span><br><span class="line">            el.attachEvent(<span class="string">'on'</span> + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>当我们每次都需要进行条件判断，其实只需要判断一次，接下来的使用方式都不会发生改变的时候，想想是否可以考虑使用惰性函数。</p>
<h1 id="3-函数组合"><a href="#3-函数组合" class="headerlink" title="3.函数组合"></a>3.函数组合</h1><h2 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h2><p>我们需要写一个函数，输入 ‘kevin’，返回 ‘HELLO, KEVIN’。</p>
<p>试想我们写个 compose 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">f,g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(g(x));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>greet 函数就可以被优化为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greet = compose(hello, toUpperCase);</span><br><span class="line">greet(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>利用 compose 将两个函数组合成一个函数，让代码从右向左运行，而不是由内而外运行，可读性大大提升。这便是函数组合。</p>
<h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>underscore 的 compose 函数的实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">let</span> start = args.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> i = start;</span><br><span class="line">        <span class="keyword">let</span> result = args[start].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">while</span> (i--) result = args[i].call(<span class="keyword">this</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ES6</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span>  </span><br><span class="line">  (arg) =&gt; fns.reduce( <span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(compose), arg)</span><br></pre></td></tr></table></figure>

<p>现在的 compose 函数已经可以支持多个函数了，然而有了这个又有什么用呢？</p>
<p>在此之前，我们先了解一个概念叫做 pointfree。</p>
<h2 id="pointfree"><a href="#pointfree" class="headerlink" title="pointfree"></a>pointfree</h2><p>pointfree 指的是函数无须提及将要操作的数据是什么样的。依然是以最初的需求为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：输入 'kevin'，返回 'HELLO, KEVIN'。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非 pointfree，因为提到了数据：name</span></span><br><span class="line"><span class="keyword">var</span> greet = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">'hello '</span> + name).toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pointfree</span></span><br><span class="line"><span class="comment">// 先定义基本运算，这些可以封装起来复用</span></span><br><span class="line"><span class="keyword">var</span> toUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x.toUpperCase(); &#125;;</span><br><span class="line"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="string">'HELLO, '</span> + x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> greet = compose(hello, toUpperCase);</span><br><span class="line">greet(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>我们再举个稍微复杂一点的例子，为了方便书写，我们需要借助在 curry 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：输入 'kevin daisy kelly'，返回 'K.D.K'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非 pointfree，因为提到了数据：name</span></span><br><span class="line"><span class="keyword">var</span> initials = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.split(<span class="string">' '</span>).map(compose(toUpperCase, head)).join(<span class="string">'. '</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pointfree</span></span><br><span class="line"><span class="comment">// 先定义基本运算</span></span><br><span class="line"><span class="keyword">var</span> split = curry(<span class="function"><span class="keyword">function</span>(<span class="params">separator, str</span>) </span>&#123; <span class="keyword">return</span> str.split(separator) &#125;)</span><br><span class="line"><span class="keyword">var</span> head = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123; <span class="keyword">return</span> str.slice(<span class="number">0</span>, <span class="number">1</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> toUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123; <span class="keyword">return</span> str.toUpperCase() &#125;</span><br><span class="line"><span class="keyword">var</span> join = curry(<span class="function"><span class="keyword">function</span>(<span class="params">separator, arr</span>) </span>&#123; <span class="keyword">return</span> arr.join(separator) &#125;)</span><br><span class="line"><span class="keyword">var</span> map = curry(<span class="function"><span class="keyword">function</span>(<span class="params">fn, arr</span>) </span>&#123; <span class="keyword">return</span> arr.map(fn) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initials = compose(join(<span class="string">'.'</span>), map(compose(toUpperCase, head)), split(<span class="string">' '</span>));</span><br><span class="line"></span><br><span class="line">initials(<span class="string">"kevin daisy kelly"</span>);</span><br></pre></td></tr></table></figure>

<p>从这个例子中我们可以看到，利用柯里化（curry）和函数组合 (compose) 非常有助于实现 pointfree。</p>
<p>利用 curry，我们能够做到让每个函数都先接收数据，然后操作数据，最后再把数据传递到下一个函数那里去。</p>
<blockquote>
<p>Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。即不使用所要处理的值，只合成运算过程。</p>
</blockquote>
<blockquote>
<p>pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用，更符合语义，更容易复用，测试也变得轻而易举。</p>
</blockquote>
<h1 id="4-函数记忆"><a href="#4-函数记忆" class="headerlink" title="4.函数记忆"></a>4.函数记忆</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>函数记忆是指将上次的计算结果缓存起来，当下次调用时，如果遇到相同的参数，就直接返回缓存中的数据。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>实现这样一个 memoize 函数很简单，原理上只用把参数和对应的结果数据存到一个对象中，调用时，判断参数对应的数据是否存在，存在就返回对应的结果数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一版 (来自《JavaScript权威指南》)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">arguments</span>.length + <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[key]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[key] = f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>我们以斐波那契数列为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">2</span>? n : fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">    fibonacci(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">// 453</span></span><br></pre></td></tr></table></figure>

<p>我们会发现最后的 count 数为 453，也就是说 fibonacci 函数被调用了 453 次！也许你会想，我只是循环到了 10，为什么就被调用了这么多次，所以我们来具体分析下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">当执行 fib(<span class="number">0</span>) 时，调用 <span class="number">1</span> 次</span><br><span class="line"></span><br><span class="line">当执行 fib(<span class="number">1</span>) 时，调用 <span class="number">1</span> 次</span><br><span class="line"></span><br><span class="line">当执行 fib(<span class="number">2</span>) 时，相当于 fib(<span class="number">1</span>) + fib(<span class="number">0</span>) 加上 fib(<span class="number">2</span>) 本身这一次，共 <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span> 次</span><br><span class="line"></span><br><span class="line">当执行 fib(<span class="number">3</span>) 时，相当于 fib(<span class="number">2</span>) + fib(<span class="number">1</span>) 加上 fib(<span class="number">3</span>) 本身这一次，共 <span class="number">3</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">5</span> 次</span><br><span class="line"></span><br><span class="line">当执行 fib(<span class="number">4</span>) 时，相当于 fib(<span class="number">3</span>) + fib(<span class="number">2</span>) 加上 fib(<span class="number">4</span>) 本身这一次，共 <span class="number">5</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">9</span> 次</span><br><span class="line"></span><br><span class="line">当执行 fib(<span class="number">5</span>) 时，相当于 fib(<span class="number">4</span>) + fib(<span class="number">3</span>) 加上 fib(<span class="number">5</span>) 本身这一次，共 <span class="number">9</span> + <span class="number">5</span> + <span class="number">1</span> = <span class="number">15</span> 次</span><br><span class="line"></span><br><span class="line">当执行 fib(<span class="number">6</span>) 时，相当于 fib(<span class="number">5</span>) + fib(<span class="number">4</span>) 加上 fib(<span class="number">6</span>) 本身这一次，共 <span class="number">15</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">25</span> 次</span><br><span class="line"></span><br><span class="line">当执行 fib(<span class="number">7</span>) 时，相当于 fib(<span class="number">6</span>) + fib(<span class="number">5</span>) 加上 fib(<span class="number">7</span>) 本身这一次，共 <span class="number">25</span> + <span class="number">15</span> + <span class="number">1</span> = <span class="number">41</span> 次</span><br><span class="line"></span><br><span class="line">当执行 fib(<span class="number">8</span>) 时，相当于 fib(<span class="number">7</span>) + fib(<span class="number">6</span>) 加上 fib(<span class="number">8</span>) 本身这一次，共 <span class="number">41</span> + <span class="number">25</span> + <span class="number">1</span> = <span class="number">67</span> 次</span><br><span class="line"></span><br><span class="line">当执行 fib(<span class="number">9</span>) 时，相当于 fib(<span class="number">8</span>) + fib(<span class="number">7</span>) 加上 fib(<span class="number">9</span>) 本身这一次，共 <span class="number">67</span> + <span class="number">41</span> + <span class="number">1</span> = <span class="number">109</span> 次</span><br><span class="line"></span><br><span class="line">当执行 fib(<span class="number">10</span>) 时，相当于 fib(<span class="number">9</span>) + fib(<span class="number">8</span>) 加上 fib(<span class="number">10</span>) 本身这一次，共 <span class="number">109</span> + <span class="number">67</span> + <span class="number">1</span> = <span class="number">177</span> 次</span><br></pre></td></tr></table></figure>

<p>所以执行的总次数为：177 + 109 + 67 + 41 + 25 + 15 + 9 + 5 + 3 + 1 + 1 = 453 次！</p>
<p>如果我们使用函数记忆呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">2</span> ? n : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fibonacci = memoize(fibonacci)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    fibonacci(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>我们会发现最后的总次数为 11 次，因为使用了函数记忆，调用次数从 453 次降低为了 12 次!</p>
]]></content>
  </entry>
  <entry>
    <title>TS实战</title>
    <url>/2020/03/01/TS%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><p>npx create-react-app react-project –template typescript –use-npm</p>
<a id="more"></a>









<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><h3 id="1-编写express代码遇到的问题"><a href="#1-编写express代码遇到的问题" class="headerlink" title="1.编写express代码遇到的问题"></a>1.编写express代码遇到的问题</h3><p><strong>Q1:express库的类型定义文件.d.ts文件类型描述不准确</strong></p>
<p>不能直接在express官方提供的.d.ts上修改，因为你下次再npm的时候，下载的还是官方提供的文件。</p>
<p>可以通过引入官方的相对应的描述文件，在其之上修正描述不准确的地方，如下所示：</p>
<!---more-->

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router, Request, Response &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> RequestWithBody <span class="keyword">extends</span> Request &#123;</span><br><span class="line">  body: &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = Router();</span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;form method="post" action="/getData"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="password" name="password"&gt;</span></span><br><span class="line"><span class="string">        &lt;button&gt;提交&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/form&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/getData'</span>, <span class="function">(<span class="params">req: RequestWithBody, res: Response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.body.password === <span class="string">'123'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> secret = <span class="string">'secretKey'</span>;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`http://www.dell-lee.com/typescript/demo.html?secret=<span class="subst">$&#123;secret&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> analyzer = DellAnalyzer.getInstance();</span><br><span class="line">    <span class="keyword">new</span> Crowller(url, analyzer);</span><br><span class="line">    res.send(<span class="string">'getData Success'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.send(<span class="string">`<span class="subst">$&#123;req.teacherName&#125;</span>password error`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>



<p>Q2:当我使用中间件的时候，对req、res进行修改之后，实际上类型并不能改变，即类型无法拓展。</p>
<p>可以自定义一个.d.ts文件，仿照官方的描述文件，把需要拓展的内容加上。这样通过类型融合的方式，可以对req、res的类型进行拓展。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> Express &#123;</span><br><span class="line">  <span class="keyword">interface</span> Request &#123;</span><br><span class="line">    myName: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> express, &#123; Request, Response, NextFunction &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(<span class="function">(<span class="params">req: Request, res: Response, next: NextFunction</span>) =&gt;</span> &#123;</span><br><span class="line">  req.myName = <span class="string">'zhou'</span>;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(router);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">7001</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is running'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="2-登陆功能实现"><a href="#2-登陆功能实现" class="headerlink" title="2.登陆功能实现"></a>2.登陆功能实现</h3><p>服务端持久存储，需要用到cookie-session</p>
<p>index.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span>;</span><br><span class="line"><span class="keyword">import</span> cookieSession <span class="keyword">from</span> <span class="string">'cookie-session'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(</span><br><span class="line">  cookieSession(&#123;</span><br><span class="line">    name: <span class="string">'session'</span>,</span><br><span class="line">    keys: [<span class="string">'teacher zhou'</span>],</span><br><span class="line">    maxAge: <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> <span class="comment">// 24 hours</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">app.use(router);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">7001</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is running'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router, Request, Response, NextFunction &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> Crowller <span class="keyword">from</span> <span class="string">'./utils/crowller'</span>;</span><br><span class="line"><span class="keyword">import</span> DellAnalyzer <span class="keyword">from</span> <span class="string">'./utils/analyzer'</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BodyRequest <span class="keyword">extends</span> Request &#123;</span><br><span class="line">  body: &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkLogin = <span class="function">(<span class="params">req: Request, res: Response, next: NextFunction</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isLogin = req.session ? req.session.login : <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.send(<span class="string">'请先登陆'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">//业务逻辑中间件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function">(<span class="params">req: BodyRequest, res: Response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isLogin = req.session ? req.session.login : <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">    res.send(<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;a href='/getData'&gt;爬取内容&lt;/a&gt;</span></span><br><span class="line"><span class="string">      &lt;a href='/showData'&gt;展示内容&lt;/a&gt;</span></span><br><span class="line"><span class="string">      &lt;a href='/logout'&gt;退出&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.send(<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;form method="post" action="/login"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="password" name="password"&gt;</span></span><br><span class="line"><span class="string">        &lt;button&gt;登陆&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/form&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/logout'</span>, <span class="function">(<span class="params">req: BodyRequest, res: Response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.session) &#123;</span><br><span class="line">    req.session.login = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  res.redirect(<span class="string">'/'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/login'</span>, <span class="function">(<span class="params">req: BodyRequest, res: Response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; password &#125; = req.body;</span><br><span class="line">  <span class="keyword">const</span> isLogin = req.session ? req.session.login : <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">    res.send(<span class="string">'已经登陆'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (password === <span class="string">'123'</span> &amp;&amp; req.session) &#123;</span><br><span class="line">      req.session.login = <span class="literal">true</span>; <span class="comment">//if语句进行类型保护</span></span><br><span class="line">      res.send(<span class="string">'登陆成功'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(<span class="string">'登陆失败'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/getData'</span>, checkLogin, <span class="function">(<span class="params">req: BodyRequest, res: Response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> secret = <span class="string">'secretKey'</span>;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">`http://www.dell-lee.com/typescript/demo.html?secret=<span class="subst">$&#123;secret&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">const</span> analyzer = DellAnalyzer.getInstance();</span><br><span class="line">  <span class="keyword">new</span> Crowller(url, analyzer);</span><br><span class="line">  res.send(<span class="string">'getData Success'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/showData'</span>, checkLogin, <span class="function">(<span class="params">req: BodyRequest, res: Response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = path.resolve(__dirname, <span class="string">'../data/course.json'</span>);</span><br><span class="line">    <span class="keyword">const</span> result = fs.readFileSync(position, <span class="string">'utf-8'</span>);</span><br><span class="line">    res.json(<span class="built_in">JSON</span>.parse(result));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    res.send(<span class="string">'尚未爬取到内容'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>



<h3 id="3-用装饰器优化express代码"><a href="#3-用装饰器优化express代码" class="headerlink" title="3.用装饰器优化express代码"></a>3.用装饰器优化express代码</h3>]]></content>
      <categories>
        <category>express</category>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>TS入门</title>
    <url>/2020/03/01/TS%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><strong>定义</strong></p>
<p>​    TypeScript is a <code>typed</code>(静态类型，不同于JS的动态类型) superset of JavaScript that <code>compiles to plain JavaScript</code>(TS不能直接运行，需要先编译成JS).Any browser. Any host. Any OS. Open source.</p>
<a id="more"></a>

<p><strong>好处</strong></p>
<ol>
<li>开发过程中就会发现错误，比如下面的代码JS中显示没问题，TS中就会提示你有潜在的问题，JS只有在编译之后才发现问题</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(data.x ** <span class="number">2</span> + data.y ** <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">demo(&#123;<span class="attr">x</span>:<span class="number">3</span>,<span class="attr">y</span>:<span class="string">'4'</span>&#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">data: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(data.x ** <span class="number">2</span> + data.y ** <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">demo(&#123;x:<span class="number">3</span>,y:<span class="string">'4'</span>&#125;);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>代码提示</li>
<li>可读性更好</li>
</ol>
<p><strong>开发环境</strong>：</p>
<p><code>ts-node</code>可以直接运行TS文件，ts-node xxx.ts，避免先tsc xxx.ts，再node xxx.js。</p>
<p><strong>静态类型深度理解</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count: <span class="built_in">number</span> = <span class="number">2020</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当count具备number的静态类型之后，count会具备number这个类型的所有属性与方法。</p>
</blockquote>
<h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1.基础语法"></a>1.基础语法</h2><h3 id="1-1基础类型与对象类型"><a href="#1-1基础类型与对象类型" class="headerlink" title="1.1基础类型与对象类型"></a>1.1基础类型与对象类型</h3><p><strong>基础类型</strong></p>
<blockquote>
<p>number、boolean、string、null、undefined、symbol、void</p>
</blockquote>
<p><strong>对象类型</strong></p>
<blockquote>
<p>对象类型{}、数组类型[]、类类型、函数类型</p>
</blockquote>
<h3 id="1-2类型注解和类型推断"><a href="#1-2类型注解和类型推断" class="headerlink" title="1.2类型注解和类型推断"></a>1.2类型注解和类型推断</h3><p>type annotation</p>
<blockquote>
<p>类型注解。我们来告诉TS变量什么类型</p>
</blockquote>
<p>type inference</p>
<blockquote>
<p>类型推断。TS会自动的去分析变量的类型，如果TS无法分析变量类型，我们就需要使用类型注解。</p>
</blockquote>
<p>对于<code>解构赋值</code>的类型注解</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">&#123; first, second &#125;: &#123; first: <span class="built_in">number</span>; second: <span class="built_in">number</span> &#125;</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> total = add(&#123; first: <span class="number">1</span>, second: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure>



<p>赋值和变量的定义在一行的话，类型推断可以有效果。否则的话，类型推断无法推断出来。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count;</span><br><span class="line">count = <span class="number">123</span>;</span><br><span class="line">-----------------</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun1 = (str: <span class="built_in">string</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(str, <span class="number">10</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//上面一种方式如果类型推断能推断出函数的返回值，那么number可以省略。</span></span><br><span class="line"><span class="comment">//但下面一种方式number省略的话，语法就不对了。</span></span><br><span class="line"><span class="keyword">const</span> fun2: <span class="function">(<span class="params">str: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(str, <span class="number">10</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1-3数组与元组"><a href="#1-3数组与元组" class="headerlink" title="1.3数组与元组"></a>1.3数组与元组</h3><p><strong>数组</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr: (<span class="built_in">number</span>|<span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> undefinedArr: <span class="literal">undefined</span>[] = [<span class="literal">undefined</span>];</span><br><span class="line"><span class="keyword">const</span> objectArr: &#123;name: <span class="built_in">string</span>&#125;[] = [&#123;name: <span class="string">'zj'</span>&#125;]</span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> User = &#123;name: <span class="built_in">string</span>,age: <span class="built_in">number</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1Arr: User[] = [&#123;name: <span class="string">'zj'</span>, age: <span class="number">1</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Teacher &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2Arr: Teacher[] = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'zj'</span>,</span><br><span class="line">        age: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> Teacher()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>



<p><strong>元组</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>]; <span class="comment">// Error</span></span><br><span class="line"><span class="comment">//csv execl导出的文件常用元组</span></span><br><span class="line"><span class="keyword">const</span> list: [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">string</span>][] = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="string">'b'</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="1-4接口"><a href="#1-4接口" class="headerlink" title="1.4接口"></a>1.4接口</h3><p><strong>接口定义属性、方法</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="comment">//readonly name: string; //只读</span></span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>; <span class="comment">//可选</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类型别名也能起到interface的效果，区别是类型别名后面可以是一个基础类型，比如</span></span><br><span class="line"><span class="comment">//type Person1 = string;</span></span><br><span class="line"><span class="keyword">type</span> Person1 = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getPersonName = <span class="function">(<span class="params">person: Person</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(person.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> setPersonName = <span class="function">(<span class="params">person: Person, name: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  person.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	name: <span class="string">'zj'</span>,</span><br><span class="line">    sex: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line">getPersonName(person);</span><br><span class="line"><span class="comment">//上面不会报错，即使你接口中没有声明sex，但是你声明必须有的name属性满足</span></span><br><span class="line">getPersonName(&#123;</span><br><span class="line">	name: <span class="string">'zj'</span>,</span><br><span class="line">    sex: <span class="string">'male'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//报错，直接以字面量的形式传递给一个变量的时候，会进行强校验，sex是未声明的</span></span><br></pre></td></tr></table></figure>



<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="comment">//readonly name: string; //只读</span></span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>; <span class="comment">//可选</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">//除了必传的name，可以有其他属性，只要属性名是string类型就ok～</span></span><br><span class="line">  say(): <span class="built_in">string</span>; <span class="comment">//函数，返回值类型string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>接口定义函数</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SayHi &#123;</span><br><span class="line">  (word: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> say: SayHi = <span class="function">(<span class="params">word: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> word;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>类实现接口</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  say(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> User <span class="keyword">implements</span> Person &#123;</span><br><span class="line">  name: <span class="string">'zj'</span>;</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口继承接口</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  teach(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-5类"><a href="#1-5类" class="headerlink" title="1.5类"></a>1.5类</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span> = <span class="string">'zhou'</span>;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  getTeacherName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'jun'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="comment">//重写父类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="keyword">this</span>.getTeacherName();</span><br><span class="line">    <span class="comment">//如果父类的方法被覆盖，但是还想调用父类的方法，可以用super。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">const</span> teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line"><span class="built_in">console</span>.log(teacher.getName());</span><br><span class="line"><span class="built_in">console</span>.log(teacher.getTeacherName());</span><br></pre></td></tr></table></figure>



<p><strong>修饰符</strong></p>
<ol>
<li><p>public</p>
<p> 允许在类的内外调用</p>
</li>
<li><p>private</p>
<p> 允许在类内调用</p>
</li>
<li><p>protected</p>
<p> 允许在类内及继承的子类调用</p>
</li>
<li><p>readonly</p>
</li>
</ol>
<p><strong>构造器</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统写法</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span> = <span class="string">'zhou'</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'jun'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment">//简化写法</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'jun'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure>



<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">'zhou'</span>); <span class="comment">//执行父类的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> teacher = <span class="keyword">new</span> Teacher(<span class="number">28</span>);</span><br></pre></td></tr></table></figure>



<p><strong>get和set</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> _name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name + <span class="string">' jun'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(name: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'zhou'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line">person.name = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure>



<p><strong>静态属性</strong></p>
<p>挂载在类的本身上，而不是类的实例上。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Grid &#123;</span><br><span class="line">    <span class="keyword">static</span> origin = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;;</span><br><span class="line">    calculateDistanceFromOrigin(point: &#123;x: <span class="built_in">number</span>; y: <span class="built_in">number</span>;&#125;) &#123;</span><br><span class="line">        <span class="keyword">let</span> xDist = (point.x - Grid.origin.x);</span><br><span class="line">        <span class="keyword">let</span> yDist = (point.y - Grid.origin.y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="keyword">this</span>.scale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> scale: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>);  <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>);  <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;x: <span class="number">10</span>, y: <span class="number">10</span>&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;x: <span class="number">10</span>, y: <span class="number">10</span>&#125;));</span><br></pre></td></tr></table></figure>



<p><strong>单例模式</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Single &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> instance: Single; <span class="comment">//why static? 此时并没有实例被创建，所以要直接挂载在类上</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> getInstance() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.instance) Single.instance = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="keyword">return</span> Single.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> demo1 = Single.getInstance();</span><br><span class="line"><span class="keyword">const</span> demo2 = Single.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(demo1 === demo2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<p><strong>抽象类</strong></p>
<p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含<code>abstract</code>关键字并且可以包含访问修饰符。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Geom &#123;</span><br><span class="line">  width: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">  getType() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Gemo'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> getArea(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Circle <span class="keyword">extends</span> Geom &#123;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-6联合类型和类型保护"><a href="#1-6联合类型和类型保护" class="headerlink" title="1.6联合类型和类型保护"></a>1.6联合类型和类型保护</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  fly: <span class="built_in">boolean</span>;</span><br><span class="line">  sing: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  fly: <span class="built_in">boolean</span>;</span><br><span class="line">  bark: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>类型断言的方式进行类型保护</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trainAnimal</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (animal.fly) &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> Bird).sing();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> Dog).bark();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>in 语法来做类型保护</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trainAnimal</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'sing'</span> <span class="keyword">in</span> animal) animal.sing();</span><br><span class="line">  <span class="keyword">else</span> animal.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>typeof语法来做类型保护</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first: <span class="built_in">string</span> | <span class="built_in">number</span>, second: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> first === <span class="string">'string'</span> || <span class="keyword">typeof</span> second === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用instanceof语法来做类型保护</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> NumberObj &#123;</span><br><span class="line">  count: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">first: object | NumberObj, second: object | NumberObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first <span class="keyword">instanceof</span> NumberObj &amp;&amp; second <span class="keyword">instanceof</span> NumberObj) &#123;</span><br><span class="line">    <span class="keyword">return</span> first.count + second.count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-7枚举类型"><a href="#1-7枚举类型" class="headerlink" title="1.7枚举类型"></a>1.7枚举类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Blue;</span><br><span class="line"><span class="built_in">console</span>.log(c);    <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(Color[<span class="number">0</span>]); <span class="comment">//输出Red</span></span><br></pre></td></tr></table></figure>



<h3 id="1-8泛型"><a href="#1-8泛型" class="headerlink" title="1.8泛型"></a>1.8泛型</h3><p><strong>generic</strong></p>
<p><strong>函数泛型</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">T</span>&gt;(<span class="params">first: T, second: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>&gt;(<span class="params">params: T[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherJoin</span>&lt;<span class="title">T</span>, <span class="title">P</span>&gt;(<span class="params">first: T, second: P</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">join&lt;<span class="built_in">string</span>&gt;(<span class="string">'1'</span>, <span class="string">'1'</span>);</span><br><span class="line">map&lt;<span class="built_in">string</span>&gt;([<span class="string">'123'</span>]);</span><br><span class="line">anotherJoin&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">'123'</span>);</span><br><span class="line">anotherJoin(<span class="string">'123'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//function join2&lt;string, number&gt;(first: string, second: number): string</span></span><br><span class="line"><span class="comment">//如果你没有显式的告诉T、P是啥类型的话，TS会根据你传的值进行类型推断</span></span><br></pre></td></tr></table></figure>

<p><strong>泛型类</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> DataManager&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> data: T[]</span>) &#123;&#125;</span><br><span class="line">  getItem(index: <span class="built_in">number</span>): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> DataManager&lt;<span class="built_in">string</span>&gt;([<span class="string">'1'</span>, <span class="string">'2'</span>]);</span><br><span class="line">data.getItem(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>泛型约束</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Item &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> DataManager&lt;T <span class="keyword">extends</span> Item&gt; &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> data: T[]</span>) &#123;&#125;</span><br><span class="line">  getItem(index: <span class="built_in">number</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[index].name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> DataManager([&#123; name: <span class="string">'zhou'</span> &#125;]);</span><br></pre></td></tr></table></figure>

<p><strong>keyof的使用</strong></p>
<p>类型可以是字符串</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type T = 'name'</span></span><br><span class="line"><span class="comment">// key: 'name'</span></span><br><span class="line"><span class="comment">// Person['name']</span></span><br><span class="line"><span class="comment">// type T = 'age'</span></span><br><span class="line"><span class="comment">// key: 'age'</span></span><br><span class="line"><span class="comment">// Person['age']</span></span><br><span class="line"><span class="comment">// type T = 'gender'</span></span><br><span class="line"><span class="comment">// key: 'gender'</span></span><br><span class="line"><span class="comment">// Person['gender']</span></span><br><span class="line"><span class="keyword">class</span> Teacher &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> info: Person</span>) &#123;&#125;</span><br><span class="line">  getInfo&lt;T <span class="keyword">extends</span> keyof Person&gt;(key: T): Person[T] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.info[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> teacher = <span class="keyword">new</span> Teacher(&#123;</span><br><span class="line">  name: <span class="string">'zhou'</span>,</span><br><span class="line">  age: <span class="number">1</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = teacher.getInfo(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure>





<h2 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2.模块化"></a>2.模块化</h2><h3 id="2-1命名空间namespace"><a href="#2-1命名空间namespace" class="headerlink" title="2.1命名空间namespace"></a>2.1命名空间namespace</h3><p>尽可能少的生成全局变量，把必须暴露出去的export出去，其他的通过namespace封装起来</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Home &#123;</span><br><span class="line">  <span class="keyword">class</span> Header &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      elem.innerText = <span class="string">'this is header'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> Content &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      elem.innerText = <span class="string">'this is content'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> Footer &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      elem.innerText = <span class="string">'this is footer'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Page &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">new</span> Header();</span><br><span class="line">      <span class="keyword">new</span> Content();</span><br><span class="line">      <span class="keyword">new</span> Footer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>模块拆分以及打包到一个文件</strong></p>
<p>components.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Components &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Header &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      elem.innerText = <span class="string">'this is header'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Content &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      elem.innerText = <span class="string">'this is content'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Footer &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      elem.innerText = <span class="string">'this is footer'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page.ts</p>
<p><code>///&lt;reference path=&quot;./components.ts&quot; /&gt;</code>Home命名空间依赖于Components命名空间</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt;reference path="./components.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Home &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Page &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">new</span> Components.Header();</span><br><span class="line">      <span class="keyword">new</span> Components.Content();</span><br><span class="line">      <span class="keyword">new</span> Components.Footer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过tsc命令并且修改tsconfig.json文件下的：</p>
<ul>
<li><p><code>&quot;rootDir&quot;: &quot;./src&quot;</code>：需要打包的目录</p>
</li>
<li><p><code>&quot;outFile&quot;: &quot;./dist/page.js&quot;</code>：打包到哪个文件</p>
</li>
<li><p>``”module”: “amd”`</p>
<blockquote>
<p>Only ‘AMD’ and ‘System’ can be used in conjunction with —<code>outFile</code>.</p>
</blockquote>
</li>
</ul>
<p>最终打包成一个js文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> Components;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Components</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Header = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">            elem.innerText = <span class="string">'this is header'</span>;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Header;</span><br><span class="line">    &#125;());</span><br><span class="line">    Components.Header = Header;</span><br><span class="line">    <span class="keyword">var</span> Content = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Content</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">            elem.innerText = <span class="string">'this is content'</span>;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Content;</span><br><span class="line">    &#125;());</span><br><span class="line">    Components.Content = Content;</span><br><span class="line">    <span class="keyword">var</span> Footer = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Footer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">            elem.innerText = <span class="string">'this is footer'</span>;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Footer;</span><br><span class="line">    &#125;());</span><br><span class="line">    Components.Footer = Footer;</span><br><span class="line">&#125;)(Components || (Components = &#123;&#125;));</span><br><span class="line"><span class="comment">///&lt;reference path="./components.ts" /&gt;</span></span><br><span class="line"><span class="keyword">var</span> Home;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Home</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Page = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Components.Header();</span><br><span class="line">            <span class="keyword">new</span> Components.Content();</span><br><span class="line">            <span class="keyword">new</span> Components.Footer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Page;</span><br><span class="line">    &#125;());</span><br><span class="line">    Home.Page = Page;</span><br><span class="line">&#125;)(Home || (Home = &#123;&#125;));</span><br></pre></td></tr></table></figure>



<p><strong>namespace也可以嵌套使用</strong></p>
<h3 id="2-2import"><a href="#2-2import" class="headerlink" title="2.2import"></a>2.2import</h3><p>components.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Header &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    elem.innerText = <span class="string">'this is header'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Content &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    elem.innerText = <span class="string">'this is content'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Footer &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    elem.innerText = <span class="string">'this is footer'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Header, Content, Footer &#125; <span class="keyword">from</span> <span class="string">'./components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Page &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> Header();</span><br><span class="line">    <span class="keyword">new</span> Content();</span><br><span class="line">    <span class="keyword">new</span> Footer();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.html</p>
<p>需要引入<code>require.js</code>，识别打包成的js文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/page.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">require</span>([<span class="string">'page'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">page</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> page.Page()</span></span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><code>npm install parcel@next</code></p>
<p>使用Parcel打包TS代码</p>
<h2 id="3-编写类型描述文件-d-ts"><a href="#3-编写类型描述文件-d-ts" class="headerlink" title="3.编写类型描述文件.d.ts"></a>3.编写类型描述文件.d.ts</h2><p>.d.ts是为了帮助TS文件更好的理解我们引入的JS文件</p>
<h3 id="3-1全局类型"><a href="#3-1全局类型" class="headerlink" title="3.1全局类型"></a>3.1全局类型</h3><p>page.ts文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'body'</span>).html(<span class="string">'&lt;div&gt;123&lt;/div&gt;'</span>);</span><br><span class="line">  <span class="keyword">new</span> $.fn.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>juery.d.ts文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义全局变量</span></span><br><span class="line"><span class="comment">// declare var $: (params: () =&gt; void) =&gt; void;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局函数</span></span><br><span class="line"><span class="keyword">interface</span> JqueryInstance &#123;</span><br><span class="line">  html: <span class="function">(<span class="params">html: <span class="built_in">string</span></span>) =&gt;</span> JqueryInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同一个函数名可以定义多个全局函数(函数重载)</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">readyFunc: () =&gt; <span class="built_in">void</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title">JqueryInstance</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何对对象进行类型定义，以及对类进行类型定义，以及命名空间的嵌套</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> $ &#123;</span><br><span class="line">  <span class="keyword">namespace</span> fn &#123;</span><br><span class="line">    <span class="keyword">class</span> init &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用interface的语法，实现函数重载</span></span><br><span class="line"><span class="comment">// interface JQuery &#123;</span></span><br><span class="line"><span class="comment">//   (readyFunc: () =&gt; void): void;</span></span><br><span class="line"><span class="comment">//   (selector: string): JqueryInstance;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// declare var $: JQuery;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-2模块化变量"><a href="#3-2模块化变量" class="headerlink" title="3.2模块化变量"></a>3.2模块化变量</h3><p><strong>ES6</strong></p>
<p>page.ts文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'body'</span>).html(<span class="string">'&lt;div&gt;123&lt;/div&gt;'</span>);</span><br><span class="line">  <span class="keyword">new</span> $.fn.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>juery.d.ts文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'jquery' &#123;</span><br><span class="line">  <span class="keyword">interface</span> JqueryInstance &#123;</span><br><span class="line">    html: <span class="function">(<span class="params">html: <span class="built_in">string</span></span>) =&gt;</span> JqueryInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//混合类型</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">readyFunc: () =&gt; <span class="built_in">void</span></span>): <span class="title">void</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title">JqueryInstance</span></span>;</span><br><span class="line">  <span class="keyword">namespace</span> $ &#123;</span><br><span class="line">    <span class="keyword">namespace</span> fn &#123;</span><br><span class="line">      <span class="keyword">class</span> init &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> = $;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-高级语法"><a href="#4-高级语法" class="headerlink" title="4.高级语法"></a>4.高级语法</h2><h3 id="4-1类的装饰器"><a href="#4-1类的装饰器" class="headerlink" title="4.1类的装饰器"></a>4.1类的装饰器</h3><ul>
<li>装饰器本身是一个函数</li>
<li>类装饰器接受的是构造函数</li>
<li>装饰器执行在类创建的时候</li>
</ul>
<p><strong>装饰器工厂</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDecorator</span>(<span class="params"></span>) </span>&#123; <span class="comment">//这是一个装饰器工厂</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">any</span></span>) </span>&#123; <span class="comment">//这是装饰器</span></span><br><span class="line">    <span class="keyword">constructor</span>.prototype.getName = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'zhou'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@testDecorator</span>()</span><br><span class="line"><span class="keyword">class</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">(test <span class="keyword">as</span> <span class="built_in">any</span>).getName();</span><br></pre></td></tr></table></figure>



<p><strong>组合装饰器</strong></p>
<p>当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p>
<ol>
<li>由上至下依次对装饰器表达式求值</li>
<li>求值的结果会被当作函数，由下至上依次调用</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDecorator1</span>(<span class="params">constructor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'decorator1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDecorator2</span>(<span class="params">constructor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'decorator2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@testDecorator1</span></span><br><span class="line"><span class="meta">@testDecorator2</span></span><br><span class="line"><span class="keyword">class</span> Test &#123;&#125;</span><br><span class="line"><span class="comment">//decorator2 </span></span><br><span class="line"><span class="comment">//decorator1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDecorator1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'decorator1 evaluated'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'decorator1 called'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDecorator2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'decorator2 evaluated'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'decorator2 called'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@testDecorator1</span>()</span><br><span class="line"><span class="meta">@testDecorator2</span>()</span><br><span class="line"><span class="keyword">class</span> Test &#123;&#125;</span><br><span class="line"><span class="comment">//decorator1 evaluated</span></span><br><span class="line"><span class="comment">//decorator2 evaluated</span></span><br><span class="line"><span class="comment">//decorator2 called</span></span><br><span class="line"><span class="comment">//decorator1 called</span></span><br></pre></td></tr></table></figure>





<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDecorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">new</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt; </span>&#123;&#125;&gt;(<span class="keyword">constructor</span>: T) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> <span class="keyword">constructor</span> &#123;</span><br><span class="line">      name = <span class="string">'jun'</span>;</span><br><span class="line">      getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = testDecorator()(</span><br><span class="line">  <span class="keyword">class</span> &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test(<span class="string">'zhou'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br></pre></td></tr></table></figure>



<h3 id="4-2方法装饰器"><a href="#4-2方法装饰器" class="headerlink" title="4.2方法装饰器"></a>4.2方法装饰器</h3><p>方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的<em>属性描述符</em></li>
</ol>
<p>类似于Object.defineProperties()</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNameDecorator</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(target);</span></span><br><span class="line">  <span class="comment">// descriptor.writable = false;</span></span><br><span class="line">  descriptor.value = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'decorator'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@getNameDecorator</span></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test(<span class="string">'zhou'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test.getName());</span><br></pre></td></tr></table></figure>



<h3 id="4-3访问器装饰器"><a href="#4-3访问器装饰器" class="headerlink" title="4.3访问器装饰器"></a>4.3访问器装饰器</h3><p><strong>不允许同时装饰一个成员的<code>get</code>和<code>set</code>访问器。取而代之的是，一个成员的所有装饰器必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个<em>属性描述符</em>时，它联合了<code>get</code>和<code>set</code>访问器，而不是分开声明的。</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visitDecorator</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// descriptor.writable = false;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">  <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@visitDecorator</span></span><br><span class="line">  <span class="keyword">set</span> name(name: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test(<span class="string">'zhou'</span>);</span><br><span class="line">test.name = <span class="string">'12312312'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.name);</span><br></pre></td></tr></table></figure>



<h3 id="4-4属性装饰器"><a href="#4-4属性装饰器" class="headerlink" title="4.4属性装饰器"></a>4.4属性装饰器</h3><p>属性装饰器改变属性descriptor</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visitDecorator</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> descriptor: PropertyDescriptor = &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">  <span class="meta">@visitDecorator</span></span><br><span class="line">  name = <span class="string">'zhou'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test.name = <span class="string">'jun'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.name);</span><br></pre></td></tr></table></figure>



<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visitDecorator</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  target[key] = <span class="string">'jun'</span>; <span class="comment">//修改的并不是实例上的name，而是原型上的name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//name放在实例上</span></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">  <span class="meta">@visitDecorator</span></span><br><span class="line">  name = <span class="string">'zhou'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="built_in">console</span>.log(test.name); <span class="comment">// zhou</span></span><br></pre></td></tr></table></figure>



<h3 id="4-5参数装饰器"><a href="#4-5参数装饰器" class="headerlink" title="4.5参数装饰器"></a>4.5参数装饰器</h3><p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>参数在函数参数列表中的索引。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paramDecorator</span>(<span class="params">target: <span class="built_in">any</span>, method: <span class="built_in">string</span>, paramIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target, method, paramIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//name放在实例上</span></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">  getInfo(<span class="meta">@paramDecorator</span> name: <span class="built_in">string</span>, age: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test.getInfo(<span class="string">'zhou'</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h3 id="4-6应用"><a href="#4-6应用" class="headerlink" title="4.6应用"></a>4.6应用</h3><p>通过装饰器将异常捕获的内容封装到了一个函数中，并能复用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfo: <span class="built_in">any</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catchError</span>(<span class="params">msg: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">  <span class="meta">@catchError</span>(<span class="string">'userInfo.name不存在'</span>)</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> userInfo.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@catchError</span>(<span class="string">'userInfo.age不存在'</span>)</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> userInfo.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test.getName();</span><br><span class="line">test.getAge();</span><br></pre></td></tr></table></figure>



<h3 id="4-7reflect-metadata"><a href="#4-7reflect-metadata" class="headerlink" title="4.7reflect-metadata"></a>4.7reflect-metadata</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'reflect-metadata'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'zhou'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在user下定义了一组元数据，key为'data' value为'test'</span></span><br><span class="line">Reflect.defineMetadata(<span class="string">'data'</span>, <span class="string">'test'</span>, user);</span><br><span class="line"><span class="comment">//获取元数据</span></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">'data'</span>, user));</span><br></pre></td></tr></table></figure>

<p>可以在<strong>类</strong>、<strong>类的属性</strong>以及<strong>类的方法</strong>上定义元数据</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reflect</span>.metadata(<span class="string">'data'</span>, <span class="string">'test'</span>)</span><br><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">  name = <span class="string">'zhou'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">'data'</span>, User));</span><br><span class="line">---------------------</span><br><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">'data'</span>, <span class="string">'test'</span>)</span><br><span class="line">  name = <span class="string">'zhou'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">'data'</span>, User.prototype, <span class="string">'name'</span>));</span><br></pre></td></tr></table></figure>



<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">'data'</span>, <span class="string">'test'</span>)</span><br><span class="line">  getName() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> User &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.hasOwnMetadata(<span class="string">'data'</span>, User.prototype, <span class="string">'getName'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.hasOwnMetadata(<span class="string">'data'</span>, Teacher.prototype, <span class="string">'getName'</span>));</span><br><span class="line"><span class="comment">//true false</span></span><br><span class="line"><span class="comment">//hasOwnMetadata判断是不是自己的元数据还是说继承来的</span></span><br></pre></td></tr></table></figure>

<p><strong>API</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// define metadata on an object or property</span></span><br><span class="line">Reflect.defineMetadata(metadataKey, metadataValue, target);</span><br><span class="line">Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// check for presence of a metadata key on the prototype chain of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = Reflect.hasMetadata(metadataKey, target);</span><br><span class="line"><span class="keyword">let</span> result = Reflect.hasMetadata(metadataKey, target, propertyKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// check for presence of an own metadata key of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = Reflect.hasOwnMetadata(metadataKey, target);</span><br><span class="line"><span class="keyword">let</span> result = Reflect.hasOwnMetadata(metadataKey, target, propertyKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get metadata value of a metadata key on the prototype chain of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = Reflect.getMetadata(metadataKey, target);</span><br><span class="line"><span class="keyword">let</span> result = Reflect.getMetadata(metadataKey, target, propertyKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get metadata value of an own metadata key of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = Reflect.getOwnMetadata(metadataKey, target);</span><br><span class="line"><span class="keyword">let</span> result = Reflect.getOwnMetadata(metadataKey, target, propertyKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get all metadata keys on the prototype chain of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = Reflect.getMetadataKeys(target);</span><br><span class="line"><span class="keyword">let</span> result = Reflect.getMetadataKeys(target, propertyKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get all own metadata keys of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = Reflect.getOwnMetadataKeys(target);</span><br><span class="line"><span class="keyword">let</span> result = Reflect.getOwnMetadataKeys(target, propertyKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete metadata from an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = Reflect.deleteMetadata(metadataKey, target);</span><br><span class="line"><span class="keyword">let</span> result = Reflect.deleteMetadata(metadataKey, target, propertyKey);</span><br><span class="line"><span class="comment">// apply metadata via a decorator to a constructor</span></span><br><span class="line"><span class="meta">@Reflect</span>.metadata(metadataKey, metadataValue)</span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">  <span class="comment">// apply metadata via a decorator to a method (property)</span></span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(metadataKey, metadataValue)</span><br><span class="line">  method() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-8装饰器的执行顺序"><a href="#4-8装饰器的执行顺序" class="headerlink" title="4.8装饰器的执行顺序"></a>4.8装饰器的执行顺序</h3><ul>
<li>当多个装饰器应用在一个声明上时会进行如下步骤的操作：</li>
</ul>
<ol>
<li>由上至下依次对装饰器表达式求值;</li>
<li>求值的结果会被当作函数，由下至上依次调用.</li>
</ol>
<ul>
<li>不同装饰器的执行顺序：属性装饰器 &gt; 方法装饰器 &gt; 参数装饰器 &gt; 类装饰器</li>
</ul>
<p><strong>自封装的元数据装饰器</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'reflect-metadata'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showData</span>(<span class="params">target: <span class="keyword">typeof</span> User</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target.prototype) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = Reflect.getMetadata(<span class="string">'data'</span>, target.prototype, key);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setData</span>(<span class="params">dataKey: <span class="built_in">string</span>, msg: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: User, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    Reflect.defineMetadata(dataKey, msg, target, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@showData</span></span><br><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">'data'</span>, <span class="string">'name'</span>)</span><br><span class="line">  getName() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@setData</span>(<span class="string">'data'</span>, <span class="string">'age'</span>)</span><br><span class="line">  getAge() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Edition Distance</title>
    <url>/2020/02/26/Edition-Distance/</url>
    <content><![CDATA[<p>​    缘起：前段时间，看dom diff算法那块的时候，看到了列表对比那块用到了edit distance算法，例如<code>p, ul, div</code> 的顺序换成了 <code>div, p, ul</code>。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 <code>p</code> 和<code>div</code>的<code>tagName</code>不同，<code>p</code>会被<code>div</code>所替代。最终，三个节点都会被替换，这样<code>DOM</code>开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。</p>
<p>​    将这个问题抽象出来其实就是字符串的最小编辑距离问题（<code>Edition Distance</code>），最常见的解决方法是 <code>Levenshtein Distance</code> , <code>Levenshtein Distance</code> 是一个度量两个字符序列之间差异的字符串度量标准，两个单词之间的 <code>Levenshtein Distance</code> 是将一个单词转换为另一个单词所需的单字符编辑（插入、删除或替换）的最小数量。<code>Levenshtein Distance</code> 是1965年由苏联数学家 Vladimir Levenshtein 发明的。<code>Levenshtein Distance</code> 也被称为编辑距离（<code>Edit Distance</code>），通过<strong>动态规划</strong>求解，时间复杂度为 <code>O(M*N)</code>。</p>
<a id="more"></a>

<h2 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h2><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p>
<p>You have the following 3 operations permitted on a word:</p>
<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (remove &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (remove &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (insert &#39;u&#39;)</span><br></pre></td></tr></table></figure>





<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">	啥都别做（skip）</span><br><span class="line">    编辑距离</span><br><span class="line">    i, j 同时向前移动</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	三选⼀：</span><br><span class="line">    	插⼊（insert）</span><br><span class="line">        删除（<span class="keyword">delete</span>）</span><br><span class="line">        替换（replace）</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDistance = <span class="function"><span class="keyword">function</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m=word1.length,</span><br><span class="line">        n=word2.length;</span><br><span class="line">    <span class="keyword">const</span> dp=<span class="built_in">Array</span>(m+<span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;m+<span class="number">1</span>;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            <span class="comment">//本来就相等，不需要任何操作</span></span><br><span class="line">            <span class="comment">//s1[0..i] 和 s2[0..j] 的最⼩编辑距离等于</span></span><br><span class="line">            <span class="comment">//s1[0..i-1] 和 s2[0..j-1] 的最⼩编辑距离</span></span><br><span class="line">            <span class="comment">//也就是说 dp(i, j) 等于 dp(i-1, j-1)</span></span><br><span class="line">            <span class="keyword">if</span>(word1[i<span class="number">-1</span>]===word2[j<span class="number">-1</span>]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">Math</span>.min(</span><br><span class="line">                    <span class="comment">//我直接把 s[i] 这个字符删掉</span></span><br><span class="line">                    <span class="comment">//前移 i，继续跟 j 对⽐</span></span><br><span class="line">                    dp[i<span class="number">-1</span>][j]+<span class="number">1</span>, <span class="comment">//删除</span></span><br><span class="line">                    <span class="comment">//我直接在 s1[i] 插⼊⼀个和 s2[j] ⼀样的字符</span></span><br><span class="line">                    <span class="comment">//那么 s2[j] 就被匹配了，前移 j，继续跟 i 对⽐</span></span><br><span class="line">                    dp[i][j<span class="number">-1</span>]+<span class="number">1</span>, <span class="comment">//插入</span></span><br><span class="line">                    <span class="comment">//我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了</span></span><br><span class="line">                    <span class="comment">//同时前移 i，j 继续对⽐</span></span><br><span class="line">                    dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span> <span class="comment">//替换</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>数据结构总结</p>
<a id="more"></a>

<h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1.链表"></a>1.链表</h2><h3 id="226-Reverse-Linked-List"><a href="#226-Reverse-Linked-List" class="headerlink" title="226. Reverse Linked List"></a>226. Reverse Linked List</h3><p>Reverse a singly linked list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<p><strong>iteratively</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">let</span> prev=<span class="literal">null</span>,</span><br><span class="line">        cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        <span class="keyword">let</span> next=cur.next;</span><br><span class="line">        cur.next=prev;</span><br><span class="line">        prev=cur;</span><br><span class="line">        cur=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>recursively</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(!head||!head.next) <span class="keyword">return</span> head; <span class="comment">//如果是空节点或者是最后一个节点 就返回自身 不需要翻转</span></span><br><span class="line">    <span class="keyword">let</span> last=reverseList(head.next); <span class="comment">//返回的是翻转后链表的头节点</span></span><br><span class="line">    head.next.next=head; <span class="comment">//将当前节点和翻转后的链表作拼接</span></span><br><span class="line">    head.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last; <span class="comment">//返回翻转后的头节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h2><h3 id="2-1-遍历"><a href="#2-1-遍历" class="headerlink" title="2.1 遍历"></a>2.1 遍历</h3><p><strong>递归</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 前序遍历</span></span><br><span class="line">	traverse(root.left)</span><br><span class="line">	<span class="comment">// 中序遍历</span></span><br><span class="line">	traverse(root.right)</span><br><span class="line">	<span class="comment">// 后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非递归</strong></p>
<p>前序遍历：</p>
<p>用栈来模拟递归</p>
<h4 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h4><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res=[],</span><br><span class="line">          stack=[root];</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.right) stack.push(node.right);</span><br><span class="line">        <span class="keyword">if</span>(node.left) stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>中序遍历：</p>
<h4 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h4><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res=[],</span><br><span class="line">          stack=[];</span><br><span class="line">    <span class="keyword">let</span> cur=root; <span class="comment">//用于查找左节点</span></span><br><span class="line">    <span class="keyword">while</span>(cur || stack.length) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        cur=node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>后序遍历：</p>
<h4 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h4><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure>

<p>解法一：</p>
<p>后序是<code>左-右-根</code>，那么反转过来是<code>根-右-左</code>，那么可以用类似于前序遍历的方法，唯一区别是左右节点的放入时机。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res=[],</span><br><span class="line">          stack=[root];</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left) stack.push(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right) stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解法二：</p>
<p><code>左-右-根</code>，也就是说一个节点的输出主要取决于：</p>
<ul>
<li>无左右子节点</li>
<li>有左右子节点，但是都输出过了</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res=[],</span><br><span class="line">          stack=[root];</span><br><span class="line">    <span class="keyword">let</span> cur; <span class="comment">//输出的时候用此标记，这样父亲节点可以通过它判断输出与否</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=stack[stack.length<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>((!node.left&amp;&amp;!node.right)||node.left===cur||node.right===cur) &#123;</span><br><span class="line">            cur=stack.pop();</span><br><span class="line">            res.push(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.right) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-建树"><a href="#2-2-建树" class="headerlink" title="2.2 建树"></a>2.2 建树</h3><p>前序+中序</p>
<h4 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h4><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>Return the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pLeft=<span class="number">0</span>,</span><br><span class="line">        pRight=preorder.length<span class="number">-1</span>,</span><br><span class="line">        iLeft=<span class="number">0</span>,</span><br><span class="line">        iRight=inorder.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> build(pLeft,pRight,iLeft,iRight);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">pLeft,pRight,iLeft,iRight</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pLeft&gt;pRight||iLeft&gt;iRight) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=iLeft;i&lt;=iRight;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]===preorder[pLeft]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node=<span class="keyword">new</span> TreeNode(preorder[pLeft]);</span><br><span class="line">        node.left=build(pLeft+<span class="number">1</span>,pLeft+i-iLeft,iLeft,i<span class="number">-1</span>);</span><br><span class="line">        node.right=build(pLeft+<span class="number">1</span>+i-iLeft,pRight,i+<span class="number">1</span>,iRight);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后序+中序</p>
<h4 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h4><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<p>Return the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">postorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">inorder, postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pLeft=<span class="number">0</span>,</span><br><span class="line">        pRight=postorder.length<span class="number">-1</span>,</span><br><span class="line">        iLeft=<span class="number">0</span>,</span><br><span class="line">        iRight=inorder.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> build(pLeft,pRight,iLeft,iRight);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">pLeft,pRight,iLeft,iRight</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pLeft&gt;pRight||iLeft&gt;iRight) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> i=iLeft;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=iRight;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]===postorder[pRight]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node=<span class="keyword">new</span> TreeNode(postorder[pRight]);</span><br><span class="line">        node.left=build(pLeft,pLeft+i-iLeft<span class="number">-1</span>,iLeft,i<span class="number">-1</span>);</span><br><span class="line">        node.right=build(pLeft+i-iLeft,pRight<span class="number">-1</span>,i+<span class="number">1</span>,iRight);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Backtracking算法</title>
    <url>/2020/02/24/Backtracking%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>解决⼀个回溯问题，实际上就是⼀个决策树的遍历过程。你只需要思考3个问题：</p>
<ol>
<li><p>路径：也就是已经做出的选择。</p>
</li>
<li><p>选择列表：也就是你当前可以做的选择。</p>
</li>
<li><p>结束条件：也就是到达决策树底层，⽆法再做选择的条件。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def backtrack(...):</span><br><span class="line">	边界判断</span><br><span class="line">	for 选择 in 选择列表:</span><br><span class="line">		做选择</span><br><span class="line">		backtrack(...)</span><br><span class="line">		撤销选择</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h2><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[]</span><br><span class="line">    backtrack(res,[],nums)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,temp,nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp.length===nums.length) <span class="keyword">return</span> res.push([...temp]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.includes(nums[i])) <span class="keyword">continue</span>; <span class="comment">//排除不符合的</span></span><br><span class="line">        temp.push(nums[i]); <span class="comment">//做选择</span></span><br><span class="line">        backtrack(res,temp,nums);</span><br><span class="line">        temp.pop();<span class="comment">//撤销选择</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h2><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permuteUnique = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[]</span><br><span class="line">    backtrack(res,[],nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b),[])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,temp,nums,visited</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp.length===nums.length) <span class="keyword">return</span> res.push([...temp]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="comment">//这个位置的数字访问过了，不能像上一题用includes，因为有重复的元素</span></span><br><span class="line">        <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果相邻的元素相同，并且前一个没被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]===nums[i<span class="number">-1</span>]&amp;&amp;!visited[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        temp.push(nums[i]);</span><br><span class="line">        visited[i]=<span class="literal">true</span>;</span><br><span class="line">        backtrack(res,temp,nums,visited);</span><br><span class="line">        visited[i]=<span class="literal">false</span>;</span><br><span class="line">        temp.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Union Find算法</title>
    <url>/2020/02/21/Union-Find%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Union-Find算法也就是常说的并查集算法，主要用来解决图论中<code>动态连通性</code>问题。</p>
<a id="more"></a>

<p>连通具有以下几个性质：</p>
<ol>
<li>⾃反性：节点 p 和 p 是连通的。</li>
<li>对称性：如果节点 p 和 q 连通，那么 q 和 p 也连通。</li>
<li>传递性：如果节点 p 和 q 连通， q 和 r 连通，那么 p 和 r 也连通。</li>
</ol>
<p><img src="/2020/02/21/Union-Find%E7%AE%97%E6%B3%95/2.png" alt></p>
<p>如上图所示，如果要将p、q连通，则可以把p的根结点连到q的根结点上，但是也会出现一个<code>问题</code>：如果每次都是随意的将一个节点的根结点连到另一个节点的根结点上，那么在查找节点的时候会导致O(n)的时间复杂度，而不是O(logn)。</p>
<p>对于⼀般的树可能出现极端不平衡的情况，使得树⼏乎退化成链表，树的⾼度最坏情况下可能变成N。为了解决此问题，我们其实是希望，⼩⼀些的树接到⼤⼀些的树下⾯，这样就能避免头重脚轻，更平衡⼀些。可以引用变量来计算每次需要合并的俩个子树的节点数，这样每次个数小的合并到个数大的根结点上，最终可以让整个数达到平衡树，时间复杂度可以降到O(logn)。</p>
<p><code>路径压缩</code>可以进一步的压缩树的高度，使数高保持为常数，如下图所示：</p>
<p><img src="/2020/02/21/Union-Find%E7%AE%97%E6%B3%95/3.jpg" alt></p>
<h3 id="990-Satisfiability-of-Equality-Equations"><a href="#990-Satisfiability-of-Equality-Equations" class="headerlink" title="990. Satisfiability of Equality Equations"></a><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">990. Satisfiability of Equality Equations</a></h3><p>​    Given an array equations of strings that represent relationships between variables, each string <code>equations[i]</code> has length <code>4</code> and takes one of two different forms: <code>&quot;a==b&quot;</code> or <code>&quot;a!=b&quot;</code>.  Here, <code>a</code> and <code>b</code> are lowercase letters (not necessarily different) that represent one-letter variable names.</p>
<p>Return <code>true</code> if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: If we assign say, a &#x3D; 1 and b &#x3D; 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We could assign a &#x3D; 1 and b &#x3D; 1 to satisfy both equations.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= equations.length &lt;= 500</code></li>
<li><code>equations[i].length == 4</code></li>
<li><code>equations[i][0]</code> and <code>equations[i][3]</code> are lowercase letters</li>
<li><code>equations[i][1]</code> is either <code>&#39;=&#39;</code> or <code>&#39;!&#39;</code></li>
<li><code>equations[i][2]</code> is <code>&#39;=&#39;</code></li>
</ol>
<p><strong>思路</strong>：</p>
<p>Union-Find</p>
<p><strong>code</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">equations</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> equationsPossible = <span class="function"><span class="keyword">function</span>(<span class="params">equations</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> string=<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>,</span><br><span class="line">          parent=<span class="built_in">Array</span>(<span class="number">26</span>),<span class="comment">//父节点</span></span><br><span class="line">          size=<span class="built_in">Array</span>(<span class="number">26</span>), <span class="comment">//各个树的"重量"</span></span><br><span class="line">          count=<span class="number">26</span>; <span class="comment">//连通分量个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;parent.length;i++) parent[i]=i;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">p,q</span>)</span>&#123; <span class="comment">//合并</span></span><br><span class="line">        <span class="keyword">let</span> rootP=find(p),</span><br><span class="line">            rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP===rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(size[rootP]&lt;size[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            size[rootQ]+=size[rootP];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            size[rootP]+=size[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// count--;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">connected</span>(<span class="params">p,q</span>)</span>&#123; <span class="comment">//是否属于一个连通分量</span></span><br><span class="line">        <span class="keyword">let</span> rootP=find(p),</span><br><span class="line">            rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP===rootQ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">x</span>)</span>&#123; <span class="comment">//路径压缩</span></span><br><span class="line">        <span class="keyword">while</span>(x!==parent[x])&#123;</span><br><span class="line">            parent[x]=parent[parent[x]];</span><br><span class="line">            x=parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    equations.forEach(<span class="function"><span class="params">str</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> c1=str.charAt(<span class="number">0</span>),</span><br><span class="line">            c2=str.charAt(<span class="number">3</span>),</span><br><span class="line">            isEqual=str.charAt(<span class="number">1</span>)===<span class="string">'='</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> c1Index=string.indexOf(c1),</span><br><span class="line">            c2Index=string.indexOf(c2);</span><br><span class="line">        <span class="keyword">if</span>(isEqual)&#123;</span><br><span class="line">            union(c1Index,c2Index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;equations.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> str=equations[i];</span><br><span class="line">        <span class="keyword">let</span> c1=str.charAt(<span class="number">0</span>),</span><br><span class="line">            c2=str.charAt(<span class="number">3</span>),</span><br><span class="line">            isEqual=str.charAt(<span class="number">1</span>)===<span class="string">'='</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> c1Index=string.indexOf(c1),</span><br><span class="line">            c2Index=string.indexOf(c2);</span><br><span class="line">        <span class="keyword">if</span>(!isEqual&amp;&amp;connected(c1Index,c2Index))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<p>使⽤ Union-Find 算法，主要是如何把原问题转化成图的动态连通性问题。对于算式合法性问题，可以直接利⽤等价关系，对于棋盘包围问题，则是利⽤⼀个虚拟节点，营造出动态连通特性。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>vue框架使用与原理</title>
    <url>/2020/02/20/vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><p><strong>v-html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将整个标签内容替换成rawHtml中的内容，如果标签内还有子元素，会被覆盖。</p>
<p><code>防止XSS攻击</code></p>
<p><strong>computed和watch</strong></p>
<a id="more"></a>

<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><h3 id="2-1-MVVM"><a href="#2-1-MVVM" class="headerlink" title="2.1.MVVM"></a>2.1.MVVM</h3><p><strong>MVC</strong></p>
<p>传统的MVC模式就是modul,view,controller三层，但是当初的网页比较简单，前端所需要的数据，一般都能通过后端处理好再发给前端。但是H5的出现让网页开始向app靠拢，为了实现H5的移动端和原生app一样，逐渐的发展为MVVM模式。<br><strong>MVC的缺点</strong> ：</p>
<ol>
<li>开发者在代码中大量调用相同的DOM API，处理繁琐，操作冗余，使得代码难以维护。</li>
<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>
<li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li>
</ol>
<p><strong>MVVM</strong>简介：<br>MVVM 极大地提高了前端开发效率。MVVM的核心是ViewModel 层，它就像是一个中转站（value converter），负责转换Model中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与Model层通过接口请求进行数据交互，起呈上启下作用。</p>
<p><img src="/2020/02/20/vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/2.png" alt></p>
<p><img src="/2020/02/20/vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/3.png" alt></p>
<p>其实可以看出对于前端，只是在view和viewModule层进行编写代码。</p>
<ul>
<li><p>view层</p>
<p>  View 是视图层，也就是用户界面。前端的html和css构建，与viewModel实现数据绑定</p>
</li>
<li><p>Model层</p>
<p>  Model是指数据模型，也就是后端的数据操控，一般前端利用ajax操作进行在viewModule层对其进行数据请求</p>
</li>
<li><p>viewModel层</p>
<p>  在该层所封装的数据类型包括视图的状态（数据）和一些行为，而 Model 层的数据模型是只包含状态的。<br>  由于实现了双向绑定，ViewModel的内容会实时展现在View层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵DOM去更新视图，MVVM框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现数据驱动开发。<br>  <strong>视图状态</strong>：这一块展示什么（数据）<br>  <strong>视图行为</strong>：用户发生了什么行为（触发了什么事件），要作什么，执行什么函数</p>
</li>
</ul>
<p><strong>例子</strong></p>
<p>vue的模板就是view层</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;showMessage()&quot;&gt;Click me&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>Vue的ViewModel层</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data: &#123;     &#x2F;&#x2F; 用于描述视图状态（有基于 Model 层数据定义的，也有纯前端定义）</span><br><span class="line">        message: &#39;Hello Vue!&#39;,  &#x2F;&#x2F; 纯前端定义</span><br><span class="line">        server: &#123;&#125;, &#x2F;&#x2F; 存放基于 Model 层数据的二次封装数据</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;  &#x2F;&#x2F; 用于描述视图行为（完全前端定义）</span><br><span class="line">        showMessage()&#123;</span><br><span class="line">            let vm &#x3D; this;</span><br><span class="line">            alert(vm.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        let vm &#x3D; this;</span><br><span class="line">        &#x2F;&#x2F; Ajax 获取 Model 层的数据</span><br><span class="line">        ajax(&#123;</span><br><span class="line">            url: &#39;&#x2F;your&#x2F;server&#x2F;data&#x2F;api&#39;,</span><br><span class="line">            success(res)&#123;</span><br><span class="line">                &#x2F;&#x2F; TODO 对获取到的 Model 数据进行转换处理，做二次封装</span><br><span class="line">                vm.server &#x3D; res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>服务器的model层</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;url&quot;: &quot;&#x2F;your&#x2F;server&#x2F;data&#x2F;api&quot;,</span><br><span class="line">    &quot;res&quot;: &#123;</span><br><span class="line">        &quot;success&quot;: true,</span><br><span class="line">        &quot;name&quot;: &quot;zhou&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/20/vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/1.png" alt></p>
<h3 id="2-2-实现双向数据绑定"><a href="#2-2-实现双向数据绑定" class="headerlink" title="2.2.实现双向数据绑定"></a>2.2.实现双向数据绑定</h3><p>Object.defineProperty()</p>
<p>缺点：</p>
<ul>
<li>深度监听，需要递归到底，一次性计算量大</li>
<li>无法监听新增属性/删除属性(Vue.set、Vue.delete)</li>
</ul>
<p>Vue3.0启用proxy()，但是兼容性不好，无法用polyfill</p>
<p>vue的<code>数据双向绑定</code>是通过数据劫持发布者-订阅者模式来实现的，通过<code>Object.defineProperty()</code>来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>实现mvvm主要包含俩个方面，数据变化驱动视图，视图变化驱动数据。</p>
<p>关键点在于data如何更新view，因为view更新data其实可以通过事件监听即可，比如input标签监听 ‘input’ 事件就可以实现了。所以我们着重来分析下，当数据改变，如何更新视图的。</p>
<p>数据更新视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的事都好处理。如何知道数据变了，其实上文我们已经给出答案了，就是通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了。</p>
<ol>
<li>需要一个监听器Observer，用来监听所有属性，如果属性发生改变，那么就通知订阅者</li>
<li>实现一个订阅者Watcher，用来收到属性变化时候需要通知执行的函数，从而更新视图</li>
<li>实现一个解析器Compile，可以扫描和解析每个节点，并初始化模板数据以及初始化相应的订阅者</li>
</ol>
<p>最后再来理一遍，<code>observe</code>递归遍历整个<code>data</code>，给每个属性创建一个订阅中心，而且重写他们的<code>getter/setter</code>方法：在特殊情况（<code>Dep.target</code>存在）下<code>get</code>会添加订阅者到订阅中心，在<code>set</code>时会通知订阅中心，继而通知每位订阅者；订阅者会特殊情况（<code>Dep.target</code>存在）下，执行<code>render</code>函数（目标在数据的初始化的时候将数据放入dep订阅器中），<code>get</code>每一个涉及到的数据。这样，以后只要有数据发生变动，就会触发该订阅者的更新函数，就会引起<code>dom</code>的变化！</p>
<p><img src="/2020/02/20/vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/4.png" alt></p>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>要实现Observer就需要使用Object.defineProperty()，对所有属性进行getter和setter的监听，当每次进行setter时触发特定的update函数。这时候需要创建一个订阅器Dep，该订阅器用于订阅者，当属性变化的时候执行对应订阅者的更新函数。</p>
<p>但是我们需要找到一个地方，用于将订阅者收集起来，这里我在getter实现订阅者的加入，但是需要判断是否有订阅者。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123; <span class="comment">//定义响应式</span></span><br><span class="line">    observer(val); <span class="comment">//需要对嵌套的对象添加响应式，所以要递归实现</span></span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(); </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123; <span class="comment">//当对data操作时，都会去走get、set方法</span></span><br><span class="line">        enumerable: <span class="literal">true</span>, <span class="comment">//可枚举</span></span><br><span class="line">        configurable: <span class="literal">true</span>,<span class="comment">//可添加删除</span></span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                dep.addSub(Dep.target); <span class="comment">//添加订阅者</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'属性'</span> + key + <span class="string">'已经被监听了，现在值为：“'</span> + newVal.toString() + <span class="string">'”'</span>);</span><br><span class="line">            dep.notify(); <span class="comment">// 如果数据变化，通知所有订阅者</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data != <span class="string">'object'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    addSub: <span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;,</span><br><span class="line">    notify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>观察者的目的是给需要变化的那个元素添加一个观察者，当数据变化后执行相应的方法。订阅者Watcher在初始化的时候需要将自己添加进订阅器Dep中，所以在一开始初始化时，需要强制执行一次监听器Observer的get执行了添加订阅者Wather的操作，这就响应了Observer为什么要在getter中加入，因为只有getter才不会影响原本的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watcher</span>(<span class="params">vm, exp, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">this</span>.exp = exp;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get();  <span class="comment">// 将自己添加到订阅器的操作</span></span><br><span class="line">&#125;</span><br><span class="line">watcher.prototype = &#123;</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.run();</span><br><span class="line">    &#125;,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//新值老值做比对，如果发生变化，调用更新方法</span></span><br><span class="line">        <span class="keyword">let</span> val = <span class="keyword">this</span>.vm.data[<span class="keyword">this</span>.exp];</span><br><span class="line">        <span class="keyword">let</span> oldVal = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">if</span> (val != oldVal) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = val;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, val, oldVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>:function () &#123;</span><br><span class="line">        Dep.target = <span class="keyword">this</span>;  <span class="comment">// 缓存自己</span></span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">this</span>.vm.data[<span class="keyword">this</span>.exp]  <span class="comment">// 强制执行监听器里的get函数</span></span><br><span class="line">        Dep.target = <span class="literal">null</span>;  <span class="comment">// 消去缓存</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，简单版的Watcher设计完毕，这时候我们只要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了。因为这里没有还没有设计解析器Compile，所以对于模板数据我们都进行写死处理，假设模板上又一个节点，且id号为’name’，并且双向绑定的绑定的变量也为’name’，且是通过两个大双括号包起来（这里只是为了掩饰，暂时没什么用处）.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vueSelf</span>(<span class="params">data, el, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    observer(data);</span><br><span class="line">    el.innerHTML = <span class="keyword">this</span>.data[exp];</span><br><span class="line">    <span class="keyword">new</span> watcher(<span class="keyword">this</span>, exp, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        el.innerHTML = value;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span>name<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./observer.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./watcher.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vueSelf.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">'#name'</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> vueSelf = <span class="keyword">new</span> vueSelf(&#123;</span></span><br><span class="line"><span class="actionscript">                    name: <span class="string">'hello world'</span></span></span><br><span class="line"><span class="actionscript">                &#125;, ele, <span class="string">'name'</span>);</span></span><br><span class="line">             </span><br><span class="line"><span class="javascript">                <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'name值改变了'</span>);</span></span><br><span class="line"><span class="actionscript">                    vueSelf.data.name = <span class="string">'canfoo'</span>;</span></span><br><span class="line">                &#125;, 2000);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们想通过vueSelf.name = ‘canfoo’这种进行赋值，这时候也需要object.defineProperty()进行调整，可以写成一个proxy函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vueSelf.prototype.proxyKeys = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body... </span></span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function proxyGetter() &#123;</span><br><span class="line">            <span class="keyword">return</span> self.data[key];</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function proxySetter(newVal) &#123;</span><br><span class="line">            self.data[key] = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>while(firstChild = el.firstChild)</strong><br>这个语句进行了2个操作：</p>
<ol>
<li>执行赋值操作<code>firstChild = el.firstChild</code></li>
<li>执行<code>while(firstChild)</code>，<code>while</code>是条件为真的情况下才执行，也就是必须<code>el.firstChild</code>有值的情况下才执行</li>
</ol>
<p>当判定<code>while(firstChild)</code>为真的情况执行<code>fragment.appendChild(firstChild);</code><br>把<code>el.firstChild</code>即<code>el.children[0]</code>抽出插入到<code>fragment</code>。注意这个操作是<code>move dom</code>， <code>el.children[0]</code>被抽出，在下次<code>while</code>循环执行<code>firstChild = el.firstChild</code>时读取的是相对本次循环的<code>el.children[1]</code> 以此达到循环转移<code>dom</code>的目的</p>
<h4 id="编译模版compile"><a href="#编译模版compile" class="headerlink" title="编译模版compile"></a>编译模版compile</h4><p>要实现个解析器Compile来做解析和绑定工作，需要考虑两个步骤：</p>
<ol>
<li>解析模板，并替换模板中的特定的数据，对视图进行初始化</li>
<li>将模板对应的节点绑定对应的更新函数，初始化相应的订阅器</li>
</ol>
<p>为了解析模板，需要获取dom元素，然后对含有dom元素上含有指令的节点进行处理，因此这个环节需要对dom操作比较频繁，所有可以先建一个fragment片段，将需要解析的dom节点存入fragment片段里再进行处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nodeToFragment</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">var</span> child = el.firstChild;</span><br><span class="line">    <span class="keyword">while</span> (child) &#123;</span><br><span class="line">        <span class="comment">// 将Dom元素移入fragment中</span></span><br><span class="line">        fragment.appendChild(child);</span><br><span class="line">        child = el.firstChild</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要遍历各个节点，对含有相关指定的节点进行特殊处理，这里咱们先处理最简单的情况，只对带有 这种形式的指令进行处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileElement</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> childNodes = el.childNodes;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    [].slice.call(childNodes).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line">        <span class="keyword">var</span> text = node.textContent;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123;  <span class="comment">// 判断是否是符合这种形式&#123;&#123;&#125;&#125;的指令</span></span><br><span class="line">            self.compileText(node, reg.exec(text)[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">            self.compileElement(node);  <span class="comment">// 继续递归遍历子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileText</span> (<span class="params">node, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> initText = <span class="keyword">this</span>.vm[exp];</span><br><span class="line">    <span class="keyword">this</span>.updateText(node, initText);  <span class="comment">// 将初始化的数据初始化到视图中</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm, exp, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;  <span class="comment">// 生成订阅器并绑定更新函数</span></span><br><span class="line">        self.updateText(node, value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">    node.textContent = <span class="keyword">typeof</span> value == <span class="string">'undefined'</span> ? <span class="string">''</span> : value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SelfVue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.vm = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.data = options;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        self.proxyKeys(key);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    observe(<span class="keyword">this</span>.data);</span><br><span class="line">    <span class="keyword">new</span> Compile(options, <span class="keyword">this</span>.vm);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改后，我们就不要像之前通过传入固定的元素值进行双向绑定了，可以随便命名各种变量进行双向绑定了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/</span>h1&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;script src=<span class="string">"js/observer.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="js/</span>watcher.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>js/compile.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>js/index.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    var selfVue = new SelfVue(&#123;</span></span><br><span class="line"><span class="string">        el: '#app',</span></span><br><span class="line"><span class="string">        data: &#123;</span></span><br><span class="line"><span class="string">            title: 'hello world',</span></span><br><span class="line"><span class="string">            name: ''</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    window.setTimeout(function () &#123;</span></span><br><span class="line"><span class="string">        selfVue.title = '你好';</span></span><br><span class="line"><span class="string">    &#125;, 2000);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    window.setTimeout(function () &#123;</span></span><br><span class="line"><span class="string">        selfVue.name = 'canfoo';</span></span><br><span class="line"><span class="string">    &#125;, 2500);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里，一个数据双向绑定功能已经基本完成了，接下去就是需要完善更多指令的解析编译。</p>
<h3 id="2-3-vdom和diff"><a href="#2-3-vdom和diff" class="headerlink" title="2.3.vdom和diff"></a>2.3.vdom和diff</h3><h4 id="2-3-1-vdom"><a href="#2-3-1-vdom" class="headerlink" title="2.3.1 vdom"></a>2.3.1 vdom</h4><ul>
<li><p>用JS模拟DOM结构(vnode)</p>
</li>
<li><p>新旧vnode对比，得出最小更新范围，最后更新DOM</p>
</li>
<li><p>数据驱动视图模式下，有效控制DOM操作</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>vdom<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">"font-size: 20px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面是用js模拟的DOM结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">'div'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        className: <span class="string">'container'</span>,</span><br><span class="line">        id: <span class="string">'div1'</span></span><br><span class="line">    &#125;</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            tag: <span class="string">'p'</span>,</span><br><span class="line">            children: <span class="string">'vdom'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            tag <span class="string">'ul'</span>,</span><br><span class="line">            props: &#123;<span class="attr">style</span>: <span class="string">'font-size: 20px'</span>&#125;</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    tag: <span class="string">'li'</span></span><br><span class="line">                    children: <span class="string">'a'</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>vnode =&gt; patch第一次 到空的dom元素 首次渲染 =&gt; newVnode =&gt; patch第二次 新旧对比</p>
<p>由于虚拟dom有那么多的好处而且现代前端框架中react和vue均不同程度的使用了虚拟dom的技术，因此通过一个简单的 库赖学习虚拟dom技术就十分必要了，至于为什么会选择snabbdom.js这个库呢？原因主要有两个：</p>
<ol>
<li>源码简短，总体代码行数不超过500行。</li>
<li>著名的vue的虚拟dom实现也是参考了snabbdom.js的实现。</li>
</ol>
<p><strong>用snabbdom来体验一下</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> snabbdom = <span class="built_in">window</span>.snabbdom</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 patch</span></span><br><span class="line"><span class="keyword">const</span> patch = snabbdom.init([</span><br><span class="line">    snabbdom_class,</span><br><span class="line">    snabbdom_props,</span><br><span class="line">    snabbdom_style,</span><br><span class="line">    snabbdom_eventlisteners</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 h</span></span><br><span class="line"><span class="keyword">const</span> h = snabbdom.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 vnode</span></span><br><span class="line"><span class="keyword">const</span> vnode = h(<span class="string">'ul#list'</span>, &#123;&#125;, [</span><br><span class="line">    h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'Item 1'</span>),</span><br><span class="line">    h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'Item 2'</span>)</span><br><span class="line">])</span><br><span class="line">patch(container, vnode)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn-change'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 生成 newVnode</span></span><br><span class="line">    <span class="keyword">const</span> newVnode = h(<span class="string">'ul#list'</span>, &#123;&#125;, [</span><br><span class="line">        h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'Item 1'</span>),</span><br><span class="line">        h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'Item B'</span>),</span><br><span class="line">        h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'Item 3'</span>)</span><br><span class="line">    ])</span><br><span class="line">    patch(vnode, newVnode)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/20/vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/5.png" alt></p>
<p><img src="/2020/02/20/vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/6.png" alt></p>
<p>在页面刷新的时候，发现<code>item1</code>并没有更新。那么是怎么做到的呢？</p>
<h4 id="2-3-2-diff算法"><a href="#2-3-2-diff算法" class="headerlink" title="2.3.2 diff算法"></a>2.3.2 diff算法</h4><ul>
<li>diff即对比，是一个广泛的概念，如Linux diff命令、git diff命令</li>
<li>俩个js对象也可以diff，如<a href="https://github.com/cujojs/jiff" target="_blank" rel="noopener">https://github.com/cujojs/jiff</a></li>
<li>俩个树做diff，如这里的vdom diff</li>
</ul>
<p><img src="/2020/02/20/vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/7.png" alt></p>
<p>正常来说俩个树做diff比较的时间复杂度为O(n^3)，如何优化到O(n)？</p>
<ul>
<li>只比较同一层级，不跨级比较</li>
<li>tag不相同，则直接删掉重建，不再深度比较</li>
<li>tag和key俩者都相同，则认为是相同节点，不再深度比较</li>
</ul>
<p><img src="/2020/02/20/vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/8.png" alt></p>
<p><img src="/2020/02/20/vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/9.png" alt></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>LRU算法</title>
    <url>/2020/02/20/LRU%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>最近最少使用算法（LRU）是大部分操作系统为最大化页面命中率而广泛采用的一种页面置换算法。该算法的思路是，发生缺页中断时，选择未使用时间最长的页面置换出去。从程序运行的原理来看，最近最少使用算法是比较接近理想的一种页面置换算法，这种算法既充分利用了内存中页面调用的历史信息，又正确反映了程序的局部问题。下面将采用双向链表+哈希表实现。</p>
<a id="more"></a>

<h3 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache</a></h3><p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</p>
<p><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a <strong>positive</strong> capacity.</p>
<p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* capacity *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; evicts key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; evicts key 1</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; returns 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; returns 4</span><br></pre></td></tr></table></figure>



<p><strong>思路</strong>：</p>
<ul>
<li>哈希表</li>
<li>双向链表</li>
</ul>
<p>哈希表和双向链表结合可以使得存取的时间复杂度都为O(1)</p>
<p>哈希表查找快，但是数据⽆固定顺序；链表有顺序之分，插⼊删除快，但是查找慢。</p>
<p><strong>code</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">capacity</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> LRUCache = <span class="function"><span class="keyword">function</span>(<span class="params">capacity</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">    <span class="keyword">this</span>.count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.head=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.tail=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.hashtable=&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.hashtable[key])&#123;</span><br><span class="line">        <span class="keyword">let</span> node=<span class="keyword">this</span>.hashtable[key];</span><br><span class="line">        <span class="keyword">if</span>(node===<span class="keyword">this</span>.head) <span class="keyword">return</span> <span class="keyword">this</span>.head.value;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node===<span class="keyword">this</span>.tail)&#123;</span><br><span class="line">            <span class="keyword">this</span>.tail=<span class="keyword">this</span>.tail.prev;</span><br><span class="line">            <span class="keyword">this</span>.head.prev=node;</span><br><span class="line">            node.next=<span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head=node;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.head.value;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.prev.next=node.next;</span><br><span class="line">            node.next.prev=node.prev;</span><br><span class="line">            <span class="keyword">this</span>.head.prev=node;</span><br><span class="line">            node.next=<span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head=node;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.head.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype.put = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.hashtable[key])&#123;</span><br><span class="line">        <span class="keyword">this</span>.hashtable[key].value=value;</span><br><span class="line">        <span class="keyword">this</span>.get(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//哈希表指向双向链表中的节点</span></span><br><span class="line">        <span class="keyword">this</span>.hashtable[key]=&#123;key,value,<span class="attr">pre</span>:<span class="literal">null</span>,<span class="attr">next</span>:<span class="literal">null</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head)&#123;</span><br><span class="line">            <span class="keyword">this</span>.head.prev=<span class="keyword">this</span>.hashtable[key];</span><br><span class="line">            <span class="keyword">this</span>.hashtable[key].next=<span class="keyword">this</span>.head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head=<span class="keyword">this</span>.hashtable[key];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.tail) <span class="keyword">this</span>.tail=<span class="keyword">this</span>.hashtable[key];</span><br><span class="line">        <span class="keyword">if</span>(++<span class="keyword">this</span>.count&gt;<span class="keyword">this</span>.capacity)&#123;</span><br><span class="line">            <span class="keyword">let</span> key=<span class="keyword">this</span>.tail.key;</span><br><span class="line">            <span class="keyword">this</span>.tail=<span class="keyword">this</span>.tail.prev;</span><br><span class="line">            <span class="keyword">this</span>.hashtable[key]=<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new LRUCache(capacity)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"> * obj.put(key,value)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>双向链表</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐小程序项目总结</title>
    <url>/2020/02/16/%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>ES6总结</title>
    <url>/2020/01/30/ES6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><p>为了加强对变量生命周期的控制，ES6引入了<code>块级作用域</code>。</p>
<a id="more"></a>

<p>块级作用域存在于：</p>
<ul>
<li>函数内部</li>
<li>块中(字符{和}之间的区域)</li>
</ul>
<p>特点：</p>
<ol>
<li>不会被提升</li>
<li>重复声明报错</li>
<li>不绑定全局作用域</li>
</ol>
<p><code>let</code>和<code>const</code>的区别：<code>const</code>用于声明常量，其值一旦被设定不能再被修改，否则会报错。const不允许修改绑定，但是允许修改值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有问题</span></span><br><span class="line">data.value = <span class="number">2</span>;</span><br><span class="line">data.num = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">data = &#123;&#125;; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>即常量data储存的是一个地址，这个地址指向一个对象。不可变的是这个地址，但对象是可变的，所以依然可以为其添加新属性。</p>
<p>如果真的想让对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<p>为了保持兼容性，var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、 const命令、class 命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在Node的REPL环境，可以写成global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><code>临时死区</code>(TDZ)：</p>
<p>JS引擎在扫描代码发现变量声明时，要么将它们提升到作用域顶部(遇到var声明)，要么将声明放在TDZ中(遇到let和const声明)。访问TDZ中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移出，然后方可访问。</p>
<p>循环中的块级作用域：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>立即调用函数表达式(IIFE)也能传入参数。因为函数内定义的任何函数可以访问外部函数的传入参数和变量（闭包），所以立即调用的函数表达式(IIFE)可以用于“锁定”值并有效地保存状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    funcs[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i))</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>ES6</p>
<p>块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = ...;</span><br><span class="line">    ...</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = ...;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>那么当使用let的时候底层到底是怎么做的呢？</p>
<p>简单的来说，就是在 <code>for (let i = 0; i &lt; 3; i++)</code> 中，即圆括号之内建立一个隐藏的作用域，这就可以解释为什么:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure>

<p>然后<strong>每次迭代循环时都创建一个新变量，并以之前迭代中同名变量的值将其初始化</strong>。这样对于下面这样一段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>就相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">0</span>) &#123;</span><br><span class="line">    funcs[<span class="number">0</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">1</span>) &#123;</span><br><span class="line">    funcs[<span class="number">1</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">2</span>) &#123;</span><br><span class="line">    funcs[<span class="number">2</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当执行函数的时候，根据词法作用域就可以找到正确的值，其实你也可以理解为let声明模仿了闭包的做法来简化循环过程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>尝试对const声明的i修改，所以会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [], object = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs[<span class="number">0</span>]()</span><br></pre></td></tr></table></figure>

<p>‘c’</p>
<p>改成let或const -&gt; ‘a’ 每次迭代不会修改已有的绑定，而是会创建一个新的绑定。</p>
<p>babel编译：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> _value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _loop = <span class="function"><span class="keyword">function</span> <span class="title">_loop</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    _loop(i);</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined，<code>默认值</code>是不会生效的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>如果默认值是一个表达式，那么这个表达式是<code>惰性求值</code>的，即只有在用到的时候，才会求值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的解构赋值，由于对象没有顺序，所以变量必须与属性同名才能取到值。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br></pre></td></tr></table></figure>

<p>变量声明与赋值是一体的，上面这种写法，其实只声明赋值了<code>baz</code>，所以调用foo的话，会报错foo is not defined</p>
</blockquote>
<p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure>

<p>上面代码的写法会报错，因为JavaScript引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>解构赋值允许，等号左边的模式之中，不放置任何变量名。</p>
<h2 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h2><ol>
<li>变量声明语句中，不能带有圆括号。</li>
<li>函数参数中，模式不能带有圆括号。</li>
<li>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</li>
</ol>
<p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>



<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>和普通函数区别：</p>
<ol>
<li><p><strong>没有this</strong></p>
<blockquote>
<p><strong>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。</strong></p>
<p>这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。</p>
</blockquote>
</li>
<li><p><strong>没有arguments</strong></p>
<blockquote>
<p>如果想要得到箭头函数的参数可以通过以下的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>不能通过 new 关键字调用</strong></p>
</li>
<li><p><strong>没有 new.target</strong></p>
<blockquote>
<p><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p>
</blockquote>
</li>
<li><p><strong>没有原型</strong></p>
</li>
<li><p><strong>没有 super</strong></p>
</li>
</ol>
<p>最后，关于箭头函数，引用 MDN 的介绍就是：</p>
<blockquote>
<p>An arrow function expression has a shorter syntax than a function expression and does not have its own <code>this</code>, <code>arguments</code>, <code>super</code>, or <code>new.target</code>. These function expressions are best suited for <code>non-method functions</code>, and they cannot be used as <code>constructors</code>.</p>
</blockquote>
<p>method的定义：</p>
<blockquote>
<p>A method is a function which is a property of an object.</p>
</blockquote>
<p>对象属性中的函数就被称之为 method，那么 non-method 就是指不被用作对象属性中的函数了，可是为什么说箭头函数更适合 non-method 呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  i: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.i, <span class="keyword">this</span>),</span><br><span class="line">  c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.i, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();</span><br><span class="line"><span class="comment">// undefined Window</span></span><br><span class="line">obj.c();</span><br><span class="line"><span class="comment">// 10, Object &#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为它内部this的指向原因，当使用obj.b()的时候，很明显我们希望b方法里面的this指向obj，但是它却指向了obj所在上下文中的this（即window），违背了我们的意愿，所以箭头函数不适合作为对象的方法。这也是为什么vue组件里面方法不允许使用箭头函数的原因。</p>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><ol>
<li><p>Symbol 值通过 Symbol 函数生成，使用 typeof，结果为 “symbol”</p>
</li>
<li><p>Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。</p>
</li>
<li><p>instanceof 的结果为 false</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
</li>
<li><p>如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line"><span class="built_in">console</span>.log(sym); <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol 函数的参数只是表示对当前 Symbol 值的描述，相同参数的 Symbol 函数的返回值是不相等的。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
</li>
<li><p>Symbol 值可以显式转为字符串。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(sym)); <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.toString()); <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。</p>
</li>
<li><p>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols);</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们希望使用同一个 Symbol 值，可以使用 Symbol.for。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.keyFor 方法返回一个<code>已登记</code>的 Symbol 类型值的 key。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1)); <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2) ); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Symbol-for与Symbol"><a href="#Symbol-for与Symbol" class="headerlink" title="Symbol.for与Symbol"></a>Symbol.for与Symbol</h2><p>Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被<code>登记</code>在<code>全局环境</code>中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用 Symbol.for(“cat”)30次，每次都会返回同一个Symbol值，但是调用 Symbol(“cat”) 30次，会返回30个不同的Symbol值。</p>
<h2 id="内置Symbol值"><a href="#内置Symbol值" class="headerlink" title="内置Symbol值"></a>内置Symbol值</h2><ol>
<li><p>Symbol.hasInstance</p>
<p> 当调用<code>instanceof</code>这个方法时，实际调用对象的Symbol.hasInstance属性，这个属性指向一个内部方法。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.hasInstance](foo) &#123;</span><br><span class="line">        <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> MyClass()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.isConcatSpreadable</p>
<p> 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat() 时，是否可以展开。</p>
<p> Symbol.isConcatSpreadable属性等于<code>true</code>或<code>undefined</code>时，表示可以展开。</p>
<p> 类数组对象也可以展开，但它的Symbol.isConcatSpreadable属性默认为false，必须手动打开。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    length: <span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">'d'</span></span><br><span class="line">&#125;;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', obj, 'e']</span></span><br><span class="line">obj[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.iterator</p>
<p> 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p> 对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> myIterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.toPrimitive</p>
<p> 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p> Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>
<ul>
<li><p>Number：该场合需要转成数值</p>
</li>
<li><p>String：该场合需要转成字符串</p>
</li>
<li><p>Default：该场合可以转成数值，也可以转成字符串</p>
<p>一般情况下，+连接运算符传入的参数是<code>default</code>，而对于乘法等算数运算符传入的是<code>number</code>。对于String(str),${str}等情况，传入的参数是<code>string</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'str'</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'default'</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">2</span> * obj <span class="comment">// 246</span></span><br><span class="line"><span class="number">3</span> + obj <span class="comment">// '3default'</span></span><br><span class="line">obj == <span class="string">'default'</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>(obj) <span class="comment">// 'str'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> <strong>Symbol.toPrimitive在类型转换方面，优先级是最高的。</strong></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123;</span><br><span class="line">    valueOf() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>+ab); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>+ab); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="defineProperty-与-proxy"><a href="#defineProperty-与-proxy" class="headerlink" title="defineProperty 与 proxy"></a>defineProperty 与 proxy</h1><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><blockquote>
<p>Object.defineProperty(obj, prop, descriptor)</p>
</blockquote>
<p>descriptor：</p>
<ol>
<li>数据描述符：<strong>configurable</strong>、<strong>enumerable</strong>、<strong>value</strong>、<strong>writable</strong></li>
<li>存取描述符：<strong>configurable</strong>、<strong>enumerable</strong>、<strong>get</strong>、<strong>set</strong></li>
</ol>
<p>configurable：</p>
<blockquote>
<p>当且仅当该属性的configurable为true时，该属性描述符才能够被改变，也能够被删除。默认为false。</p>
</blockquote>
<p>enumerable：</p>
<blockquote>
<p>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</p>
</blockquote>
<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><p>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>

<p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  (v, property) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`监听到属性<span class="subst">$&#123;property&#125;</span>改变为<span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  (target, property) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`'<span class="subst">$&#123;property&#125;</span>' = <span class="subst">$&#123;target[property]&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// 控制台输出：监听到属性a改变</span></span><br><span class="line">p.a <span class="comment">// 'a' = 2</span></span><br></pre></td></tr></table></figure>

<p>自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p>
<p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-get"><a href="#1-get" class="headerlink" title="1.get()"></a>1.get()</h3><blockquote>
<p>get方法用于拦截某个属性的读取操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"zj"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, property) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">return</span>  target[property];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">ReferenceError</span>(<span class="string">"Property \""</span> + property + <span class="string">"\" does not exist."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">//"张三"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(proxy.age) //抛出一个错误</span></span><br><span class="line"><span class="comment">//如果没有这个拦截函数，访问不存在的属性，只会返回undefined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>get方法可以继承</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, propertyKey, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'GET'</span> + propertyKey);</span><br><span class="line">        <span class="keyword">return</span> target[propertyKey];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line"><span class="built_in">console</span>.log(obj.xxx);</span><br></pre></td></tr></table></figure>



<h3 id="2-set"><a href="#2-set" class="headerlink" title="2.set()"></a>2.set()</h3><blockquote>
<p>set方法用来拦截某个属性的赋值操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> validator = &#123;</span><br><span class="line">    <span class="keyword">set</span>: function(obj, prop, value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prop === <span class="string">'age'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The age is not an integer'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The age seems invalid'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于age以外的属性，直接保存</span></span><br><span class="line">        obj[prop] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person.age = 'young'; //报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person.age = 300; //报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用set方法还是可以数据绑定，即每当对象发生变化时，会自动更新DOM</span></span><br></pre></td></tr></table></figure>



<h3 id="3-apply"><a href="#3-apply" class="headerlink" title="3.apply()"></a>3.apply()</h3><blockquote>
<p>apply方法可以拦截函数的调用、call和apply的操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'I am the target'</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    apply: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'I am the proxy'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p()); <span class="comment">//I am the proxy</span></span><br><span class="line"><span class="comment">//上述代码p是Proxy的实例，当它作为函数调用时p()，就会被apply方法拦截，返回一个字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> twice = &#123;</span><br><span class="line">    apply (target, ctx, args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, twice);</span><br><span class="line">proxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br><span class="line">proxy.call(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span></span><br><span class="line">proxy.apply(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面代码中，每当执行proxy函数，就会被apply方法拦截</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外 直接调用Reflect.apply方法，也会被拦截</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>]) <span class="comment">// 38</span></span><br></pre></td></tr></table></figure>

<h3 id="4-has"><a href="#4-has" class="headerlink" title="4.has()"></a>4.has()</h3><blockquote>
<p>用来拦截HasProperty操作，即判断对象是否有某个属性时，这个方法会生效。</p>
</blockquote>
<blockquote>
<p>典型的操作就是<code>in</code>运算符。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    has (target, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">'foo'</span>, <span class="attr">prop</span>: <span class="string">'foo'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'_prop'</span> <span class="keyword">in</span> proxy);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has就会返回 false，从而不会被 in 运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时 has 拦截会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">	has: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> p <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure>

<p>has拦截的是HasProperty操作，而不是HasOwnProperty操作，即 has 方法不判断一个属性是对象自身的属性，还是继承的属性。由于for…in操作内部也会用到 HasProperty 操作，所以has方法在for…in循环时也会生效。</p>
<h3 id="5-construct"><a href="#5-construct" class="headerlink" title="5.construct()"></a>5.construct()</h3><blockquote>
<p>construct方法用于拦截new命令</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">    construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'called: '</span> + args.join(<span class="string">', '</span>));</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> p(<span class="number">1</span>).value</span><br><span class="line"><span class="comment">//"called: 1"</span></span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p><code>construct方法返回的必须是一个对象</code>，否则会报错。</p>
<h3 id="6-deleteProperty"><a href="#6-deleteProperty" class="headerlink" title="6.deleteProperty()"></a>6.deleteProperty()</h3><blockquote>
<p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">	deleteProperty (target, key) &#123;</span><br><span class="line">		invariant(key, <span class="string">'delete'</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invariant</span> (<span class="params">key, action</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private "<span class="subst">$&#123;key&#125;</span>" property`</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">delete</span> proxy._prop</span><br><span class="line"><span class="comment">// Error: Invalid attempt to delete private "_prop" property</span></span><br></pre></td></tr></table></figure>

<p>deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。</p>
<h3 id="7-defineProperty"><a href="#7-defineProperty" class="headerlink" title="7.defineProperty()"></a>7.defineProperty()</h3><blockquote>
<p>defineProperty 方法拦截了 Object.defineProperty 操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">	defineProperty (target, key, descriptor) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span></span><br><span class="line"><span class="comment">// TypeError: proxy defineProperty handler returned false for property '"foo"'</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，defineProperty方法返回false，导致添加新属性会抛出错误。</p>
<h3 id="8-getOwnPropertyDescriptor"><a href="#8-getOwnPropertyDescriptor" class="headerlink" title="8.getOwnPropertyDescriptor()"></a>8.getOwnPropertyDescriptor()</h3><blockquote>
<p>getOwnPropertyDescriptor 方法拦截 Object.getOwnPropertyDescriptor ，返回一个属性描述对象或者 undefined 。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    getOwnPropertyDescriptor(target, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">    _foo: <span class="string">'bar'</span>,</span><br><span class="line">    baz: <span class="string">'tar'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'wat'</span>))</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'_foo'</span>))</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'baz'</span>))</span><br><span class="line"><span class="comment">// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，handler.getOwnPropertyDescriptor 方法对于第一个字符为下划线的属性名会返回 undefined 。</p>
<h3 id="9-getPrototypeOf"><a href="#9-getPrototypeOf" class="headerlink" title="9.getPrototypeOf()"></a>9.getPrototypeOf()</h3><blockquote>
<p>getPrototypeOf 方法主要用来拦截 Object.getPrototypeOf() 运算符，以及其他一些操作：</p>
<ul>
<li>Object.prototype.<strong>proto</strong></li>
<li>Object.prototype.isPrototypeOf()</li>
<li>Object.getPrototypeOf()</li>
<li>Reflect.getPrototypeOf()</li>
<li>instanceof 运算符</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">	getPrototypeOf(target) &#123;</span><br><span class="line">		<span class="keyword">return</span> proto;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p) === proto <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中， getPrototypeOf 方法拦截 Object.getPrototypeOf() ，返回 proto 对象。</p>
<h3 id="10-isExtensible"><a href="#10-isExtensible" class="headerlink" title="10.isExtensible()"></a>10.isExtensible()</h3><blockquote>
<p>isExtensible方法拦截Object.isExtensible 操作。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">	isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"called"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(p)</span><br><span class="line"><span class="comment">// "called"</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码设置了 isExtensible 方法，在调用 Object.isExtensible 时会输出 called</p>
<p>这个方法有一个强限制，如果不能满足下面的条件，就会抛出错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.isExtensible(proxy) === <span class="built_in">Object</span>.isExtensible(target)</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    isExtensible: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(p) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="11-ownKeys"><a href="#11-ownKeys" class="headerlink" title="11.ownKeys()"></a>11.ownKeys()</h3><blockquote>
<p>ownKeys 方法用来拦截 Object.keys() 操作。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">	ownKeys(target) &#123;</span><br><span class="line">		<span class="keyword">return</span> [<span class="string">'hello'</span>, <span class="string">'world'</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.keys(proxy)</span><br><span class="line"><span class="comment">// [ 'hello', 'world' ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码拦截了对于target对象的Object.keys() 操作，返回预先设定的数组。</p>
<h3 id="12-preventExtensions"><a href="#12-preventExtensions" class="headerlink" title="12.preventExtensions()"></a>12.preventExtensions()</h3><blockquote>
<p>preventExtensions 方法拦截 Object.preventExtensions() 。该方法必须返回一个布尔值。</p>
</blockquote>
<p>这个方法有一个限制，只有当 Object.isExtensible(proxy) 为 false （即不可扩展）时， proxy.preventExtensions 才能返回 true ，否则会报错。</p>
<h3 id="13-setPrototypeOf"><a href="#13-setPrototypeOf" class="headerlink" title="13.setPrototypeOf()"></a>13.setPrototypeOf()</h3><blockquote>
<p>setPrototypeOf 方法主要用来拦截 Object.setPrototypeOf 方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">	setPrototypeOf (target, proto) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Changing the prototype is forbidden'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.setPrototypeOf(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，只要修改 target 的原型对象，就会报错</p>
<h3 id="14-Proxy-revocable"><a href="#14-Proxy-revocable" class="headerlink" title="14.Proxy.revocable()"></a>14.Proxy.revocable()</h3><blockquote>
<p>Proxy.revocable方法返回一个可取消的Proxy实例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo <span class="comment">// 123</span></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure>

<p>Proxy.revocable方法返回一个对象，该对象的 proxy 属性是 Proxy 实例， revoke 属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出一个错误。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h3 id="设计的目的"><a href="#设计的目的" class="headerlink" title="设计的目的"></a>设计的目的</h3><ol>
<li><p>将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty ），放到Reflect对象上。</p>
</li>
<li><p>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc) 在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc) 则会返回 false 。</p>
</li>
<li><p>让Object操作都变成函数行为。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Reflect对象的方法和Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loggedObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">	<span class="keyword">get</span>(target, name) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'get'</span>, target, name);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, name);</span><br><span class="line">	&#125;,</span><br><span class="line">	deleteProperty(target, name) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'delete'</span> + name);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, name);</span><br><span class="line">	&#125;,</span><br><span class="line">	has(target, name) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'has'</span> + name);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.has(target, name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，每一个 Proxy 对象的拦截操作（ get 、 delete 、 has ），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>
</blockquote>
</li>
</ol>
<h3 id="1-Reflect-set-target-name-value-receiver"><a href="#1-Reflect-set-target-name-value-receiver" class="headerlink" title="1.Reflect.set(target,name,value,receiver)"></a>1.Reflect.set(target,name,value,receiver)</h3><blockquote>
<p>查找并返回 target 对象的 name 属性，如果没有该属性，则返回 undefined 。如果 name 属性部署了读取函数，则读取函数的this绑定 receiver 。</p>
</blockquote>
<h3 id="2-Reflect-get-target-name-receiver"><a href="#2-Reflect-get-target-name-receiver" class="headerlink" title="2.Reflect.get(target,name,receiver)"></a>2.Reflect.get(target,name,receiver)</h3><blockquote>
<p>设置 target 对象的 name 属性等于 value 。如果 name 属性设置了赋值函数，则赋值函数的 this 绑定 receiver 。</p>
</blockquote>
<h3 id="3-Reflect-apply-target-thisArg-args"><a href="#3-Reflect-apply-target-thisArg-args" class="headerlink" title="3.Reflect.apply(target,thisArg,args)"></a>3.Reflect.apply(target,thisArg,args)</h3><blockquote>
<p>等同于 Function.prototype.apply.call(fun,thisArg,args) 。一般来说，如果要绑定一个函数的this对象，可以这样写 fn.apply(obj, args) ，但是如果函数定义了自己的 apply 方法，就只能写成 Function.prototype.apply.call(fn, obj, args) ，采用Reflect对象可以简化这种操作。</p>
</blockquote>
<h3 id="4-Reflect-has-target-name"><a href="#4-Reflect-has-target-name" class="headerlink" title="4.Reflect.has(target,name)"></a>4.Reflect.has(target,name)</h3><blockquote>
<p>等同于 name in obj</p>
</blockquote>
<h3 id="5-Reflect-construct-target-args"><a href="#5-Reflect-construct-target-args" class="headerlink" title="5.Reflect.construct(target,args)"></a>5.Reflect.construct(target,args)</h3><blockquote>
<p>等同于 new target(…args) ，这提供了一种不使用 new ，来调用构造函数的方法。</p>
</blockquote>
<h3 id="6-Reflect-deleteProperty-obj-name"><a href="#6-Reflect-deleteProperty-obj-name" class="headerlink" title="6.Reflect.deleteProperty(obj, name)"></a>6.Reflect.deleteProperty(obj, name)</h3><blockquote>
<p>等同于 delete obj[name] </p>
</blockquote>
<h3 id="7-Reflect-getPrototypeOf-obj"><a href="#7-Reflect-getPrototypeOf-obj" class="headerlink" title="7.Reflect.getPrototypeOf(obj)"></a>7.Reflect.getPrototypeOf(obj)</h3><blockquote>
<p>读取对象的 <strong>proto</strong> 属性，对应 Object.getPrototypeOf(obj)</p>
</blockquote>
<h3 id="8-Reflect-setPrototypeOf-obj-newProto"><a href="#8-Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="8.Reflect.setPrototypeOf(obj, newProto)"></a>8.Reflect.setPrototypeOf(obj, newProto)</h3><blockquote>
<p>设置对象的 <strong>proto</strong> 属性，对应 Object.setPrototypeOf(obj,newProto)</p>
</blockquote>
<h3 id="9-Reflect-defineProperty-target-name-desc"><a href="#9-Reflect-defineProperty-target-name-desc" class="headerlink" title="9.Reflect.defineProperty(target,name,desc)"></a>9.Reflect.defineProperty(target,name,desc)</h3><h3 id="10-Reflect-ownKeys-target"><a href="#10-Reflect-ownKeys-target" class="headerlink" title="10.Reflect.ownKeys(target)"></a>10.Reflect.ownKeys(target)</h3><h3 id="11-Reflect-isExtensible-target"><a href="#11-Reflect-isExtensible-target" class="headerlink" title="11.Reflect.isExtensible(target)"></a>11.Reflect.isExtensible(target)</h3><h3 id="12-Reflect-preventExtensions-target"><a href="#12-Reflect-preventExtensions-target" class="headerlink" title="12.Reflect.preventExtensions(target)"></a>12.Reflect.preventExtensions(target)</h3><h3 id="13-Reflect-getOwnPropertyDescriptor-target-name"><a href="#13-Reflect-getOwnPropertyDescriptor-target-name" class="headerlink" title="13.Reflect.getOwnPropertyDescriptor(target, name)"></a>13.Reflect.getOwnPropertyDescriptor(target, name)</h3><p>Reflect.set()、Reflect.defineProperty()、Reflect.freeze()、Reflect.seal()和 Reflect.preventExtensions() 返回一个布尔值，表示操作是否成功。它们对应的Object方法，失败时都会抛出错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 失败时抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, name, desc);</span><br><span class="line"><span class="comment">// 失败时返回false</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty(obj, name, desc);</span><br></pre></td></tr></table></figure>

<p>上面代码中， Reflect.defineProperty方法的作用与Object.defineProperty是一样的，都是为对象定义一个属性。但是，Reflect.defineProperty方法失败时，不会抛出错误，只会返回false 。</p>
<h1 id="set和map"><a href="#set和map" class="headerlink" title="set和map"></a>set和map</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</p>
<p><strong>Set 本身是一种构造函数，用来生成 Set 数据结构。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([iterable])</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)	<span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重数组的重复对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">[... new <span class="built_in">Set</span>(arr)]	<span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于<strong>精确相等</strong>运算符（<code>===</code>），主要的区别是<strong><code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">let a = NaN;</span><br><span class="line">let b = NaN;</span><br><span class="line"><span class="keyword">set</span>.add(a);</span><br><span class="line"><span class="keyword">set</span>.add(b);</span><br><span class="line"><span class="keyword">set</span> // Set &#123;<span class="literal">NaN</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">set1.add(<span class="number">5</span>)</span><br><span class="line">set1.add(<span class="string">'5'</span>)</span><br><span class="line"><span class="built_in">console</span>.log([...set1])	<span class="comment">// [5, "5"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Set 实例属性</p>
<ul>
<li><p>constructor： Set构造函数</p>
</li>
<li><p>size：元素数量</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 2, 1])</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.length)	// undefined</span><br><span class="line">console.log(<span class="keyword">set</span>.size)	// 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Set 实例方法</p>
<ul>
<li><p>操作方法</p>
<ul>
<li><p>add(value)：新增，相当于 array里的push</p>
</li>
<li><p>delete(value)：存在即删除集合中value</p>
</li>
<li><p>has(value)：判断集合中是否存在 value</p>
</li>
<li><p>clear()：清空集合</p>
<hr>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add(1).add(2).add(1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.has(1)	// true</span><br><span class="line"><span class="keyword">set</span>.has(3)	// false</span><br><span class="line"><span class="keyword">set</span>.delete(1)	</span><br><span class="line"><span class="keyword">set</span>.has(1)	// false</span><br></pre></td></tr></table></figure>

<p>  <code>Array.from</code> 方法可以将 Set 结构转为数组</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items)</span><br><span class="line"><span class="built_in">console</span>.log(array)	<span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> arr = [...items]</span><br><span class="line"><span class="built_in">console</span>.log(arr)	<span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>遍历方法（遍历顺序为插入顺序）</p>
<ul>
<li><p>keys()：返回一个包含集合中所有键的迭代器</p>
</li>
<li><p>values()：返回一个包含集合中所有值得迭代器</p>
</li>
<li><p>entries()：返回一个包含Set对象中所有元素得键值对迭代器</p>
</li>
<li><p>forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，<strong>没有返回值</strong></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3])</span><br><span class="line">console.log(<span class="keyword">set</span>.keys())	// SetIterator &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.values())	// SetIterator &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.entries())	// SetIterator &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;	<span class="comment">// 1	2	 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;	<span class="comment">// [1, 1]	[2, 2]	[3, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.forEach((value, key) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value)</span><br><span class="line">&#125;)	<span class="comment">// 1 : 1	2 : 2	3 : 3</span></span><br><span class="line"><span class="built_in">console</span>.log([...set])	<span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>  Set 可默认遍历，默认迭代器生成函数是 values() 方法</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>  所以， Set可以使用 map、filter 方法</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3])</span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].map(item =&gt; item * 2))</span><br><span class="line">console.log([...<span class="keyword">set</span>])	// [2, 4, 6]</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].filter(item =&gt; (item &gt;= 4)))</span><br><span class="line">console.log([...<span class="keyword">set</span>])	//[4, 6]</span><br></pre></td></tr></table></figure>

<p>  因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1].filter(<span class="function"><span class="params">value</span> =&gt;</span> set2.has(value)))</span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1, ...set2])</span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1].filter(<span class="function"><span class="params">value</span> =&gt;</span> !set2.has(value)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(intersect)	<span class="comment">// Set &#123;2, 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(union)		<span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(difference)	<span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>

<p>  由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以 key 方法和 value 方法的行为完全一致。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 对象允许你将<strong>弱引用对象</strong>储存在一个集合中</p>
<p>WeakSet 与 Set 的区别：</p>
<ul>
<li>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</li>
<li>WeakSet 对象中储存的对象值都是被弱引用的，即==垃圾回收机制不考虑 WeakSet 对该对象的应用==，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），==WeakSet 对象是无法被遍历的==（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素</li>
</ul>
<p>属性：</p>
<ul>
<li><p>constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">const</span> weakset = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(arr)</span><br><span class="line"><span class="built_in">console</span>.log(weakset)</span><br></pre></td></tr></table></figure>

<p>  将数组作为WeakSet构造函数的参数，数组的成员会自动成为WeakSet的成员，所以数组的成员也必须要是对象。</p>
</li>
</ul>
<p><img src="/Users/dannysoul/Desktop/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9/ES6/assets/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-09-29%20%E4%B8%8A%E5%8D%8810.41.43.png" alt="屏幕快照 2019-09-29 上午10.41.43"></p>
<p>方法：</p>
<ul>
<li>add(value)：在WeakSet 对象中添加一个元素value</li>
<li>has(value)：判断 WeakSet 对象中是否包含value</li>
<li>delete(value)：删除元素 value</li>
<li>clear()：清空所有元素，<strong>注意该方法已废弃</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">ws.add(<span class="built_in">window</span>)</span><br><span class="line">ws.add(obj)</span><br><span class="line"></span><br><span class="line">ws.has(<span class="built_in">window</span>)	<span class="comment">// true</span></span><br><span class="line">ws.has(foo)	<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ws.delete(<span class="built_in">window</span>)	<span class="comment">// true</span></span><br><span class="line">ws.has(<span class="built_in">window</span>)	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>用处：</p>
<p>加入其中的元素不会算入引用计数，所以当其他地方没有对对象的引用之后，就可以删除了，不会造成内存泄漏。</p>
<p>储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>() &#123;</span><br><span class="line">		foos.add(<span class="keyword">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	method () &#123;</span><br><span class="line">		<span class="keyword">if</span> (!foos.has(<span class="keyword">this</span>)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Foo.prototype.method 只能在Foo的实例上调用！'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码保证了 Foo 的实例方法，只能在 Foo 的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑 foos ，也不会出现内存泄漏。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>集合 与 字典 的区别：</p>
<ul>
<li>共同点：集合、字典 可以储存不重复的值</li>
<li>不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">'haha'</span>&#125;</span><br><span class="line">m.set(o, <span class="string">'content'</span>)</span><br><span class="line">m.get(o)	<span class="comment">// content</span></span><br><span class="line"></span><br><span class="line">m.has(o)	<span class="comment">// true</span></span><br><span class="line">m.delete(o)	<span class="comment">// true</span></span><br><span class="line">m.has(o)	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键</p>
<p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>
<p><strong>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构</strong>都可以当作<code>Map</code>构造函数的参数，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([</span><br><span class="line">  ['foo', 1],</span><br><span class="line">  ['bar', 2]</span><br><span class="line">]);</span><br><span class="line">const m1 = new Map(<span class="keyword">set</span>);</span><br><span class="line">m1.<span class="keyword">get</span>('foo') // 1</span><br><span class="line"></span><br><span class="line">const m2 = new Map([['baz', 3]]);</span><br><span class="line">const m3 = new Map(m2);</span><br><span class="line">m3.<span class="keyword">get</span>('baz') // 3</span><br></pre></td></tr></table></figure>

<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>().get(<span class="string">'asfddfsasadf'</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>注意，==只有对同一个对象的引用，Map 结构才将其视为同一个键==。这一点要非常小心。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>
<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="number">-0</span>, <span class="number">123</span>);</span><br><span class="line">map.get(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">map.set(<span class="string">'true'</span>, <span class="number">2</span>);</span><br><span class="line">map.get(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">map.get(<span class="literal">undefined</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="literal">NaN</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>Map 的属性及方法</p>
<p>属性：</p>
<ul>
<li><p>constructor：Map构造函数</p>
</li>
<li><p>size：返回字典中所包含的元素个数</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'An'</span>],</span><br><span class="line">  [<span class="string">'des'</span>, <span class="string">'JS'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>操作方法：</p>
<ul>
<li>set(key, value)：向字典中添加新元素，set 方法返回的是Map本身，因此可以采用链式写法</li>
<li>get(key)：通过键查找特定的数值并返回，找不到的话返回undefined</li>
<li>has(key)：判断字典中是否存在键key</li>
<li>delete(key)：通过键 key 从字典中移除对应的数据</li>
<li>clear()：将这个字典中的所有元素删除</li>
</ul>
<p>遍历方法</p>
<ul>
<li>Keys()：将字典中包含的所有键名以迭代器形式返回</li>
<li>values()：将字典中包含的所有数值以迭代器形式返回</li>
<li>entries()：返回所有成员的迭代器</li>
<li>forEach()：遍历字典的所有成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">            [<span class="string">'name'</span>, <span class="string">'An'</span>],</span><br><span class="line">            [<span class="string">'des'</span>, <span class="string">'JS'</span>]</span><br><span class="line">        ]);</span><br><span class="line"><span class="built_in">console</span>.log(map.entries())	<span class="comment">// MapIterator &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()) <span class="comment">// MapIterator &#123;"name", "des"&#125;</span></span><br></pre></td></tr></table></figure>

<p>Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">map[<span class="built_in">Symbol</span>.iterator] === map.entries</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>
<p>对于 forEach ，看一个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reporter = &#123;</span><br><span class="line">  report: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'name'</span>, <span class="string">'An'</span>],</span><br><span class="line">    [<span class="string">'des'</span>, <span class="string">'JS'</span>]</span><br><span class="line">])</span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br><span class="line"><span class="comment">// Key: name, Value: An</span></span><br><span class="line"><span class="comment">// Key: des, Value: JS</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中， forEach 方法的回调函数的 this，就指向 reporter</p>
<p><strong>与其他数据结构的相互转换</strong></p>
<ol>
<li><p>Map 转 Array</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="built_in">console</span>.log([...map])	<span class="comment">// [[1, 1], [2, 2], [3, 3]]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Array 转 Map</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="built_in">console</span>.log(map)	<span class="comment">// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Map 转 Object</p>
<p> 因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToObj</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">        obj[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'name'</span>, <span class="string">'An'</span>).set(<span class="string">'des'</span>, <span class="string">'JS'</span>)</span><br><span class="line">mapToObj(map)  <span class="comment">// &#123;name: "An", des: "JS"&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object 转 Map</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">        map.set(key, obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToMap(&#123;<span class="string">'name'</span>: <span class="string">'An'</span>, <span class="string">'des'</span>: <span class="string">'JS'</span>&#125;) <span class="comment">// Map &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Map 转 JSON</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToJson</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'name'</span>, <span class="string">'An'</span>).set(<span class="string">'des'</span>, <span class="string">'JS'</span>)</span><br><span class="line">mapToJson(map)	<span class="comment">// [["name","An"],["des","JS"]]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON 转 Map</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objToMap(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(<span class="string">'&#123;"name": "An", "des": "JS"&#125;'</span>) <span class="comment">// Map &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap 对象是一组键值对的集合，其中的<strong>键是弱引用对象，而值可以是任意</strong>。</p>
<p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p>
<p>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。</p>
<p>WeakMap 的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后， WeakMap 自动移除对应的键值对。典型应用是，一个对应DOM元素的 WeakMap 结构，当某个DOM元素被清除，其所对应的 WeakMap 记录就会自动被移除。基本上， WeakMap 的专用场合就是，它的键所对应的对象，可能会在将来消失。 WeakMap 结构有助于防止内存泄漏。</p>
<p>属性：</p>
<ul>
<li>constructor：构造函数</li>
</ul>
<p>方法：</p>
<ul>
<li>has(key)：判断是否有 key 关联对象</li>
<li>get(key)：返回key关联对象（没有则则返回 undefined）</li>
<li>set(key)：设置一组key关联对象</li>
<li>delete(key)：移除 key 的关联对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>);</span><br><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(myElement);</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中， myElement 是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在WeakMap里，对应的键名就是 myElement 。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<p>WeakMap的另一个用处是部署私有属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _counter = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> _action = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(counter, action) &#123;</span><br><span class="line">		_counter.set(<span class="keyword">this</span>, counter);</span><br><span class="line">		_action.set(<span class="keyword">this</span>, action);</span><br><span class="line">	&#125;</span><br><span class="line">	dec() &#123;</span><br><span class="line">		<span class="keyword">let</span> counter = _counter.get(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		counter--;</span><br><span class="line">		_counter.set(<span class="keyword">this</span>, counter);</span><br><span class="line">		<span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">			_action.get(<span class="keyword">this</span>)();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Countdown(<span class="number">2</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'DONE'</span>));</span><br><span class="line">c.dec()</span><br><span class="line">c.dec()</span><br><span class="line"><span class="comment">// DONE</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Countdown类的两个内部属性 _counter 和 _action ，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Set<ul>
<li>成员唯一、无序且不重复</li>
<li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）</li>
<li>可以遍历，方法有：add、delete、has</li>
</ul>
</li>
<li>WeakSet<ul>
<li>成员都是对象</li>
<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏</li>
<li>不能遍历，方法有add、delete、has</li>
</ul>
</li>
<li>Map<ul>
<li>本质上是键值对的集合，类似集合</li>
<li>可以遍历，方法很多可以跟各种数据格式转换</li>
</ul>
</li>
<li>WeakMap<ul>
<li>只接受对象作为键名（null除外），不接受其他类型的值作为键名</li>
<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li>
<li>不能遍历，方法有get、set、has、delete</li>
</ul>
</li>
</ul>
<h2 id="扩展：Object与Set、Map"><a href="#扩展：Object与Set、Map" class="headerlink" title="扩展：Object与Set、Map"></a>扩展：Object与Set、Map</h2><ol>
<li><p>Object 与 Set</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">const</span> properties1 = &#123;</span><br><span class="line">    <span class="string">'width'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'height'</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(properties1[<span class="string">'width'</span>]? <span class="literal">true</span>: <span class="literal">false</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">const</span> properties2 = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">properties2.add(<span class="string">'width'</span>)</span><br><span class="line">properties2.add(<span class="string">'height'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(properties2.has(<span class="string">'width'</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object 与 Map</p>
</li>
</ol>
<p>JS 中的对象（Object），本质上是键值对的集合（hash 结构）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'App'</span>);</span><br><span class="line"></span><br><span class="line">data[element] = <span class="string">'metadata'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data[<span class="string">'[object HTMLCollection]'</span>]) <span class="comment">// "metadata"</span></span><br></pre></td></tr></table></figure>

<p>但当以一个DOM节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 <strong>字符串-值</strong> 对应，Map则提供了 <strong>值-值</strong> 的对应。</p>
<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>Iterator接口的目的就是为所有数据结构提供了一种统一的访问机制，即<code>for…of</code>循环。当使用这个<code>for…of</code>循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</p>
<ul>
<li><p>定义：为各种不同的数据结构提供统一的访问机制。</p>
</li>
<li><p>原理：创建一个指针指向首个成员，按照次序使用<code>next()</code>指向下一个成员，直接到结束位置(数据结构只要部署<code>Iterator接口</code>就可完成遍历操作)</p>
</li>
<li><p>Iterator的作用有三个：</p>
<ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>使得数据结构的成员能够按某种次序排列；</li>
<li>ES6创造了一种新的遍历命令<code>for…of</code>循环，Iterator接口主要供<code>for…of</code>消费。</li>
</ol>
</li>
<li><p>部署：默认部署在<code>Symbol.iterator</code>(具备此属性被认为<code>可遍历的iterable</code>)</p>
</li>
<li><p>遍历器对象</p>
<ul>
<li><strong>next()</strong>：下一步操作，返回<code>{ done, value }</code>(必须部署)</li>
<li><strong>return()</strong>：<code>for-of</code>提前退出调用，返回<code>{ done: true }</code></li>
<li><strong>throw()</strong>：不使用，配合<code>Generator函数</code>使用</li>
</ul>
</li>
</ul>
<p>在ES6中有三类数据结构原生具备Iterator接口：<code>数组、某些类似数组的对象、Set和Map结构</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iter); <span class="comment">// Object [Array Iterator] &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next());<span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next());<span class="comment">// &#123; value: 'b', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next());<span class="comment">// &#123; value: 'c', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next());<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作Map结构使用，ES5没有Map结构，而ES6原生提供了。一个对象如果要有可被 for…of 循环调用的Iterator接口，就必须在 Symbol.iterator 的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rangeIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(start, end) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.end) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value++;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: <span class="literal">false</span>,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> &#123;</span><br><span class="line">            done: <span class="literal">true</span>,</span><br><span class="line">            value: <span class="literal">undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> rangeIterator(start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) <span class="built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure>

<p>上述是一个类部署的Iterator接口的写法，Symbol.iterator 属性对应一个函数，执行后返回当前对象的遍历器对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    data: [<span class="string">'hello'</span>, <span class="string">'world'</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">let</span> self = <span class="keyword">this</span>,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: self.data[index++],</span><br><span class="line">                        done: <span class="literal">false</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: <span class="literal">undefined</span>,</span><br><span class="line">                    done: <span class="literal">true</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于类似数组的对象（==存在数值键名和length属性==），部署Iterator接口，有一个简便方法，就是 Symbol.iterator 方法直接引用数组的Iterator接口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = [][<span class="built_in">Symbol</span>.iterator];</span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)] <span class="comment">// 可以执行了</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">	<span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">	<span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">	<span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">	length: <span class="number">3</span>,</span><br><span class="line">	[<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(item); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>注意，普通对象部署数组的 Symbol.iterator 方法，并无效果</code>。</p>
<p>任何 Iterator 接口的对象，都可以用<code>扩展运算符</code>转为真正的数组，对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;  </span><br><span class="line"><span class="string">'0'</span>: <span class="string">'a'</span>,  </span><br><span class="line"><span class="string">'1'</span>: <span class="string">'b'</span>,  </span><br><span class="line"><span class="string">'2'</span>: <span class="string">'c'</span>,  </span><br><span class="line">length: <span class="number">3</span>  </span><br><span class="line">&#125;;   </span><br><span class="line"><span class="keyword">let</span> arr = [...arrayLike]; </span><br><span class="line"><span class="comment">// Uncaught TypeError: arrayLike is not iterable</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">Array</span>.from(iterable)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><ul>
<li>定义：调用<code>Iterator接口</code>产生遍历器对象(<code>for-of</code>内部调用数据结构的<code>Symbol.iterator()</code>)</li>
<li>遍历字符串：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code>(可识别32位UTF-16字符)</li>
<li>遍历数组：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code></li>
<li>遍历对象：<code>for-in</code>获取<code>键</code>，<code>for-of</code>需自行部署</li>
<li>遍历Set：<code>for-of</code>获取<code>值</code> =&gt; <code>for (const v of set)</code></li>
<li>遍历Map：<code>for-of</code>获取<code>键值对</code> =&gt;  <code>for (const [k, v] of map)</code></li>
<li>遍历类数组：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code>(无<code>Iterator接口的类数组</code>可用<code>Array.from()</code>转换)</li>
<li>计算生成数据结构：<code>Array</code>、<code>Set</code>、<code>Map</code><ul>
<li><strong>keys()</strong>：返回遍历器对象，遍历所有的键</li>
<li><strong>values()</strong>：返回遍历器对象，遍历所有的值</li>
<li><strong>entries()</strong>：返回遍历器对象，遍历所有的键值对</li>
</ul>
</li>
<li>与<code>for-in</code>区别 <ul>
<li>有着同<code>for-in</code>一样的简洁语法，但没有<code>for-in</code>那些缺点、</li>
<li>不同于<code>forEach()</code>，它可与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</li>
<li>提供遍历所有数据结构的统一操作接口</li>
</ul>
</li>
</ul>
<h3 id="调用Iterator的场合"><a href="#调用Iterator的场合" class="headerlink" title="调用Iterator的场合"></a>调用Iterator的场合</h3><h4 id="1-解构赋值"><a href="#1-解构赋值" class="headerlink" title="1.解构赋值"></a>1.解构赋值</h4><blockquote>
<p>对数组和Set结构进行解构赋值时，会默认调用 Symbol.iterator 方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set().add('a').add('b').add('c');</span><br><span class="line"></span><br><span class="line">let [x,y] = <span class="keyword">set</span>;</span><br><span class="line"></span><br><span class="line">// x='a'; y='b'</span><br><span class="line"></span><br><span class="line">let [first, ...rest] = <span class="keyword">set</span>;</span><br><span class="line"></span><br><span class="line">// first='a'; rest=['b','c'];</span><br></pre></td></tr></table></figure>



<h4 id="2-扩展运算符"><a href="#2-扩展运算符" class="headerlink" title="2.扩展运算符"></a>2.扩展运算符</h4><blockquote>
<p>扩展运算符（…）也会调用默认的iterator接口。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// ['h','e','l','l','o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure>

<p>上面代码的扩展运算符内部就调用Iterator接口。实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure>

<h4 id="3-yield"><a href="#3-yield" class="headerlink" title="3.yield*"></a>3.yield*</h4><blockquote>
<p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span>*[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-其他场合"><a href="#4-其他场合" class="headerlink" title="4.其他场合"></a>4.其他场合</h4><blockquote>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
</blockquote>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()(比如 new Map([[‘a’,1],[‘b’,2]]))</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h3 id="字符串的Iterator接口"><a href="#字符串的Iterator接口" class="headerlink" title="字符串的Iterator接口"></a>字符串的Iterator接口</h3><p>字符串是一个类似数组的对象，也原生具有Iterator接口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">"hi"</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line"><span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iterator.next() <span class="comment">// &#123; value: "h", done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: "i", done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以覆盖原生的 Symbol.iterator 方法，达到修改遍历器行为的目的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串的Iterator接口</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hi"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...str]); <span class="comment">// [ 'h', 'i' ]</span></span><br><span class="line"></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._first) &#123;</span><br><span class="line">                <span class="keyword">this</span>._first = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: <span class="string">"bye"</span>,</span><br><span class="line">                    done: <span class="literal">false</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    done: <span class="literal">true</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        _first: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...str]); <span class="comment">//[ 'bye' ]</span></span><br><span class="line"><span class="comment">//字符串str的 Symbol.iterator 方法被修改了，所以扩展运算符</span></span><br><span class="line"><span class="comment">//（ ... ）返回的值变成了 bye ，而字符串本身还是 hi</span></span><br></pre></td></tr></table></figure>

<h3 id="Iterator接口与Generator函数"><a href="#Iterator接口与Generator函数" class="headerlink" title="Iterator接口与Generator函数"></a>Iterator接口与Generator函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">* [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">		<span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>

<h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h4><p>数组原生具备iterator接口， for…of 循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上这俩个写法是等价的</span></span><br></pre></td></tr></table></figure>

<p>JavaScript原有的 for…in 循环，只能获得对象的键名，不能直接获取键值。ES6提供 for…of 循环，允许遍历获得键值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表明， for…in 循环读取键名， for…of 循环读取键值。如果要通过 for…of 循环，获取数组的索引，可以借助数组实例的 entries 方法和 keys 方法，参见《数组的扩展》章节。</p>
<p>for…of 循环调用遍历器接口，数组的遍历器接口<code>只返回具有数字索引的属性</code>。这一点跟 for…in 循环也不一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i); <span class="comment">// "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i); <span class="comment">// "3", "5", "7"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中， for…of 循环不会返回数组 arr 的 foo 属性。</p>
<h4 id="2-Set和Map"><a href="#2-Set和Map" class="headerlink" title="2.Set和Map"></a>2.Set和Map</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"><span class="keyword">let</span> es6 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">es6.set(<span class="string">"edition"</span>, <span class="number">6</span>);</span><br><span class="line">es6.set(<span class="string">"committee"</span>, <span class="string">"TC39"</span>);</span><br><span class="line">es6.set(<span class="string">"standard"</span>, <span class="string">"ECMA-262"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(name + <span class="string">": "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure>

<p>Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。</p>
<h4 id="3-计算生成的数据结构"><a href="#3-计算生成的数据结构" class="headerlink" title="3.计算生成的数据结构"></a>3.计算生成的数据结构</h4><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象。</p>
<p>entries() 返回一个遍历器对象，用来遍历 [键名, 键值] 组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的iterator接口，默认就是调用entries方法。</p>
<p>keys() 返回一个遍历器对象，用来遍历所有的键名。</p>
<p>values() 返回一个遍历器对象，用来遍历所有的键值。</p>
<p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.entries()); <span class="comment">//Object [Array Iterator] &#123;&#125;</span></span><br><span class="line"><span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure>

<h4 id="4-类似数组的对象"><a href="#4-类似数组的对象" class="headerlink" title="4.类似数组的对象"></a>4.类似数组的对象</h4><p>类似数组的对象包括好几类。下面是 for…of 循环用于字符串、DOM NodeList对象、arguments对象的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">	p.classList.add(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure>

<p>并不是所有类似数组的对象都具有iterator接口，一个简便的解决方法，就是使用<code>Array.from方法将其转为数组</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-对象"><a href="#5-对象" class="headerlink" title="5.对象"></a>5.对象</h4><p>对于普通的对象， for…of 结构不能直接使用，会报错，必须部署了iterator接口后才能使用。但是，这样情况下， for…in 循环依然可以用来遍历键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> es6 = &#123;</span><br><span class="line">	edition: <span class="number">6</span>,</span><br><span class="line">	committee: <span class="string">"TC39"</span>,</span><br><span class="line">	standard: <span class="string">"ECMA-262"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (e <span class="keyword">in</span> es6) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition</span></span><br><span class="line"><span class="comment">// committee</span></span><br><span class="line"><span class="comment">// standard</span></span><br><span class="line"><span class="keyword">for</span> (e <span class="keyword">of</span> es6) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: es6 is not iterable</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，对于普通的对象， for…in 循环可以遍历键名， for…of 循环会报错</p>
<p>一种解决方法是，使用 Object.keys 方法将对象的键名生成一个数组，然后遍历这个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(key + <span class="string">": "</span> + someObject[key]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个方法是使用Generator函数将对象重新包装一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, <span class="string">"-&gt;"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure>

<h4 id="与其他遍历方法的比较"><a href="#与其他遍历方法的比较" class="headerlink" title="与其他遍历方法的比较"></a>与其他遍历方法的比较</h4><p>最原始的就是for循环，但是太麻烦，因此数组提供内置的forEach方法，但是这种方法的弊端在于无法跳出forEach 循环，break命令或return命令都不能奏效。</p>
<p>for…in</p>
<p>for…in 循环可以遍历数组的键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for…in循环有几个缺点：</p>
<ul>
<li>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。</li>
<li>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至<code>包括原型链上的键</code>。</li>
<li>某些情况下，for…in循环会以任意顺序遍历键名。</li>
</ul>
<p>总之， for…in 循环主要是为遍历对象而设计的，不适用于遍历数组。</p>
<p>for…of 循环相比上面几种做法，有一些显著的优点：</p>
<p><code>有着同for...in一样的简洁语法，但是没有for...in那些缺点。不同用于forEach方法，它可以与break、continue和return配合使用。提供了遍历所有数据结构的统一操作接口</code>。</p>
<p>下面是一个使用break语句，跳出 for…of 循环的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子，会输出斐波纳契数列小于等于1000的项。如果当前项大于1000，就会使用break语句跳出 for…of 循环。</p>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><ul>
<li>每次调用<code>next()</code>，指针就从<code>函数头部</code>或<code>上次停下的位置</code>开始执行，直到遇到下一个<code>yield命令</code>或<code>return语句</code>为止</li>
<li>函数内部可不用<code>yield命令</code>，但会变成单纯的<code>暂缓执行函数</code>(还是需要<code>next()</code>触发)</li>
<li><code>yield命令</code>是暂停执行的标记，<code>next()</code>是恢复执行的操作</li>
<li><code>yield命令</code>用在另一个表达式中必须放在<code>圆括号</code>里</li>
<li><code>yield命令</code>用作函数参数或放在赋值表达式的右边，可不加<code>圆括号</code></li>
<li><code>yield命令</code>本身没有返回值，可认为是返回<code>undefined</code></li>
<li><code>yield命令表达式</code>为惰性求值，等<code>next()</code>执行到此才求值</li>
<li>函数调用后生成遍历器对象，此对象的<code>Symbol.iterator</code>是此对象本身</li>
<li>在函数运行的不同阶段，通过<code>next()</code>从外部向内部注入不同的值，从而调整函数行为</li>
<li>首个<code>next()</code>用来启动遍历器对象，后续才可传递参数</li>
<li>想首次调用<code>next()</code>时就能输入值，可在函数外面再包一层</li>
<li>一旦<code>next()</code>返回对象的<code>done</code>为<code>true</code>，<code>for-of</code>遍历会中止且不包含该返回对象</li>
<li>函数内部部署<code>try-finally</code>且正在执行<code>try</code>，那么<code>return()</code>会导致立刻进入<code>finally</code>，执行完<code>finally</code>以后整个函数才会结束</li>
<li>函数内部没有部署<code>try-catch</code>，<code>throw()</code>抛错将被外部<code>try-catch</code>捕获</li>
<li><code>throw()</code>抛错要被内部捕获，前提是必须<code>至少执行过一次next()</code></li>
<li><code>throw()</code>被捕获以后，会附带执行下一条<code>yield命令</code></li>
<li>函数还未开始执行，这时<code>throw()</code>抛错只可能抛出在函数外部</li>
</ul>
<p>概要：</p>
<blockquote>
<p>Generator函数是一个状态机，封装了多个内部状态</p>
<p>执行Generator函数会返回一个遍历器对象，也就是说Generator除了是一个状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>
</blockquote>
<p>特征：</p>
<ul>
<li><code>function</code>关键字和函数名之间有个*号</li>
<li>函数体内部使用 yield 语句，定义不同的内部状态</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>

<p>Generator函数和普通函数不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一次调用，Generator函数开始执行，直到遇到第一个 yield 语句为止。 next 方法返回一个对象，它的 value 属性就是当前 yield 语句的值hello， done 属性的值false，表示遍历还没有结束。</li>
<li>第二次调用，Generator函数从上次 yield 语句停下的地方，一直执行到下一个 yield 语句。next 方法返回的对象的 value 属性就是当前 yield 语句的值world， done属性的值false，表示遍历还没有结束。</li>
<li>第三次调用，Generator函数从上次 yield 语句停下的地方，一直执行到 return 语句（如果没有return语句，就执行到函数结束）。 next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为undefined）， done 属性的值true，表示遍历已经结束。</li>
<li>第四次调用，此时Generator函数已经运行完毕， next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。</li>
</ul>
<h3 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h3><p>由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。</p>
<p>遍历器对象的 next 方法的运行逻辑如下。</p>
<p>（1）遇到 yield 语句，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。</p>
<p>（2）下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 语句。</p>
<p>（3）如果没有再遇到新的 yield 语句，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。</p>
<p>（4）如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined 。</p>
<p>需要注意的是， yield 语句后面的表达式，只有当调用 next 方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（LazyEvaluation）的语法功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数在调用时不会立即求值，只会在next方法将指针移到这一句时，才会求值。</p>
<p><code>yield和return语句的区别?</code></p>
<ul>
<li>相同点：<ul>
<li>都能返回紧跟在语句后面那个表达式的值</li>
</ul>
</li>
<li>不同点：<ul>
<li>每次遇到yield时，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备这个功能</li>
<li>一个函数最多只能执行一次return语句，但是可以执行多次yield语句</li>
</ul>
</li>
</ul>
<p><code>Generator函数可以不用yield，这样就变成了一个单纯的暂缓执行函数</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'执行了！'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = f();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	generator.next()</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>yield不能用在普通函数中，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = a[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span>* flat(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> f <span class="keyword">of</span> flat(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure>

<p><code>yield</code>语句如果用在一个表达式之中，必须放在圆括号里面。用作函数参数或者赋值表达式右边可以不加括号</p>
<h3 id="与Iterator接口的关系"><a href="#与Iterator接口的关系" class="headerlink" title="与Iterator接口的关系"></a>与Iterator接口的关系</h3><p>由于Generator函数就是遍历器生成函数，因此可以把<code>Generator</code>赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有Iterator接口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Generator函数赋值给 Symbol.iterator 属性，从而使得 myIterable 对象具有了Iterator接口，可以被 … 运算符遍历了。Generator函数执行后，返回一个遍历器对象。该对象本身也具有 Symbol.iterator 属性，执行后返回自身。</p>
<p>Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"><span class="built_in">console</span>.log(g[<span class="built_in">Symbol</span>.iterator]() === g); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h3><p><code>yield</code>句本身没有返回值，或者说返回值为undefined。<code>next</code>方法可以带一个参数，这个参数就会被当作上一个<code>yield</code>语句的返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span>(x + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span>(y / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"><span class="keyword">let</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>

<p>第二次运行 next 方法的时候不带参数，导致y的值等于 2 * undefined （即 NaN ），除以3以后还是 NaN ，因此返回对象的 value 属性也等于 NaN 。第三次运行 Next 方法的时候不带参数，所以 z 等于 undefined ，返回对象的 value 属性等于 5 + NaN + undefined ，即 NaN 。</p>
<p>如果向 next 方法提供参数，返回结果就完全不一样了。上面代码第一次调用 b 的 next 方法时，返回 x+1 的值6；第二次调用 next 方法，将上一次 yield 语句的值设为12，因此 y 等于24，返回 y / 3 的值8；第三次调用 next 方法，将上一次 yield 语句的值设为13，因此 z 等于13，这时 x 等于</p>
<p>5， y 等于24，所以 return 语句的值等于42。</p>
<p>注意，由于 next 方法的参数表示上一个 yield 语句的返回值，所以<code>第一次使用 next 方法时，不能带有参数</code>。V8引擎直接忽略第一次使用 next 方法时的参数，只有从第二次使用 next 方法开始，参数才是有效的。从语义上讲，第一个 next 方法用来启动遍历器对象，所以不用带有参数。</p>
<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p><code>for…of</code>循环可以自动遍历调用Generator函数时生成的Iterator对象，且此时不再需要调用<code>next</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>

<p>一旦<code>next</code>方法的返回对象的done属性为true，for…of循环就会终止。</p>
<p>for…of 循环、扩展运算符（ … ）、解构赋值和 Array.from 方法内部调用的，都是遍历器接口。这意味着，它们可以将Generator函数返回的Iterator对象，作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">[...numbers()] <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = numbers();</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h3><p>Generator函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	i.throw(<span class="string">'a'</span>);</span><br><span class="line">	i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure>

<p>如果Generator内部没有部署<code>try…catch</code>代码块，那么抛出的错误直接被外部<code>catch</code>代码块捕获</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">yield</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	i.throw(<span class="string">'a'</span>);</span><br><span class="line">	i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 a</span></span><br></pre></td></tr></table></figure>

<p>throw 方法被捕获以后，会附带执行下一条 yield 语句。也就是说，会附带执行一次 next 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">	<span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next() <span class="comment">// a</span></span><br><span class="line">g.throw() <span class="comment">// b</span></span><br><span class="line">g.next() <span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个 yield 语句，可以只用一个try…catch 代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部写一次 catch 语句就可以了。</p>
<p>Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的 catch 捕获。</p>
<p>一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 next 方法，将返回一个 value 属性等于 undefined 、 done 属性等于 true 的对象，即JavaScript引擎认为这个Generator已经运行结束了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'throwing an exception'</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'generator broke!'</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> v;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'starting generator'</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        v = generator.next();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'第一次运行next方法'</span>, v);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        v = generator.next();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'第二次运行next方法'</span>, v);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        v = generator.next();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'第三次运行next方法'</span>, v);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'caller done'</span>);</span><br><span class="line">&#125;</span><br><span class="line">log(g());</span><br><span class="line"><span class="comment">// starting generator</span></span><br><span class="line"><span class="comment">// 第一次运行next方法 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// throwing an exception</span></span><br><span class="line"><span class="comment">// 捕捉错误 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// 第三次运行next方法 &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// caller done</span></span><br></pre></td></tr></table></figure>

<p>上面代码一共三次运行 next 方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator函数就已经结束了，不再执行下去了。</p>
<h3 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h3><p>Generator函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历Generator函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">'foo'</span>) <span class="comment">// &#123; value: "foo", done: true &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果Generator函数内部有 try…finally 代码块，那么 return 方法会推迟到 finally 代码块执行完再执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = numbers()</span><br><span class="line">g.next() <span class="comment">// &#123; done: false, value: 1 &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; done: false, value: 2 &#125;</span></span><br><span class="line">g.return(<span class="number">7</span>) <span class="comment">// &#123; done: false, value: 4 &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; done: false, value: 5 &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; done: true, value: 7 &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用 return 方法后，就开始执行 finally 代码块，然后等到 finally 代码块执行完，再执行 return 方法。</p>
<h3 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield*语句"></a>yield*语句</h3><p>用来在一个Generator函数里面执行另一个Generator函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'open'</span>;</span><br><span class="line">    <span class="keyword">yield</span> inner();</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'close'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = outer1()</span><br><span class="line">gen.next().value <span class="comment">// "open"</span></span><br><span class="line">gen.next().value <span class="comment">// 返回一个遍历器对象</span></span><br><span class="line">gen.next().value <span class="comment">// "close"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'open'</span></span><br><span class="line">    <span class="keyword">yield</span>* inner()</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'close'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = outer2()</span><br><span class="line">gen.next().value <span class="comment">// "open"</span></span><br><span class="line">gen.next().value <span class="comment">// "hello!"</span></span><br><span class="line">gen.next().value <span class="comment">// "close"</span></span><br></pre></td></tr></table></figure>

<p>任何数据结构只要有Iterator接口，就可以被<code>yield*</code>遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> read = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">	<span class="keyword">yield</span>* <span class="string">'hello'</span>;</span><br><span class="line">&#125;)();</span><br><span class="line">read.next().value <span class="comment">// "hello"</span></span><br><span class="line">read.next().value <span class="comment">// "h"</span></span><br></pre></td></tr></table></figure>

<p>如果被代理的Generator函数有 return 语句，那么就可以向代理它的Generator函数返回数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">yield</span>* foo();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"v: "</span> + v);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = bar();</span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// "v: foo"</span></span><br><span class="line"><span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码在第四次调用 next 方法的时候，屏幕上会有输出，这是因为函数 foo 的 return 语句，向函数 bar 提供了返回值。</p>
<h3 id="作为对象属性的Generator函数"><a href="#作为对象属性的Generator函数" class="headerlink" title="作为对象属性的Generator函数"></a>作为对象属性的Generator函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	* myGeneratorMethod() &#123;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中， myGeneratorMethod 属性前面有一个星号，表示这个属性是一个Generator函数。</p>
<p>它的完整形式如下，与上面的写法是等价的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ···</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Generator函数的this"><a href="#Generator函数的this" class="headerlink" title="Generator函数的this"></a>Generator函数的this</h3><p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的 prototype 对象上的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">g.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line">obj <span class="keyword">instanceof</span> g <span class="comment">// true</span></span><br><span class="line">obj.hello() <span class="comment">// 'hi!'</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，Generator函数 g 返回的遍历器 obj ，是 g 的实例，而且继承了 g.prototype 。但是，如果把 g 当作普通的构造函数，并不会生效，因为 g 返回的总是遍历器对象，而不是 this 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line">obj.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>那么如何让Generator函数返回一个正常的对象实例</p>
<ol>
<li><p>让其绑定一个空对象</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> f = F.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.next());<span class="comment">//&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next());<span class="comment">//&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next());<span class="comment">//&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b);<span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.c);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定F.prototype</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = F.call(F.prototype);</span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line">f.a <span class="comment">// 1</span></span><br><span class="line">f.b <span class="comment">// 2</span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再将 F 改成构造函数，就可以对它执行 new 命令了</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> gen.call(gen.prototype);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line">f.a <span class="comment">// 1</span></span><br><span class="line">f.b <span class="comment">// 2</span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li><p>Generator与状态机</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ticking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> clock = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ticking)</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'Tick!'</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'Tock!'</span>);</span><br><span class="line">	ticking = !ticking;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clock = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Tick!'</span>);</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Tock!'</span>);</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量 ticking ，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p>
</li>
</ol>
<ol start="2">
<li><p>控制流管理</p>
<p> 如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">step1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">	step2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</span><br><span class="line">		step3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</span><br><span class="line">			step4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</span><br><span class="line">				<span class="comment">// Do something with value4</span></span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 采用Promise改写上面的代码</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Q.fcall(step1)</span><br><span class="line">.then(step2)</span><br><span class="line">.then(step3)</span><br><span class="line">.then(step4)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// Do something with value4</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">&#125;)</span><br><span class="line">.done();</span><br></pre></td></tr></table></figure>

<p> 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">longRunningTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> value1 = <span class="keyword">yield</span> step1();</span><br><span class="line">		<span class="keyword">let</span> value2 = <span class="keyword">yield</span> step2(value1);</span><br><span class="line">		<span class="keyword">let</span> value3 = <span class="keyword">yield</span> step3(value2);</span><br><span class="line">		<span class="keyword">let</span> value4 = <span class="keyword">yield</span> step4(value3);</span><br><span class="line">		<span class="comment">// Do something with value4</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">		<span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署iterator接口</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> key = keys[i];</span><br><span class="line">        <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">    foo: <span class="number">3</span>,</span><br><span class="line">    bar: <span class="number">7</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 3</span></span><br><span class="line"><span class="comment">// bar 7</span></span><br></pre></td></tr></table></figure>

<p>myObj是一个普通对象，通过iterEntries函数，就有了iterator接口。也就是说，可以在任意对象上部署next方法。</p>
<ol start="4">
<li><p>作为数据结构</p>
<p> Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为</p>
<p> Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数</p>
<p> 组的接口。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'hello.txt'</span>);</span><br><span class="line">    <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'world.txt'</span>);</span><br><span class="line">    <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'and-such.txt'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处</p>
<p> 理数组那样，处理这三个返回的函数。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (task <span class="keyword">of</span> doStuff()) &#123;</span><br><span class="line">	<span class="comment">// task是一个函数，可以像回调函数那样使用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>Promise</code> 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是：</p>
<ol>
<li>等待中（pending）</li>
<li>完成了 （resolved）</li>
<li>拒绝了（rejected）</li>
</ol>
<p>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">  <span class="comment">// 无效</span></span><br><span class="line">  reject(<span class="string">'reject'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new Promise'</span>)</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'finifsh'</span>)</span><br><span class="line"><span class="comment">// new Promise -&gt; finifsh</span></span><br></pre></td></tr></table></figure>

<p><code>Promise</code> 实现了链式调用，也就是说每次调用 <code>then</code> 之后返回的都是一个 <code>Promise</code>，并且是一个全新的 <code>Promise</code>，原因也是因为状态不可变。如果你在 <code>then</code> 中 使用了 <code>return</code>，那么 <code>return</code> 的值会被 <code>Promise.resolve()</code> 包装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// 包装成 Promise.resolve(2)</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 2</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>当然了，<code>Promise</code> 也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax(url)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url1)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url2)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>

<p>前面都是在讲述 <code>Promise</code> 的一些优点和特点，其实它也是存在一些缺点的，比如无法取消 <code>Promise</code>，错误需要通过回调函数捕获。</p>
<p>Promise是异步编程的解决方案，是一个容器，里面保存着未来才会结束的事件的结果。</p>
<p>Promise的俩个特点：</p>
<ul>
<li>对象的状态不受外界影响</li>
<li>一旦状态改变，就不会再变</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result)).catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure>

<p>上面代码中， <code>p1</code> 是一个Promise，3秒之后变为 rejected 。 <code>p2</code> 的状态在1秒之后改变， resolve 方法返回的是 <code>p1</code> 。此时，由于 <code>p2</code> 返回的是另一个Promise，所以后面的 then 语句都变成针对后者（ <code>p1</code> ）。又过了2秒， <code>p1</code> 变为 rejected ，导致触发 catch 方法指定的回调函数。</p>
<h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise实例具有 then 方法，也就是说， then 方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过， then 方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。then 方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p>Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"fulfilled:"</span>, val))</span><br><span class="line">	.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(fulfilled:<span class="string">", val))</span></span><br><span class="line"><span class="string">	.then(null, (err) =&gt; console.log("</span>rejected:<span class="string">", err));</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// success</span></span><br><span class="line">	&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// error</span></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">		<span class="comment">// success</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// error</span></span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<p>第二种写法要好于第一种写法，理由是第二种写法可以捕获前面 then 方法执行中的错误，也更接近同步的写法（ try/catch ）。因此，建议总是使用 catch 方法，而不使用 then 方法的第二个参数。跟传统的 try/catch 代码块不同的是，如果没有使用 catch 方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all 方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<p><code>let p = Promise.all([p1, p2, p3]);</code></p>
<p>上面代码中， Promise.all 方法接受一个数组作为参数， p1 、 p2 、 p3 都是Promise对象的实例，如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转为Promise实例，再进一步处理。Promise.all 方法的参数可以不是数组，但必须具有<code>Iterator</code>接口，且返回的每个成员都是Promise实例。</p>
<p>p 的状态由 p1 、 p2 、 p3 决定，分成两种情况。</p>
<p>（1）只有 p1 、 p2 、 p3 的状态都变成 fulfilled ， p 的状态才会变成 fulfilled ，此时 p1 、 p2 、 p3 的返回值组成一个数组，传递给 p 的回调函数。</p>
<p>（2）只要 p1 、 p2 、 p3 之中有一个被 rejected ， p 的状态就变成 rejected ，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>Promise.race 方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<p><code>let p = Promise.race([p1,p2,p3]);</code></p>
<p>上面代码中，只要 p1 、 p2 、 p3 之中有一个实例率先改变状态， p 的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给 p 的回调函数。</p>
<p>Promise.race 方法的参数与 Promise.all 方法一样，如果不是Promise实例，就会先调用下面讲到的 Promise.resolve 方法，将参数转为Promise实例，再进一步处理。</p>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>参数分成四种情况：</p>
<ol>
<li><p>参数是一个Promise实例</p>
<p> 如果参数是Promise实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例。</p>
</li>
<li><p>参数是一个thenable对象</p>
<p> thenable 对象指的是具有 then 方法的对象，比如下面这个对象。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">	then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">		resolve(<span class="number">42</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> Promise.resolve 方法会将这个对象转为Promise对象，然后就立即执行 thenable 对象的 then 方法。</p>
</li>
<li><p>参数不是具有 then 方法的对象，或根本就不是对象</p>
<p> 如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的Promise对象，状态为 Resolved。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不带有任何参数</p>
<p> Promise.resolve 方法允许调用时不带参数，直接返回一个 Resolved 状态的Promise对象。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用 Promise.resolve 方法。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure>

<p> 需要注意的是，<code>立即 resolve 的Promise对象，是在本轮“事件循环”（eventloop）的结束时，而不是在下一轮“事件循环”的开始时</code>。</p>
<p> 上面代码中， setTimeout(fn, 0) 在下一轮“事件循环”开始时执行， Promise.resolve() 在本轮“事件循环”结束时执行， console.log(‘one’) 则是立即执行，因此最先输出。</p>
</li>
</ol>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>Promise.reject(reason) 方法也会返回一个新的Promise实例，该实例的状态为 rejected 。它的参数用法与 Promise.resolve 方法完全一致。</p>
<h2 id="俩个有用的附加方法"><a href="#俩个有用的附加方法" class="headerlink" title="俩个有用的附加方法"></a>俩个有用的附加方法</h2><h3 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h3><p>Promise对象的回调链，不管以 then 方法或 catch 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个 done 方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//抛出一个全局错误</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面代码可见， done 方法的使用，可以像 then 方法那样用，提供 Fulfilled 和 Rejected 状态的回调函数，也可以不提供任何参数。但不管怎样， done 都会捕捉到任何可能出现的错误，并向全局抛出。</p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><p>finally 方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与 done 方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">        value =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">        reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="异步操作和Async"><a href="#异步操作和Async" class="headerlink" title="异步操作和Async"></a>异步操作和Async</h1><p>身为大自然的前端搬运工，为了能更好的搬运代码，咱们应该去理解前端中比较重要的异步调用部分。在说异步之前，我想先介绍generator函数，promise对象和async函数。</p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>generator函数是一种异步编程的解决方案，语法会与传统函数有所不同。</p>
<p>在《ES6标准入门》中是这么介绍generator函数函数的，从语法上，首先可以把它理解成一个状态机，封装了多个内部状态。执行generator函数会返回一个遍历器对象，所以generator函数还是一个遍历器对象生成函数，可以通过它依次遍历generator函数内部的每一个状态。</p>
<p>形式上，generator函数有两个特征：</p>
<ol>
<li>function命令与函数名之间有一个星号。</li>
<li>函数体内部使用yield语句定义不同内部状态。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hw = helloGenerator(); <span class="comment">//执行该函数</span></span><br><span class="line">hw.next() 				 <span class="comment">//&#123;value: 'hello', done: false&#125;</span></span><br><span class="line">hw.next() 				 <span class="comment">//&#123;value: 'world', done: false&#125;</span></span><br><span class="line">hw.next() 				 <span class="comment">//&#123;value: 'ending', done: true&#125;</span></span><br><span class="line">hw.next() 				 <span class="comment">//&#123;value: 'undefine', done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面的函数就是一个例子helloGenerator函数内定义了3个状态：hello、world、return语句</p>
<p>generator函数的调用方法与普通函数类似，但是调用generator函数之后，只是返回一个指向内部状态的指针，通过每次调用next方法没事的指针向下一个状态移动，函数会执行一直到下个yield语句（或return语句）为止。就是说generator函数函数是分段执行的，yield语句是暂停执行标记，而next方法会恢复执行。而每次调用next都会返回yield后的语句的内容，若是函数会先执行（这就与异步相似），然后再返回函数执行的返回结果。</p>
<p>接下来说下next的运行逻辑：</p>
<ol>
<li>遇到yield语句就暂停执行后面的操作，并紧跟在yield后面的表达式的值作为返回的对象的value属性值</li>
<li>下一次调用next方法时再继续往下执行，知道遇到下一条yield</li>
<li>如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式值作为返回的对象的value属性值</li>
<li>如果没有return语句，也会执行但是返回的value里面是undefined</li>
</ol>
<p>需要注意的是只有当我们调用next才会执行后续语句，所以很大程度上来说，generator函数的后续操作，都需要人为手动的控制，但是我们会在后续的讨论中说道co模块和thunk函数，关于自启动的说明。</p>
<p>但是我们通过向next传递一个参数这样子它会被当做上一条yield语句的返回值。我们要注意不能在普通函数中使用yield语句，不然会报错。而且yield语句如果用在一个表达式中，必须放在圆括号里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'result:'</span> + result);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      i = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = f();</span><br><span class="line">g.next()  <span class="comment">// &#123;value: 0, done: false&#125; </span></span><br><span class="line"><span class="comment">// result:undefined</span></span><br><span class="line"></span><br><span class="line">g.next()  <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="comment">// result:undefined</span></span><br><span class="line"></span><br><span class="line">g.next(<span class="literal">true</span>)  <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line"><span class="comment">// result:true</span></span><br></pre></td></tr></table></figure>



<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>关于promise对象，一开始的时候，我写下的几个函数，大家可以理解一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例一</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例二</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">21</span>; <span class="comment">//21 resolve出去到下一个then</span></span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//in 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例三</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//in success</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例四</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//in error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例五</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success2'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//in error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例六</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success2'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error2'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//in error2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例七</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success1'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success2'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error2'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//in</span></span><br><span class="line"><span class="comment">//error1</span></span><br><span class="line"><span class="comment">//success2</span></span><br></pre></td></tr></table></figure>

<p>在上述中一共有七个实例，第一个和第二个很类似，但是第一个会在实例浏览器中报错，而第二个不会，因为catch会捕获报错。虽然在promise对象中我们可以通过操作去决定我们到底执行resolved状态还是rejected状态，但是这是相对的，<code>使用then的第二个参数和使用catch是一样，都会被当做rejected状态</code>，所以为了代码的健壮性，我更加建议使用catch。</p>
<p>但是看到第七个实例它的输出，你会发现，好像和预想的不一样，所以这就是要注意的地方，then和catch返回的都是promise对象，所以可以在后续中执行resolved状态。在异步操作中一定要记住这一点。</p>
<p>promise对象的错误是有冒泡性质的，会一直向后传递，直到被捕获为止，也就是说，<code>错误总是会被下一个catch语句或者then的第二个参数捕获</code>。这也就解释实例七的结果。在promise对象抛出的错误会一直冒泡到最外层，如果没有捕获，但是在谷歌浏览器中会抛出到最外层，只是不会影响后续操作。</p>
<p>我们需要理解当调用 Promise 的 then(..) 会自动创建一个新的 Promise 从调用返回，而其中的promise是怎么产生的。</p>
<p>promise.resolve()会返回一个新的promise对象，且其状态为resolved。</p>
<p>当调用promise.resolve的时候会对对第一个参数转换为一个promise，当参数不是promise的值时，会将其展开提取一个非类promise的最终值。与then类似，如果调用的是then通过return返回一个值，那么该值也会类似将其展开转换为promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例八</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'1'</span>).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例九</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'3'</span>).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>要记住async函数是generator函数的语法糖。</p>
<ol>
<li>具有内置执行器。</li>
<li>能自动执行，输出最后结果。</li>
<li>更好的语法。</li>
<li>更广的适用性。</li>
<li>返回值为Promise</li>
</ol>
<p>这时候我给出一个实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> f1();</span><br><span class="line">    <span class="keyword">await</span> f2();</span><br><span class="line">    <span class="keyword">await</span> f3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = fn();</span><br><span class="line"><span class="built_in">console</span>.log(g);</span><br></pre></td></tr></table></figure>

<p>这个实例的执行结果是怎么样的，可以吧它复制到控制面板中执行，你会发现输出的顺序是1，promise对象，2，3。这是为什么，为什么1之后是promise，展开promise对象，会发现里面的promiseValue值是1，那这个值是不是和yield一样返回的是后面表达式的值呢，然后选择吧await f1();注释掉，重新执行就发现其实promise的promiseValue值没有改变，所以这不是和yield一样但是不可否认的是会返回一个Promise值。</p>
<p>但是为什么是promise对象之后才是2，3呢，不是先1,2,3才promise对象，因为async就是一个异步函数，我们可以这么理解，当我们fn()的时候，会执行到第一个await后面的语句，然后停止执行，也就是输出了1，然后发现函数外还有代码需要执行，就会暂停，执行函数外的后续代码，等到系统空闲，就会继续执行函数内后续的代码。</p>
<p>所以结果就是1，promise对象，2，3。</p>
<h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><p>其实“异步”在我看来就是一部分先执行，一部分后执行。而在js中最简单的异步就是ajax中的回调函数，回调函数就是把任务的第二个阶段单独写在一个函数中，当做参数传递进去也就是callback参数。而异步的核心就是现在运行的代码和未来运行的关系。程序中将来执行的部分并不一定在现在运行的部分执行完之后就立即执行。无法完成的任务就会异步完成。比如在一开始的页面请求中，为避免页面的卡死，会将向后台请求的代码进行异步处理，一般利用ajax就是回调。而真正的异步代码，直到es6才开始内建起来（Promise对象）。</p>
<p>JS的引擎并不是独立运行的，它运行在宿主换将中（一般指浏览器）。这些环境都有一个共同点，它们都提供了一种机制来处理程序中多个快的执行，且执行每块时调用JS引擎，这种机制就是事件循环。</p>
<p>可以参考这个图：</p>
<p><img src="/2020/01/30/ES6%E6%80%BB%E7%BB%93/1.png" alt></p>
<p>并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行：在不同 的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。但是事件循环吧自身的工作分成一个个任务，内存不会共享。但是通过分立线程中彼此合作的事件循环，可以共享。</p>
<p>一个任务可能引起更多任务被添加到同一个队列末尾。所以，理论上说，任务循环（job loop）可能无限循环（一个任务总是添加另一个任务，以此类推），进而导致程序的 饿死，无法转移到下一个事件循环tick。一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互、IO 和定时器会向事件队列中加入事件。任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一 个或多个后续事件。</p>
<p>但是JS是单线程运行特性。不会进行并行执行除非使用web worker。单线程事件循环是并发的一种形式。</p>
<h2 id="异步总结"><a href="#异步总结" class="headerlink" title="异步总结"></a>异步总结</h2><p>js的异步其实是为了解决浏览器单线程问题，而提出的，如果没有异步，那么浏览器在发送请求的时候就会一直卡死在等待服务器response，从而造成资源利用地下的问题。而异步就是为了解决这个问题，而最早应用的异步应该就是ajax里面的回调函数了，但是回调函数依然有问题，那就是如果需要多次应用callback就要在里面一层层的添加回调函数从而而造成回调地狱，又或者是如果在多个ajax执行完成时才能执行下一步，那可能就需要添加许多额外的变量或者判断。而到了es6异步才算是真正的诞生，其实际应该是generate函数、promise函数的应用以及asyn和await的应用了。</p>
<p>对于generate函数其实就是一个函数内，利用yield定义一连串的状态机，然后手动的去执行，也就是用next执行下一个步骤，而next可以传参进去替代原本的yeild的位置。</p>
<p>promise函数可以说是现在应用的最多的一个函数了，我们在平时的开发请求中，也基本会用到它，首先我们知道的是promise其实有3个状态pending、fullified、reject，3种状态，而3种状态的转换是不可逆的，promise的首个状态一般是pending也就是在new Promise的时候传递进去的函数参数所在的状态就是pending，要知道的一个点是从pending到fullified状态其实是需要调用resolve参数的，而如果从pending到reject状态到达的路径有两条，函数内有语法或者数据导致报错，另一条就是手动调用reject，但是我们有一点需要注意的，对于promise的报错是逐渐冒泡的，比如我在promise函数内报错，那这个错误就会一直向下冒泡，经历所有的then直到后续有than的第二个参数或者catch对其进行捕获，如果没有，就会一直抛到最外层形成错误，但是这个错误并不会影响或者停止浏览器执行除这个promise之外的其他代码，其实then和catch都会返回一个promise函数让后续继续执行，而参数就是return的内容。所以我们最好的方式就是我们可以在末尾添加一个catch保证错误是能被我们捕获的，然后再添加一个done告诉别人该函数已经执行完毕，我们知道的一个点就是。其实promise在执行完之后会一直保持现有状态，除非后续有调用，否则只有在关掉页面时才会消除。</p>
<p>而async和await其实可以理解为进阶版的generate，async和await会自动执行，其实就是每一次都会把剩余部分都放到微任务队中等待下次的执行，并且会返回await后的内容。</p>
<p>所以其实promise与async其实都会把后续部分放入到微任务中，而原本的callback其实就是一个宏任务的简易调用。</p>
<h2 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h2><p>问题的引入：函数的参数到底应该何时求值？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(x + <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算 x + 5 的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传值调用时，等同于</span></span><br><span class="line">f(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种意见是”传名调用”（call by name），即直接将表达式 x + 5 传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传名调用时，等同于</span></span><br><span class="line">(x + <span class="number">5</span>) * <span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">3</span> * x * x - <span class="number">2</span> * x - <span class="number">1</span>, x);</span><br></pre></td></tr></table></figure>

<p>f函数的第一参数是很复杂的表达式，但是函数体内根本没用到。对这个参数求值其实是没必要的。所以我们更倾向于<strong>传名调用</strong>这种高效率的参数求值方式。</p>
<p>编译器的传名调用实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就叫做<code>Thunk函数</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(x + <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">thunk</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> thunk() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript语言的Thunk函数"><a href="#JavaScript语言的Thunk函数" class="headerlink" title="JavaScript语言的Thunk函数"></a>JavaScript语言的Thunk函数</h3><p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123; <span class="comment">//一个thunk函数转换器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, cb</span>) </span>&#123;</span><br><span class="line">    cb(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ft = Thunk(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</span><br><span class="line">ft(<span class="number">1</span>)(log) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="async函数-1"><a href="#async函数-1" class="headerlink" title="async函数"></a>async函数</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol>
<li><p>async 函数返回一个Promise对象。</p>
<p> async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>

<p> async内部抛出错误，会导致返回的Promise对象变为reject对象，抛出的错误对象会被catch方法回调函数接收到。</p>
</li>
<li><p>async 函数返回的Promise对象，必须等到内部所有 await 命令的Promise对象执行完，才会发生状态改变。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">	<span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">	<span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正常情况下， await 命令后面是一个Promise对象。如果不是，会被转成一个立即 resolve 的Promise对象。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p> 只要一个 await 语句后面的Promise变为 reject ，那么整个 async 函数都会中断执行。为了避免这个问题，可以将<code>第一个 await 放在 try...catch 结构里面</code>，这样第二个 await 就会执行。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<p> 另一种方法是 <code>await 后面的Promise对象再跟一个 catch</code> 方面，处理前面可能出现的错误。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">		.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 await 后面的异步操作出错，那么等同于 async 函数返回的Promise对象被 reject 。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure>

<p> 上面代码中， async 函数 f 执行后， await 后面的Promise对象会抛出一个错误对象，导致 catch 方法的回调函数被调用，它的参数就是抛出的错误对象。</p>
</li>
</ol>
<p><code>多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br></pre></td></tr></table></figure>

<p>上面代码中， getFoo 和 getBar 是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有 getFoo 完成以后，才会执行 getBar ，完全可以让它们同时触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>



<p><code>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</code></p>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p><strong>不同点</strong>：</p>
<ul>
<li><p>Class的内部定义的方法，都是不可枚举的(non-enumerable)，这一点和ES5中不一样。</p>
</li>
<li><p>ES6定义对象时，可以用表达式作为属性名 如[‘a’+’bc’]。</p>
</li>
<li><p>类的构造函数，不使用new无法调用，会报错。跟普通构造函数不一样，后者不用new也可以执行。</p>
</li>
<li><p>Class不存在变量提升(hoist)，这一点与ES5完全不同。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">//ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这种规定的原因主要是与继承有关：必须保证子类在父类之后定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> Foo = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上：如果<code>class此时变量提升</code>，但是由于<code>let</code>是不会提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</p>
</blockquote>
</li>
</ul>
<p>通过new生成对象实例时，自动调用constructor方法，constructor方法默认返回实例对象this，也可以指定返回另外一个对象，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<p>不推荐通过实例的<strong>proto</strong>属性为Class添加方法，因为修改的话，会影响所有实例。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">p1.__proto__.printName=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'Oops'</span>&#125;;</span><br><span class="line">p1.printName(); <span class="comment">//Oops</span></span><br><span class="line">p2.printName(); <span class="comment">//Oops</span></span><br></pre></td></tr></table></figure>





<h2 id="class表达式"><a href="#class表达式" class="headerlink" title="class表达式"></a>class表达式</h2><p>与函数一样，Class也可以使用表达式的形式定义。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">    getClassName() &#123;</span><br><span class="line">        <span class="keyword">return</span> Me.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>MyClass才是<code>类名</code>，Me只在Class的内部代码可用，指代当前类，也可以省略。</p>
</blockquote>
<p>可以是立即执行的Class</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">'zj'</span>);</span><br><span class="line">person.sayName(); <span class="comment">//zj</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h2><ol>
<li>方法前面加<code>_</code>，_privateFunc() {}; 这种方法在类的外部还是可以调用，不安全。</li>
<li>将私有方法模块移出模块。</li>
<li>Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</li>
</ol>
<h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line">Point.name <span class="comment">//"Point"</span></span><br></pre></td></tr></table></figure>

<p>name属性总是返回紧跟在<code>class</code>关键字后面的类名。</p>
<h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例会出错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。</p>
<p>子类的构造函数中，只有调用super之后，才可以使用<code>this</code>关键字。</p>
<p>俩条继承链：</p>
<ol>
<li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类</li>
<li>子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>JS部分API实现</title>
    <url>/2020/01/23/JS%E9%83%A8%E5%88%86API%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1-call、apply和bind"><a href="#1-call、apply和bind" class="headerlink" title="1.call、apply和bind"></a>1.call、apply和bind</h1><a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>apply、call、bind的作用都是改变运行时上下文的（即函数中的this对象），区别是apply和call是立即执行，而bind的作用是改变运行上下文后返回新的函数，用于以后执行的函数。</p>
<p>apply和call的区别在于使用方式不同，apply中传递的参数是一个数组，而call则是传递了一系列参数</p>
</blockquote>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><blockquote>
<p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>注意两点：</p>
<ol>
<li>call 改变了 this 的指向，指向到 foo</li>
<li>bar 函数执行了</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">    context.fn = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> args = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length;i &lt; len;i++) &#123;</span><br><span class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        value: <span class="keyword">this</span>.value,</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call2(<span class="literal">null</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.call2(obj, <span class="string">'kevin'</span>, <span class="number">18</span>));</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//    value: 1,</span></span><br><span class="line"><span class="comment">//    name: 'kevin',</span></span><br><span class="line"><span class="comment">//    age: 18</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>eval函数接收参数是个字符串</strong></p>
<p>定义和用法</p>
<blockquote>
<p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p>
</blockquote>
<p>语法：<br><code>eval(string)</code></p>
<blockquote>
<p>string必需。要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句。该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。因此请不要为 eval() 函数传递 String 对象来作为参数。</p>
</blockquote>
<p>简单来说吧，就是用JavaScript的解析引擎来解析这一堆字符串里面的内容，这么说吧，你可以这么理解，你把<code>eval</code>看成是<code>&lt;script&gt;</code>标签。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'function Test(a,b,c,d)&#123;console.log(a,b,c,d)&#125;;Test(1,2,3,4)'</span>)</span><br></pre></td></tr></table></figure>

<p>==难点解析:==</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的数组为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [<span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>], ...]</span><br></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br></pre></td></tr></table></figure>

<p>在eval中，args 自动调用 args.toString()方法，eval的效果如 jawil所说，最终的效果相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = context.fn(<span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>], ...);</span><br></pre></td></tr></table></figure>

<p>这样就做到了把传给call的参数传递给了context.fn函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//call ES6版本</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.callEs6 = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">//挂载到context下的fn中</span></span><br><span class="line">    <span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.callSym = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn] = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="built_in">Reflect</span>.deleteProperty(context, fn);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><ul>
<li>首先要先原型上即 Function.prototype上编程</li>
<li>需要拿到函数的引用， 在这里是 this</li>
<li>让传入对象.fn = this</li>
<li>执行传入对象.fn(传入参数)</li>
<li>返回执行结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apply</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    context.fn = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">        result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==call和apply的区别仅仅是:==</p>
<p>call是通过传多个参数的方式，而apply则是传入一个数组。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><blockquote>
<p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p>
</blockquote>
<ul>
<li>因为bind的使用方法是 某函数.bind(某对象，…剩余参数)<ul>
<li>所以需要在Function.prototype 上进行编程</li>
</ul>
</li>
<li>将传递的参数中的某对象和剩余参数使用apply的方式在一个回调函数中执行即可</li>
<li>要在第一层获取到被绑定函数的this，因为要拿到那个函数用apply</li>
</ul>
<p>简单版</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function">(<span class="params">context, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> funcThis = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...bindArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> funcThis.apply(context, args.concat(bindArgs));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶版</p>
<blockquote>
<p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.habit = <span class="string">'shopping'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.prototype.friend = <span class="string">'kevin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> bindFoo(<span class="string">'18'</span>);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// daisy</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.habit);</span><br><span class="line"><span class="built_in">console</span>.log(obj.friend);</span><br><span class="line"><span class="comment">// shopping</span></span><br><span class="line"><span class="comment">// kevin</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bindEs6 = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'invalid invoked!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> self(...rest, ...args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, rest.concat(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//获取bind2函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//转换类数组元素 arguments 为数组元素，方便使用数组方法，比如后面的 array.concat()</span></span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span></span><br><span class="line">        <span class="comment">// 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性</span></span><br><span class="line">        <span class="comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-new"><a href="#2-new" class="headerlink" title="2.new"></a>2.new</h1><h2 id="new的模拟实现"><a href="#new的模拟实现" class="headerlink" title="new的模拟实现"></a>new的模拟实现</h2><blockquote>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = F.prototype;</span><br><span class="line">F.call(obj);</span><br></pre></td></tr></table></figure>

<p>new运算符具体干了三件事:</p>
<ol>
<li>创建一个空对象obj</li>
<li>将这个空对象的<strong>proto</strong>成员指向了F函数对象prototype成员对象</li>
<li>将F函数对象的this指针替换成obj，然后再调用F函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> Constructor = args.shift();</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(Constructor.prototype);</span><br><span class="line">  <span class="keyword">let</span> temp = Constructor.apply(instance, args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> temp === <span class="string">'object'</span> &amp;&amp; temp !== <span class="literal">null</span>) ? temp : instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),<span class="comment">//从Object.prototype上克隆一个对象</span></span><br><span class="line"></span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);<span class="comment">//取得外部传入的构造器</span></span><br><span class="line"></span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//改变构造函数 this 的指向到新建的对象，这样obj就可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="comment">//obj代替Constructor中this对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;<span class="comment">//确保构造器总是返回一个对象</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.habit = <span class="string">'Games'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.strength = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = objectFactory(Otaku, <span class="string">'Kevin'</span>, <span class="string">'18'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength) <span class="comment">// 60</span></span><br><span class="line"></span><br><span class="line">person.sayYourName(); <span class="comment">// I am Kevin</span></span><br></pre></td></tr></table></figure>



<h2 id="Object-create-和-new-Object-的区别"><a href="#Object-create-和-new-Object-的区别" class="headerlink" title="Object.create() 和 new Object()的区别"></a>Object.create() 和 new Object()的区别</h2><p><img src="/2020/01/23/JS%E9%83%A8%E5%88%86API%E5%AE%9E%E7%8E%B0/1.png" alt></p>
<p>使用<code>create</code>创建的对象，没有任何属性，显示<code>No properties</code>，我们可以把它当作一个非常<strong>纯净</strong>的map来使用，我们可以自己定义<code>hasOwnProperty</code>、<code>toString</code>方法，不管是有意还是不小心，我们完全不必担心会将原型链上的同名方法覆盖掉。</p>
<h3 id="new-Object-创建的对象纯净么？"><a href="#new-Object-创建的对象纯净么？" class="headerlink" title="new Object()创建的对象纯净么？"></a>new Object()创建的对象纯净么？</h3><p>首先什么是纯净？我们定义一个对象的<code>__proto__</code>属性为空的对象是一个纯净的对象。</p>
<p>在第二步的时候中已经改变的obj的原型链，所以无论它前面的原型链是咋样的都无所谓，但是为了保证对象的纯净性，我们有必要引出<code>Object.create()</code>，该方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p>
<h2 id="Object-create实现"><a href="#Object-create实现" class="headerlink" title="Object.create实现"></a>Object.create实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params"> o </span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    f.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-类数组对象"><a href="#3-类数组对象" class="headerlink" title="3.类数组对象"></a>3.类数组对象</h1><h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><p>类数组对象:</p>
<blockquote>
<p>拥有一个 length 属性和若干索引属性的对象</p>
</blockquote>
<p>从读写、获取长度和遍历来看无差别,但不能用数组的方法,所以叫类数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">'name'</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">'age'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'sex'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用数组的方法"><a href="#调用数组的方法" class="headerlink" title="调用数组的方法"></a>调用数组的方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.join.call(arrayLike, <span class="string">'&amp;'</span>); <span class="comment">// name&amp;age&amp;sex</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike, <span class="number">0</span>); <span class="comment">// ["name", "age", "sex"] </span></span><br><span class="line"><span class="comment">// slice可以做到类数组转数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.map.call(arrayLike, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item.toUpperCase();</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// ["NAME", "AGE", "SEX"]</span></span><br></pre></td></tr></table></figure>

<p>把原型指向Array.prototype后就可以调用Array.prototype上的方法，行为上确实是跟数组一样，然而Array.isArray和Object.prototype.toString不认</p>
<p><img src="/2020/01/23/JS%E9%83%A8%E5%88%86API%E5%AE%9E%E7%8E%B0/2.png" alt></p>
<h3 id="类数组转数组"><a href="#类数组转数组" class="headerlink" title="类数组转数组"></a>类数组转数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;<span class="number">0</span>: <span class="string">'name'</span>, <span class="number">1</span>: <span class="string">'age'</span>, <span class="number">2</span>: <span class="string">'sex'</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="comment">// 1. slice</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike); <span class="comment">// ["name", "age", "sex"] </span></span><br><span class="line"><span class="comment">// 2. splice</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>); <span class="comment">// ["name", "age", "sex"] </span></span><br><span class="line"><span class="comment">// 3. ES6 Array.from</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ["name", "age", "sex"] </span></span><br><span class="line"><span class="comment">// 4. apply</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike)</span><br></pre></td></tr></table></figure>

<p>slice和splice的区别:</p>
<ol>
<li><p>slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素</p>
</li>
<li><p>splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目。（==该方法会改变原数组==）</p>
<p> splice（index,howmany,item1,…itemX）</p>
</li>
</ol>
<p>那么为什么会讲到类数组对象呢？以及类数组有什么应用吗？</p>
<p>要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端JavaScript中一些DOM方法(document.getElementsByTagName()等)也返回==类数组对象==。</p>
<blockquote>
<p>对于 HTMLCollection，length 属性为只读，splice 底层还是会修改 length 的长度，这才导致了报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  elements = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'box'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.splice.call(elements, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot assign to read only property 'length' of object '#&lt;HTMLCollection&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice方法可以</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Arguments对象"><a href="#Arguments对象" class="headerlink" title="Arguments对象"></a>Arguments对象</h2><p>Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>)</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<p><img src="/Users/dannysoul/Desktop/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9/JS%E5%9F%BA%E7%A1%80/assets/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-09-22%20%E4%B8%8B%E5%8D%886.20.47.png" alt="屏幕快照 2019-09-22 下午6.20.47"></p>
<h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h3><p>Arguments对象的length属性，表示实参的长度，举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b, c, d</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"实参的长度为："</span> + <span class="built_in">arguments</span>.length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"形参的长度为："</span> + foo.length)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参的长度为：3</span></span><br><span class="line"><span class="comment">// 实参的长度为：1</span></span><br></pre></td></tr></table></figure>

<h3 id="callee属性"><a href="#callee属性" class="headerlink" title="callee属性"></a>callee属性</h3><p>Arguments 对象的 callee 属性，通过它可以调用函数自身。</p>
<p>讲个闭包经典面试题使用 callee 的解决方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.i) </span><br><span class="line">    &#125;).i = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>函数也是一种对象，我们可以通过这种方式给函数添加一个自定义的属性。<br>这个解决方式就是给 data[i] 这个函数添加一个自定义属性，这个属性值就是正确的 i 值。</p>
<p>接下来讲讲 arguments 对象的几个注意要点：</p>
<h3 id="arguments-和对应参数的绑定"><a href="#arguments-和对应参数的绑定" class="headerlink" title="arguments 和对应参数的绑定"></a>arguments 和对应参数的绑定</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, age, sex, hobbit</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(name, <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// name name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变形参</span></span><br><span class="line">    name = <span class="string">'new name'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(name, <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// new name new name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变arguments</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="string">'new age'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(age, <span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">// new age new age</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试未传入的是否会绑定</span></span><br><span class="line">    <span class="built_in">console</span>.log(sex); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">    sex = <span class="string">'new sex'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(sex, <span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// new sex undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">3</span>] = <span class="string">'new hobbit'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(hobbit, <span class="built_in">arguments</span>[<span class="number">3</span>]); <span class="comment">// undefined new hobbit</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'name'</span>, <span class="string">'age'</span>)</span><br></pre></td></tr></table></figure>

<p>传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享</p>
<p>除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>将参数从一个函数传递到另一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 apply 将 foo 的参数传递给 bar</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="强大的ES6"><a href="#强大的ES6" class="headerlink" title="强大的ES6"></a>强大的ES6</h3><p>使用ES6的 … 运算符，我们可以轻松转成数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">...arguments</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>



<h1 id="4-数组去重"><a href="#4-数组去重" class="headerlink" title="4.数组去重"></a>4.数组去重</h1><h2 id="双层循环"><a href="#双层循环" class="headerlink" title="双层循环"></a>双层循环</h2><p>缺点：</p>
<p><code>对象和NaN不会去重</code></p>
<blockquote>
<p>NaN===NaN //false</p>
<p>{}==={} //false</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双层循环</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'str'</span>, <span class="string">'str'</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; res.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] === res[j]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j === res.length) res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array)); <span class="comment">// [ 1, '1', 'str', &#123; a: 1 &#125;, &#123; a: 1 &#125;, NaN, NaN ]</span></span><br></pre></td></tr></table></figure>

<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>indexOf简化内层循环</p>
<p>缺点和上述方法一样，因为<code>indexOf</code>底层还是用的<code>===</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'str'</span>, <span class="string">'str'</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">            res.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array)); <span class="comment">// [ 1, '1', 'str', &#123; a: 1 &#125;, &#123; a: 1 &#125;, NaN, NaN ]</span></span><br></pre></td></tr></table></figure>

<h2 id="排序后去重"><a href="#排序后去重" class="headerlink" title="排序后去重"></a>排序后去重</h2><p>先将要去重的数组使用 sort 方法排序后，相同的值就会被排在一起，然后我们就可以只判断当前元素与上一个元素是否相同，相同就说明重复，不相同就添加进 res。</p>
<p>缺点：</p>
<p><code>除了对象NaN不去重，数字1也不去重</code></p>
<blockquote>
<p>[ 1, ‘1’, ‘1’, 1, NaN, NaN, { a: 1 }, { a: 1 }, ‘str’, ‘str’ ]</p>
<p>可以看到sort排序会出现上述的情况，所以1无法去重。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="string">'str'</span>, <span class="string">'str'</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [],</span><br><span class="line">        sortedArr = arr.concat().sort(),</span><br><span class="line">        <span class="comment">//你对数组进行了 array.concat()操作之后，相当于复制出来一份原有的数组，</span></span><br><span class="line">        <span class="comment">//且对复制出来的新数组的操作不会影响到原有数组</span></span><br><span class="line">        seen;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = sortedArr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || seen !== sortedArr[i]) res.push(sortedArr[i]);</span><br><span class="line">        seen = sortedArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array)); <span class="comment">// [ 1, '1', 1, NaN, NaN, &#123; a: 1 &#125;, &#123; a: 1 &#125;, 'str' ]</span></span><br></pre></td></tr></table></figure>



<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>ES5 提供了 filter 方法，我们可以用来简化外层循环：</p>
<p>比如使用 indexOf 的方法：</p>
<p><code>filter+indexOf</code>缺点：</p>
<p>对象无法去重，NaN会被忽略掉</p>
<blockquote>
<p>indexOf 底层还是使用 <code>===</code> 进行判断，因为 NaN === NaN的结果为 false，所以使用 indexOf 查找不到 NaN 元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="string">'str'</span>, <span class="string">'str'</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array)); <span class="comment">// [ 1, '1', 'str', &#123; a: 1 &#125;, &#123; a: 1 &#125; ]</span></span><br></pre></td></tr></table></figure>

<p>排序去重的方法：</p>
<p><code>filter+sort</code>缺点：</p>
<p>对象NaN无法去重，数字1不去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="string">'str'</span>, <span class="string">'str'</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.concat().sort().filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !index || item !== array[index - <span class="number">1</span>];</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array)); <span class="comment">// [ 1, '1', 1, NaN, NaN, &#123; a: 1 &#125;, &#123; a: 1 &#125;, 'str' ]</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-键值对"><a href="#Object-键值对" class="headerlink" title="Object 键值对"></a>Object 键值对</h2><p>这种方法是利用一个空的 Object 对象，我们把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。因为 1 和 ‘1’ 是不同的，但是这种方法会判断为同一个值，这是因为<code>对象的键值只能是字符串</code>，所以我们可以使用 <code>typeof item + item</code> 拼成字符串作为 key 值来避免这个问题：然而，即便如此，我们依然无法正确区分出两个对象，比如 {value: 1} 和 {value: 2}，因为 <code>typeof item + item</code> 的结果都会是 <code>object[object Object]</code>，不过我们可以使用JSON.stringify将对象序列化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>), /a/, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>), / a /, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)) ? <span class="literal">false</span> : obj[<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)] = <span class="literal">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array)); <span class="comment">//[ 1, '1', null, undefined, [String: '1'], /a/, NaN ]</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>对象不去重，NaN去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>), /a/, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>), / a /, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));<span class="comment">//Array.from将可迭代对象转换成数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array));</span><br><span class="line"><span class="comment">//[1, '1', null, undefined, [String: '1'], /a/, [String: '1'], / a /, NaN]</span></span><br></pre></td></tr></table></figure>

<p>简化版:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unique = <span class="function">(<span class="params">arr</span>) =&gt;</span> [...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure>

<p>Map</p>
<p>对象不去重，NaN去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>), /a/, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>), / a /, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> !seen.has(item) &amp;&amp; seen.set(item, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array));</span><br><span class="line"><span class="comment">//[1, '1', null, undefined, [String: '1'], /a/, [String: '1'], / a /, NaN]</span></span><br></pre></td></tr></table></figure>

<h1 id="5-数组扁平化"><a href="#5-数组扁平化" class="headerlink" title="5.数组扁平化"></a>5.数组扁平化</h1><h2 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h2><blockquote>
<p>数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。</p>
</blockquote>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法 1</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            res.push(...flatten(arr[i]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]].toString() <span class="comment">// "1,2,3,4"</span></span><br></pre></td></tr></table></figure>

<p>调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString().split(<span class="string">','</span>).map(<span class="function">(<span class="params">item</span>) =&gt;</span> +item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<p>然而这种方法使用的场景却非常有限，如果数组是 [1, ‘1’, 2, ‘2’] 的话，这种方法就会产生错误的结果。</p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法3</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">cur, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cur.concat(<span class="built_in">Array</span>.isArray(next) ? flatten(next) : next);</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure>

<h2 id="ES6-1"><a href="#ES6-1" class="headerlink" title="ES6"></a>ES6</h2><p>ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="built_in">console</span>.log([].concat(...arr)); <span class="comment">// [1, 2, [3, 4]]</span></span><br></pre></td></tr></table></figure>

<p>我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法4</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure>



<h1 id="6-深拷贝、浅拷贝"><a href="#6-深拷贝、浅拷贝" class="headerlink" title="6.深拷贝、浅拷贝"></a>6.深拷贝、浅拷贝</h1><h2 id="基本类型值和引用类型值"><a href="#基本类型值和引用类型值" class="headerlink" title="基本类型值和引用类型值"></a>基本类型值和引用类型值</h2><ol>
<li><p><strong>基本类型值</strong>基本类型值指的是存储在栈中的一些简单的数据段</p>
<p> 在JavaScript中基本数据类型有String,Number,Undefined,Null,Boolean，在ES6中，又定义了一种新的基本数据类型Symbol,所以一共有6种。</p>
<p> 基本类型是按值访问的，从一个变量复制基本类型的值到另一个变量后这2个变量的值是完全独立的，即使一个变量改变了也不会影响到第二个变量。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = str1;</span><br><span class="line">str2 = <span class="string">'b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">//'b'</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//'a'</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>引用类型值</strong> 引用类型值是引用类型的实例，它是保存在堆内存中的一个对象，引用类型是一种数据结构，最常用的是Object,Array,Function类型，另外还有Date,RegExp,Error等，ES6同样也提供了Set,Map2种新的数据结构</li>
</ol>
<h2 id="数组的浅拷贝"><a href="#数组的浅拷贝" class="headerlink" title="数组的浅拷贝"></a>数组的浅拷贝</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><blockquote>
<p>语法：Object.assign(target, …sources)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123; a: &#123; b: 10 &#125; &#125;;</span></span><br><span class="line">source.a.b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">// &#123; a: &#123; b: 10 &#125; &#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123; a: &#123; b: 10 &#125; &#125;;</span></span><br></pre></td></tr></table></figure>

<p>Object.assign 只是在<strong>根属性</strong>(对象的第一层级)创建了一个新的对象，但是对于属性的值是对象的话只会拷贝一份相同的内存地址。</p>
<ul>
<li>不会拷贝对象继承的属性</li>
<li>不会拷贝不可枚举的属性</li>
<li>属性的数据属性/访问器属性</li>
<li>可以拷贝Symbol类型</li>
</ul>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;;</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.age)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="slice和concat"><a href="#slice和concat" class="headerlink" title="slice和concat"></a>slice和concat</h3><p>可以利用一些数组的方法实现浅拷贝,比如说slice、concat</p>
<p>如果数组嵌套了对象或者数组的话，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [&#123;<span class="attr">old</span>: <span class="string">'old'</span>&#125;, [<span class="string">'old'</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> new_arr = arr.concat();</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>].old = <span class="string">'new'</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">'new'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [&#123;old: 'new'&#125;, ['new']]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr) <span class="comment">// [&#123;old: 'new'&#125;, ['new']]</span></span><br></pre></td></tr></table></figure>

<p>我们会发现，无论是新数组还是旧数组都发生了变化，也就是说使用 concat 方法，克隆的并不彻底。</p>
<p>如果数组元素是<code>基本类型</code>，就会拷贝一份，互不影响，而如果是对象或者数组，就会<code>只拷贝对象和数组的引用</code>，这样我们无论在新旧数组进行了修改，两者都会发生变化。</p>
<p>我们把这种复制引用的拷贝方法称之为浅拷贝，与之对应的就是深拷贝，深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。</p>
<p>所以我们可以看出使用 <code>concat 和 slice 是一种浅拷贝</code>。</p>
<h2 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h2><p>那如何深拷贝一个数组呢？这里介绍一个技巧，不仅适用于数组还适用于对象！那就是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'old'</span>, <span class="number">1</span>, <span class="literal">true</span>, [<span class="string">'old1'</span>, <span class="string">'old2'</span>], &#123;<span class="attr">old</span>: <span class="number">1</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> new_arr = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringify(arr) );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(new_arr);</span><br></pre></td></tr></table></figure>

<p>缺点是==不能拷贝函数==</p>
<h3 id="JSON-parse-JSON-stringify-obj-实现深拷贝应该注意的坑"><a href="#JSON-parse-JSON-stringify-obj-实现深拷贝应该注意的坑" class="headerlink" title="JSON.parse(JSON.stringify(obj))实现深拷贝应该注意的坑"></a>JSON.parse(JSON.stringify(obj))实现深拷贝应该注意的坑</h3><blockquote>
<p>所有安全的JSON值（JSON-safe）都可以使用JSON.stringify(..)字符串化。安全的JSON值是指能够呈现为有效JSON格式的值。</p>
</blockquote>
<p>下面敲黑板划重点：</p>
<blockquote>
<p>为了简单起见，我们来看看什么是不安全的JSON值 。undefined 、function 、symbol （ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合JSON结构标准，支持JSON的语言无法处理它们。</p>
</blockquote>
<p>JSON.stringify(..) 在对象中遇到 undefined 、 function 和 symbol 时会自动将其忽略，在数组中则会返回null（以保证单元位置不变），对包含循环引用的对象执行JSON.stringify(..)会出错。</p>
<blockquote>
<p>利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象；序列化的作用是存储(对象本身存储的只是一个地址映射，如果断电，对象将不复存在，因此需将对象的内容转换成字符串的形式再保存在磁盘上 )和传输（例如 如果请求的<code>Content-Type</code>是 <code>application/x-www-form-urlencoded</code>，则前端这边需要使用<code>qs.stringify(data)</code>来序列化参数再传给后端，否则后端接受不到； ps: <code>Content-Type</code> 为 <code>application/json;charset=UTF-8</code>或者 <code>multipart/form-data</code> 则可以不需要 ）；我们在使用 <code>JSON.parse(JSON.stringify(xxx))</code>时应该注意一下几点：</p>
</blockquote>
<ol>
<li><p>如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象</p>
<p> <img src="/2020/01/23/JS%E9%83%A8%E5%88%86API%E5%AE%9E%E7%8E%B0/3.png" alt></p>
</li>
<li><p>如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象</p>
<p> <img src="/2020/01/23/JS%E9%83%A8%E5%88%86API%E5%AE%9E%E7%8E%B0/4.png" alt></p>
</li>
<li><p>如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失</p>
<p> <img src="/2020/01/23/JS%E9%83%A8%E5%88%86API%E5%AE%9E%E7%8E%B0/5.png" alt></p>
</li>
<li><p>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</p>
<p> <img src="/2020/01/23/JS%E9%83%A8%E5%88%86API%E5%AE%9E%E7%8E%B0/6.png" alt></p>
</li>
<li><p>JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor</p>
<p> <img src="/2020/01/23/JS%E9%83%A8%E5%88%86API%E5%AE%9E%E7%8E%B0/7.png" alt></p>
</li>
<li><p>如果对象中存在循环引用的情况也无法正确实现深拷贝</p>
</li>
</ol>
<h2 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h2><ol>
<li><p><strong>递归</strong></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> deepCopy = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1=&#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;,<span class="attr">c</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2=deepCopy(obj1);</span><br><span class="line">obj1.a.b=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">//&#123; a: &#123; b: 2 &#125;, c: 1 &#125;</span></span><br><span class="line"><span class="comment">//&#123; a: &#123; b: 1 &#125;, c: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p> 深拷贝因为递归的存在,性能会不如浅拷贝</p>
</li>
<li><p>BFS</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是对象/数组，返回一个空的对象/数组，</span></span><br><span class="line"><span class="comment">// 都不是的话直接返回原对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEmptyArrOrObj</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> itemType = <span class="built_in">Object</span>.prototype.toString.call(item)</span><br><span class="line">    <span class="keyword">if</span> (itemType === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (itemType === <span class="string">'[object Object]'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyBFS</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">//记录出现过的对象，用来处理环</span></span><br><span class="line">    <span class="keyword">let</span> target = getEmptyArrOrObj(origin);</span><br><span class="line">    queue.push([origin, target]);</span><br><span class="line">    map.set(origin, target);</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> [ori, tar] = queue.shift();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> ori) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ori.hasOwnProperty(key)) &#123; <span class="comment">// 不在原型上</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(ori[key])) &#123; <span class="comment">// 处理环状</span></span><br><span class="line">                    tar[key] = map.get(ori[key]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tar[key] = getEmptyArrOrObj(ori[key]);</span><br><span class="line">                queue.push([ori[key], tar[key]]);</span><br><span class="line">                map.set(ori[key], tar[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DFS</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEmptyArrOrObj</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> itemType = <span class="built_in">Object</span>.prototype.toString.call(item)</span><br><span class="line">    <span class="keyword">if</span> (itemType === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (itemType === <span class="string">'[object Object]'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyDFS</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> target = getEmptyArrOrObj(origin);</span><br><span class="line">    stack.push([origin, target]);</span><br><span class="line">    map.set(origin, target);</span><br><span class="line">    <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> [ori, tar] = stack.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> ori) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ori.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(ori[key])) &#123;</span><br><span class="line">                    tar[key] = map.get(ori[key]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tar[key] = getEmptyArrOrObj(ori[key]);</span><br><span class="line">                stack.push([ori[key], tar[key]]);</span><br><span class="line">                map.set(ori[key], tar[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="7-如何判断俩个对象相等"><a href="#7-如何判断俩个对象相等" class="headerlink" title="7.如何判断俩个对象相等"></a>7.如何判断俩个对象相等</h1><blockquote>
<p>ES5比较俩个值是否相等，只有俩个运算符：相等(<code>==</code>)运算符和严格相等运算符(<code>===</code>)</p>
<p>但都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。</p>
<p>JS缺乏一种运算，在所有环境中，只要俩个值是一样的，它们就应该相等。</p>
<p>ES6中的<code>Object.is()</code>相比<code>===</code>来说多了俩种判断：</p>
<ol>
<li>Object.is(NaN,NaN) //true</li>
<li>Object.is(+0,-0) //false</li>
</ol>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们认为只要 <code>===</code> 的结果为 true，两者就相等，然而今天我们重新定义相等：</p>
<p>我们认为：</p>
<ol>
<li>NaN 和 NaN 是相等</li>
<li>[1] 和 [1] 是相等</li>
<li>{value: 1} 和 {value: 1} 是相等</li>
</ol>
<p>不仅仅是这些长得一样的，还有</p>
<ol>
<li>1 和 new Number(1) 是相等</li>
<li>‘Curly’ 和 new String(‘Curly’) 是相等</li>
<li>true 和 new Boolean(true) 是相等</li>
</ol>
<h2 id="0-与-0"><a href="#0-与-0" class="headerlink" title="+0 与 -0"></a>+0 与 -0</h2><p>如果 a === b 的结果为 true， 那么 a 和 b 就是相等的吗？一般情况下，当然是这样的，但是有一个特殊的例子，就是 +0 和 -0。</p>
<p>JavaScript “处心积虑”的想抹平两者的差异：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表现1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表现2</span></span><br><span class="line">(<span class="number">-0</span>).toString() <span class="comment">// '0'</span></span><br><span class="line">(+<span class="number">0</span>).toString() <span class="comment">// '0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表现3</span></span><br><span class="line"><span class="number">-0</span> &lt; +<span class="number">0</span> <span class="comment">// false</span></span><br><span class="line">+<span class="number">0</span> &lt; <span class="number">-0</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>即便如此，两者依然是不同的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> / +<span class="number">0</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">1</span> / <span class="number">-0</span> <span class="comment">// -Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> / +<span class="number">0</span> === <span class="number">1</span> / <span class="number">-0</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>也许你会好奇为什么要有 +0 和 -0 呢？</p>
<p>这是因为 JavaScript 采用了IEEE_754 浮点数表示法(几乎所有现代编程语言所采用)，这是一种二进制表示法，按照这个标准，最高位是符号位(0 代表正，1 代表负)，剩下的用于表示大小。而对于零这个边界值 ，1000(-0) 和 0000(0)都是表示 0 ，这才有了正负零的区别。</p>
<p>也许你会好奇什么时候会产生 -0 呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(<span class="number">-0.1</span>) <span class="comment">// -0</span></span><br></pre></td></tr></table></figure>

<p>那么我们又该如何在 === 结果为 true 的时候，区别 0 和 -0 得出正确的结果呢？我们可以这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">-0</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p>我们认为NaN和NaN是相等的，那又该如何判断出 NaN 呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>利用 <code>NaN 不等于自身的特性，我们可以区别出 NaN</code>，那么这个 eq 函数又该怎么写呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eq(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">toString.call(<span class="string">'Curly'</span>); <span class="comment">// "[object String]"</span></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>)); <span class="comment">// "[object String]"</span></span><br></pre></td></tr></table></figure>

<p>那我们利用隐式类型转换呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Curly'</span> + <span class="string">''</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>) + <span class="string">''</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果a和b的Object.prototype.toString的结果一致，并且都是”[object String]”，那我们就使用’’ + a === ‘’ + b 进行判断。</p>
<p>可是不止有String对象呐，Boolean、Number、RegExp、Date呢？</p>
<h2 id="更多对象"><a href="#更多对象" class="headerlink" title="更多对象"></a>更多对象</h2><p>跟String同样的思路，利用隐式类型转换。</p>
<p><strong>Boolean</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>Date</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">9</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">9</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>RegExp</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="regexp">/a/i</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/a/i</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">''</span> + a === <span class="string">''</span> + b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>Number</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(+a === +b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>有例外：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(+a === +b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>但是判断为true才是正确的</p>
<p>那么我们就改成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Number</span>(<span class="literal">NaN</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 Number(NaN) Object(NaN) 等情况</span></span><br><span class="line">    <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</span><br><span class="line">    <span class="comment">// 其他判断 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eq(a, b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数实例"><a href="#构造函数实例" class="headerlink" title="构造函数实例"></a>构造函数实例</h2><h2 id="eq函数"><a href="#eq函数" class="headerlink" title="eq函数"></a>eq函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object Function]'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//区别出+0和-0</span></span><br><span class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</span><br><span class="line">    <span class="comment">//typeof null的结果为object，这里做判断，是为了让有null的情况尽早退出函数</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断NaN</span></span><br><span class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</span><br><span class="line">    <span class="comment">//判断a类型，如果是基本类型，直接返回false</span></span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> a;</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">'function'</span> &amp;&amp; type !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 更复杂的对象使用deepEq函数进行深度比较</span></span><br><span class="line">    <span class="keyword">return</span> deepEq(a, b, aStack, bStack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEq</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//a和b的内部属性[[class]]相同时返回true</span></span><br><span class="line">    <span class="keyword">let</span> className = toString.call(a);</span><br><span class="line">    <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (className) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'[object String]'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</span><br><span class="line">            <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</span><br><span class="line">            <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / +b : +a === +b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</span><br><span class="line">            <span class="keyword">return</span> +a === +b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> areArrays = className === <span class="string">'[object Array]'</span>;</span><br><span class="line">    <span class="comment">//不是数组</span></span><br><span class="line">    <span class="keyword">if</span> (!areArrays) &#123;</span><br><span class="line">        <span class="comment">//过滤掉俩个函数的情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> aCtor = a.constructor,</span><br><span class="line">            bCtor = b.constructor;</span><br><span class="line">        <span class="comment">// aCtor 和 bCtor 必须都存在并且都不是 Object 构造函数的情况下，aCtor 不等于 bCtor， 那这两个对象就真的不相等啦</span></span><br><span class="line">        <span class="keyword">if</span> (aCtor !== bCtor &amp;&amp; !(isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp; isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor) &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aStack = aStack || [];</span><br><span class="line">    bStack = bStack || [];</span><br><span class="line">    <span class="keyword">let</span> len = aStack.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有循环引用的部分</span></span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aStack[len] === a) &#123;</span><br><span class="line">            <span class="keyword">return</span> bStack[len] === b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aStack.push(a);</span><br><span class="line">    bStack.push(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组判断</span></span><br><span class="line">    <span class="keyword">if</span> (areArrays) &#123;</span><br><span class="line">        len = a.length;</span><br><span class="line">        <span class="keyword">if</span> (len !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!eq(a[len], b[len], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对象判断</span></span><br><span class="line">        <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(a),</span><br><span class="line">            key;</span><br><span class="line">        len = keys.length;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(b).length !== len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">            key = keys[len];</span><br><span class="line">            <span class="keyword">if</span> (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    aStack.pop();</span><br><span class="line">    bStack.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(eq(<span class="number">0</span>, <span class="number">-0</span>)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eq(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(eq(<span class="built_in">Number</span>(<span class="literal">NaN</span>), <span class="built_in">Number</span>(<span class="literal">NaN</span>))); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eq(<span class="string">'Curly'</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Curly'</span>))); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eq([<span class="number">1</span>], [<span class="number">1</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(eq(&#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line"></span><br><span class="line">a = &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            foo: &#123;</span><br><span class="line">                c: &#123;</span><br><span class="line">                    foo: <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">b = &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            foo: &#123;</span><br><span class="line">                c: &#123;</span><br><span class="line">                    foo: <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.foo.b.foo.c.foo = a;</span><br><span class="line">b.foo.b.foo.c.foo = b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eq(a, b)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h1 id="8-在数组中查找指定元素"><a href="#8-在数组中查找指定元素" class="headerlink" title="8.在数组中查找指定元素"></a>8.在数组中查找指定元素</h1><h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h2><p>ES6 对数组新增了 findIndex 方法，它会返回数组中满足提供的函数的第一个元素的索引，否则返回 -1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findIndex</span>(<span class="params">array, predicate, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.call(context, array[i], i, array)) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findIndex([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="keyword">function</span> (<span class="params">item, i, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;)) <span class="comment">// 2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">item, i, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;)<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<h2 id="findLastIndex"><a href="#findLastIndex" class="headerlink" title="findLastIndex"></a>findLastIndex</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLastIndex</span>(<span class="params">array, predicate, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.call(context, array[i], i, array)) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findLastIndex([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<h1 id="9-数组中的最大值最小值"><a href="#9-数组中的最大值最小值" class="headerlink" title="9.数组中的最大值最小值"></a>9.数组中的最大值最小值</h1><h2 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.max([value1[,value2, ...]])</span><br></pre></td></tr></table></figure>

<p>需要注意的是:</p>
<ol>
<li>如果有任一参数不能被转换为数值，则结果为 NaN。</li>
<li>max 是 Math 的静态方法，所以应该像这样使用：Math.max()，而不是作为 Math 实例的方法 (简单的来说，就是不使用 new )</li>
<li>如果没有参数，则结果为 <code>-Infinity</code> (注意是负无穷大)</li>
</ol>
<p>1.如果任一参数不能被转换为数值，这就意味着如果参数可以被转换成数字，就是可以进行比较的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="literal">true</span>, <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="literal">true</span>, <span class="string">'2'</span>, <span class="literal">null</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>, &#123;&#125;) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>2.如果没有参数，则结果为 -Infinity，对应的，Math.min 函数，如果没有参数，则结果为 Infinity，所以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min();</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max();</span><br><span class="line"><span class="built_in">console</span>.log(min &gt; max);</span><br></pre></td></tr></table></figure>

<h3 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h3><p>循环一遍</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    result =  <span class="built_in">Math</span>.max(result, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<h3 id="reduce-1"><a href="#reduce-1" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a &gt; b ? a : b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(max(arr));</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>如果我们先对数组进行一次排序，那么最大值就是最后一个值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(arr[arr.length - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>Math.max 支持传多个参数来进行比较，那么我们如何将一个数组转换成参数传进 Math.max 函数呢？eval 便是一种</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">eval</span>(<span class="string">"Math.max("</span> + arr + <span class="string">")"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(max)</span><br></pre></td></tr></table></figure>

<p> 这是因为发生了<code>隐式类型转换</code>，举个简单例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr + <span class="string">''</span>); <span class="comment">// 6,4,1,8,2,11,23</span></span><br></pre></td></tr></table></figure>

<p>其实</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> max = <span class="built_in">eval</span>(<span class="string">"Math.max("</span> + arr + <span class="string">")"</span>);</span><br></pre></td></tr></table></figure>

<p>其实就相当于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> max = <span class="built_in">eval</span>(<span class="string">"Math.max(6,4,1,8,2,11,23)"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="apply-1"><a href="#apply-1" class="headerlink" title="apply"></a>apply</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr))</span><br></pre></td></tr></table></figure>

<p><code>当apply、call、bind的第一个参数传入null/undefined的时候将执行js全局对象浏览器中是window，其他环境是global</code></p>
<h3 id="ES6-…"><a href="#ES6-…" class="headerlink" title="ES6 …"></a>ES6 …</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr))</span><br></pre></td></tr></table></figure>

<p><code>arr是一个数组，…arr是一个参数序列</code></p>
<h1 id="10-递归"><a href="#10-递归" class="headerlink" title="10.递归"></a>10.递归</h1><p>递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。我们只需要关注如何把原问题划分成符合条件的子问题，而不需要去研究这个子问题是如何被解决的。递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)) <span class="comment">// 5 * 4 * 3 * 2 * 1 = 120</span></span><br></pre></td></tr></table></figure>

<p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。</p>
<p>试着对阶乘函数分析执行的过程，我们会发现，JavaScript 会不停的创建执行上下文压入执行上下文栈，对于内存而言，维护这么多的执行上下文也是一笔不小的开销呐！那么，我们该如何优化呢？</p>
<p>答案就是<code>尾调用</code>。</p>
<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>尾调用，是指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并不是尾调用，因为 g(x) 的返回值还需要跟 1 进行计算后，f(x)才会返回值。</p>
<p>两者又有什么区别呢？答案就是执行上下文栈的变化不一样。</p>
<p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [];</span><br></pre></td></tr></table></figure>

<p>我们模拟下第一个尾调用函数执行时的执行上下文栈变化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">ECStack.push(<span class="xml"><span class="tag">&lt;<span class="name">f</span>&gt;</span> functionContext);</span></span><br><span class="line"></span><br><span class="line"><span class="xml">ECStack.pop();</span></span><br><span class="line"></span><br><span class="line">ECStack.push(&lt;g&gt; functionContext);</span><br><span class="line"></span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure>

<p>我们再来模拟一下第二个非尾调用函数执行时的执行上下文栈变化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack.push(<span class="xml"><span class="tag">&lt;<span class="name">f</span>&gt;</span> functionContext);</span></span><br><span class="line"></span><br><span class="line">ECStack.push(&lt;g&gt; functionContext);</span><br><span class="line"></span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure>

<p>也就说尾调用函数执行时，虽然也调用了一个函数，但是因为原来的的函数执行完毕，执行上下文会被弹出，执行上下文栈中相当于只多压入了一个执行上下文。然而非尾调用函数，就会创建多个执行上下文压入执行上下文栈。</p>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<h2 id="阶乘函数优化"><a href="#阶乘函数优化" class="headerlink" title="阶乘函数优化"></a>阶乘函数优化</h2><p>我们需要做的就是把所有用到的内部变量改写成函数的参数，以阶乘函数为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">4</span>, <span class="number">1</span>)) <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<p>我们计算4的阶乘，结果函数要传入4和1，我就不能只传入一个4吗？</p>
<p>这就用到偏函数了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newFactorial = partial(factorial, _, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">newFactorial(<span class="number">4</span>) <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> n * factorial2(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'尾递归'</span>);</span><br><span class="line">factorial(<span class="number">10000</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'尾递归'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'正常递归'</span>);</span><br><span class="line">factorial2(<span class="number">10000</span>)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'正常递归'</span>);</span><br><span class="line"><span class="comment">//尾递归: 2.032ms</span></span><br><span class="line"><span class="comment">//正常递归: 0.408ms</span></span><br></pre></td></tr></table></figure>

<p>可以看出<code>尾递归</code>的确提高了性能。</p>
<h1 id="11-防抖与节流"><a href="#11-防抖与节流" class="headerlink" title="11.防抖与节流"></a>11.防抖与节流</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端开发中会遇到一些频繁的事件触发，比如：</p>
<ol>
<li>window 的 resize、scroll</li>
<li>mousedown、mousemove</li>
<li>keyup、keydown<br> ……</li>
</ol>
<p>如果频繁触发，会有卡顿发生</p>
<p>为了解决这个问题，一般有两种解决方案：</p>
<ol>
<li>debounce 防抖</li>
<li>throttle 节流</li>
</ol>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>原理：</p>
<blockquote>
<p>你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!</p>
</blockquote>
<ul>
<li>百度搜索框在输入稍有停顿时才更新推荐热词。</li>
<li>拖拽</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">handler, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//维护一个timer 用来记录当前执行函数状态</span></span><br><span class="line">    <span class="comment">//timer是暂停执行函数的id，需要配合clearTimeout来清除</span></span><br><span class="line">    delay = delay || <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//通过this和arguments来获取函数的作用域和变量</span></span><br><span class="line">        <span class="comment">//event对象</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">//清理正在执行的函数，并重新执行</span></span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            handler.apply(context, args);</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不希望被频繁调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">counterName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(counterName + <span class="string">": "</span> + <span class="keyword">this</span>.index++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要的上下文对象</span></span><br><span class="line"><span class="keyword">let</span> counter = &#123;</span><br><span class="line">    index: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖的自增函数，绑定上下文对象counter</span></span><br><span class="line"><span class="keyword">let</span> db_add = debounce(add, <span class="number">10</span>).bind(counter)</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    db_add(<span class="string">"someCounter1"</span>);</span><br><span class="line">    db_add(<span class="string">"someCounter2"</span>);</span><br><span class="line">    db_add(<span class="string">"someCounter3"</span>);</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预期效果：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 每隔500ms，输出一个自增的数</span></span><br><span class="line"><span class="comment"> * 即打印：</span></span><br><span class="line"><span class="comment">    someCounter3:  0</span></span><br><span class="line"><span class="comment">    someCounter3:  1</span></span><br><span class="line"><span class="comment">    someCounter3:  2</span></span><br><span class="line"><span class="comment">    someCounter3:  3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><blockquote>
<p>如果你持续触发事件，每隔一段时间，只执行一次事件。</p>
</blockquote>
<blockquote>
<p>根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。<br>我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。</p>
</blockquote>
<blockquote>
<p>关于节流的实现，有两种主流的实现方式，一种是使用<code>时间戳</code>，一种是设置<code>定时器</code></p>
</blockquote>
<ul>
<li>抢券时疯狂点击，既要限制次数，又要保证先点先发出请求</li>
<li>窗口调整</li>
<li>页面滚动</li>
</ul>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">handler, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">            context = <span class="keyword">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; delay) &#123;</span><br><span class="line">            handler.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">handler, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                handler.apply(context, args);</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比俩种方法:</p>
<ol>
<li>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行</li>
<li>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</li>
</ol>
<p>防抖是虽然事件持续触发，但只有等事件停止触发后 n 秒才执行函数，节流是持续触发的时候，每 n 秒执行一次函数。</p>
<h1 id="12-使用setTimeout模拟setInterval"><a href="#12-使用setTimeout模拟setInterval" class="headerlink" title="12.使用setTimeout模拟setInterval"></a>12.使用setTimeout模拟setInterval</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可避免setInterval因执行时间导致的间隔执行时间不一致</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">500</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>



<h1 id="13-AJAX原生实现与promise封装"><a href="#13-AJAX原生实现与promise封装" class="headerlink" title="13.AJAX原生实现与promise封装"></a>13.AJAX原生实现与promise封装</h1><p>流程：</p>
<ol>
<li><p>创建XHR</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">    xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code for IE6, IE5</span></span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送请求</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(method,url,<span class="keyword">async</span>);</span><br><span class="line">xhr.setRequestHeader(header,value);</span><br><span class="line">xhr.send(string);</span><br></pre></td></tr></table></figure>

<p>规定请求的类型、URL 以及是否异步处理请求</p>
<ul>
<li><em>method</em>：请求的类型；GET 或 POST</li>
<li><em>url</em>：文件在服务器上的位置</li>
<li><em>async</em>：true（异步）或 false（同步）</li>
</ul>
<p>向请求添加 HTTP 头</p>
<ul>
<li><em>header</em>: 规定头的名称</li>
<li><em>value</em>: 规定头的值</li>
</ul>
<p>将请求发送到服务器</p>
<ul>
<li><em>string</em>：仅用于 POST 请求</li>
</ul>
<p>当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数</p>
<p>当使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可</p>
</blockquote>
</li>
<li><p>onreadystatechange</p>
<blockquote>
<p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当readyState改变时，就会触发onreadystatechange事件。readyState 属性存有XMLHttpRequest的状态信息。</p>
<ul>
<li>onreadystatechange: 一个函数，每当readyState属性改变时，就会调用该函数</li>
<li>readyState: XMLHttpRequest的状态<ul>
<li>0: 请求未初始化</li>
<li>1: 服务器连接已建立</li>
<li>2: 请求已接收</li>
<li>3: 请求处理中</li>
<li>4: 请求已完成，且响应已就绪</li>
</ul>
</li>
<li>status 200: “OK”、404: 未找到页面</li>
</ul>
</blockquote>
</li>
<li><p>服务器响应</p>
<blockquote>
<p>获得来自服务器的响应，使用XMLHttpRequest对象的responseText或responseXML属性</p>
<ul>
<li>responseText 获得字符串形式的响应数据。</li>
<li>responseXML 获得 XML 形式的响应数据。</li>
</ul>
</blockquote>
</li>
</ol>
<p>AJAX的核心是<code>XMLHttpRequest</code>。</p>
<p>一个完整的<code>AJAX</code>请求一般包括以下步骤：</p>
<ul>
<li>实例化<code>XMLHttpRequest</code>对象</li>
<li>连接服务器</li>
<li>发送请求</li>
<li>接收响应数据</li>
</ul>
<h3 id="ajax-的-xhr-对象的-7-个事件"><a href="#ajax-的-xhr-对象的-7-个事件" class="headerlink" title="ajax 的 xhr 对象的 7 个事件"></a>ajax 的 xhr 对象的 7 个事件</h3><ul>
<li>onloadstart<ul>
<li>开始send触发</li>
</ul>
</li>
<li>onprogress<ul>
<li>从服务器上下载数据每50ms触发一次</li>
</ul>
</li>
<li>onload<ul>
<li>得到响应</li>
</ul>
</li>
<li>onerror<ul>
<li>服务器异常</li>
</ul>
</li>
<li>onloadend<ul>
<li>请求结束，无论成功失败</li>
</ul>
</li>
<li>onreadystatechange<ul>
<li>xhr.readyState改变使触发</li>
</ul>
</li>
<li>onabort<ul>
<li>调用xhr.abort时触发</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> method = options.method || <span class="string">'GET'</span>,</span><br><span class="line">        params = options.params,</span><br><span class="line">        data = options.data,</span><br><span class="line">        url = options.url + (params ? <span class="string">'?'</span> + <span class="built_in">Object</span>.keys(params).map(<span class="function"><span class="params">key</span> =&gt;</span> key + <span class="string">'='</span> + params[key]).join(<span class="string">'&amp;'</span>) : <span class="string">''</span>),</span><br><span class="line">        <span class="keyword">async</span> = options.async === <span class="literal">false</span> ? <span class="literal">false</span> : <span class="literal">true</span>,</span><br><span class="line">        success = options.success,</span><br><span class="line">        headers = options.headers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> xhr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="keyword">else</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) success &amp;&amp; success(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.open(method, url, <span class="keyword">async</span>);</span><br><span class="line">    <span class="keyword">if</span> (headers) <span class="built_in">Object</span>.keys(headers).forEach(<span class="function"><span class="params">key</span> =&gt;</span> xhr.setRequestHeader(key, headers[key]));</span><br><span class="line">    method === <span class="string">'GET'</span> ? xhr.send() : xhr.send(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">    url: <span class="string">'...'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success'</span>, res);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">true</span>,</span><br><span class="line">    params: &#123;</span><br><span class="line">        p: <span class="string">'test'</span>,</span><br><span class="line">        t: <span class="number">666</span></span><br><span class="line">    &#125;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 简单流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">xhr.open(method, url, <span class="keyword">async</span>)</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.send(data)</span><br><span class="line"><span class="comment">// 设置状态变化回调处理请求结果</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyStatus === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 基于promise实现 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 请求地址</span></span><br><span class="line">  <span class="keyword">const</span> url = options.url</span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  <span class="keyword">const</span> method = options.method.toLocaleLowerCase() || <span class="string">'get'</span></span><br><span class="line">  <span class="comment">// 默认为异步true</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">async</span> = options.async</span><br><span class="line">  <span class="comment">// 请求参数</span></span><br><span class="line">  <span class="keyword">const</span> data = options.data</span><br><span class="line">  <span class="comment">// 实例化</span></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  <span class="comment">// 请求超时</span></span><br><span class="line">  <span class="keyword">if</span> (options.timeout &amp;&amp; options.timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    xhr.timeout = options.timeout</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个Promise实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    xhr.ontimeout = <span class="function"><span class="params">()</span> =&gt;</span> reject &amp;&amp; reject(<span class="string">'请求超时'</span>)</span><br><span class="line">    <span class="comment">// 监听状态变化回调</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 200-300 之间表示请求成功，304资源未变，取缓存</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">          resolve &amp;&amp; resolve(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject &amp;&amp; reject()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误回调</span></span><br><span class="line">    xhr.onerror = <span class="function"><span class="params">err</span> =&gt;</span> reject &amp;&amp; reject(err)</span><br><span class="line">    <span class="keyword">let</span> paramArr = []</span><br><span class="line">    <span class="keyword">let</span> encodeData</span><br><span class="line">    <span class="comment">// 处理请求参数</span></span><br><span class="line">    <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="comment">// 参数拼接需要通过 encodeURIComponent 进行编码</span></span><br><span class="line">        paramArr.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key]))</span><br><span class="line">      &#125;</span><br><span class="line">      encodeData = paramArr.join(<span class="string">'&amp;'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get请求拼接参数</span></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'get'</span>) &#123;</span><br><span class="line">      <span class="comment">// 检测url中是否已存在 ? 及其位置</span></span><br><span class="line">      <span class="keyword">const</span> index = url.indexOf(<span class="string">'?'</span>)</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">-1</span>) url += <span class="string">'?'</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (index !== url.length <span class="number">-1</span>) url += <span class="string">'&amp;'</span></span><br><span class="line">      <span class="comment">// 拼接url</span></span><br><span class="line">      url += encodeData</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    xhr.open(method, url, <span class="keyword">async</span>)</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'get'</span>) xhr.send(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// post 方式需要设置请求头</span></span><br><span class="line">      xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span>)</span><br><span class="line">      xhr.send(encodeData)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="14-懒加载"><a href="#14-懒加载" class="headerlink" title="14.懒加载"></a>14.懒加载</h1><p>Lazy-Load，翻译过来是“懒加载”。它是针对图片加载时机的优化：在一些图片量比较大的网站（比如电商网站首页，或者团购网站、小游戏首页等），如果我们尝试在用户打开页面的时候，就把所有的图片资源加载完毕，那么很可能会造成白屏、卡顿等现象，因为图片真的太多了，一口气处理这么多任务，浏览器做不到啊！</p>
<p>但我们再想，用户真的需要这么多图片吗？不对，用户点开页面的瞬间，呈现给他的只有屏幕的一部分（我们称之为首屏）。只要我们可以在页面打开的时候把首屏的图片资源加载出来，用户就会认为页面是没问题的。至于下面的图片，我们完全可以等用户下拉的瞬间再即时去请求、即时呈现给他。这样一来，性能的压力小了，用户的体验却没有变差——这个延迟加载的过程，就是 Lazy-Load。</p>
<p>在懒加载的实现中，有两个关键的数值：一个是<strong>当前可视区域的高度</strong>，另一个是<strong>元素距离可视区域顶部的高度</strong>。</p>
<p><strong>当前可视区域的高度</strong>， 在和现代浏览器及 IE9 以上的浏览器中，可以用 window.innerHeight 属性获取。在低版本 IE 的标准模式中，可以用 document.documentElement.clientHeight 获取，这里我们兼容两种情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight</span><br></pre></td></tr></table></figure>

<p>而<strong>元素距离可视区域顶部的高度</strong>，我们这里选用 getBoundingClientRect() 方法来获取返回元素的大小及其相对于视口的位置。对此 MDN 给出了非常清晰的解释：</p>
<blockquote>
<p>该方法的返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的 CSS 边框集合 。</p>
</blockquote>
<blockquote>
<p>DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。</p>
</blockquote>
<p>其中需要引起我们注意的就是 left、top、right 和 bottom，它们对应到元素上是这样的：</p>
<p><img src="/2020/01/23/JS%E9%83%A8%E5%88%86API%E5%AE%9E%E7%8E%B0/8.png" alt></p>
<p>可以看出，top 属性代表了元素距离可视区域顶部的高度，正好可以为我们所用！</p>
<p>Lazy-Load 方法开工啦！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 获取所有的图片标签</span></span><br><span class="line">  <span class="keyword">const</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span><br><span class="line">  <span class="comment">// 获取可视区域的高度</span></span><br><span class="line">  <span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = imgs.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 用可视区域高度减去元素顶部距离可视区域顶部的高度</span></span><br><span class="line">      <span class="keyword">let</span> distance = viewHeight - imgs[i].getBoundingClientRect().top</span><br><span class="line">      <span class="comment">// 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出</span></span><br><span class="line">      <span class="keyword">if</span> (distance &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 给元素写入真实的src，展示图片</span></span><br><span class="line">        imgs[i].src = imgs[i].getAttribute(<span class="string">'data-src'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lazyload();</span><br><span class="line">  <span class="comment">// 监听Scroll事件</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, lazyload, <span class="literal">false</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="15-promise"><a href="#15-promise" class="headerlink" title="15.promise"></a>15.promise</h1><h2 id="promise出现的原因"><a href="#promise出现的原因" class="headerlink" title="promise出现的原因"></a>promise出现的原因</h2><p>如果我们想根据第一个网络请求的结果，再去执行第二个网络请求，那么会出现<strong>回调地狱</strong></p>
<p>回调地狱带来的负面作用有以下几点：</p>
<ul>
<li>代码臃肿。</li>
<li>可读性差。</li>
<li>耦合度过高，可维护性差。</li>
<li>代码复用性差。</li>
<li>容易滋生 bug。</li>
<li>只能在回调里处理异常。</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul>
<li><p>Promise.resolve(value)</p>
<p>  类方法，该方法返回一个以value值解析后的Promise对象</p>
<ol>
<li><p>参数是一个thenable对象，Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">	then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">		resolve(<span class="number">42</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果传入的value本身就是Promise对象，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p>
</li>
<li><p>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved 。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不带有任何参数</p>
<p> Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"><span class="comment">//one two three</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>Promise.reject</p>
<p>  类方法，且与resolve唯一的不同是，返回的promise对象的状态为rejected。</p>
</li>
<li><p>Promise.prototype.then</p>
<p>  实例方法，为Promise注册回调函数，函数形式：fn(value){}，value 是上一个任务的返回结果，<strong>then 中的函数一定要return一个结果或者一个新的Promise对象，才可以让之后的then回调接收。</strong></p>
</li>
<li><p>Promise.prototype.catch</p>
<p>  Promise.prototype.catch方法是.then(null, rejection) 的别名，用于指定发生错误时的回调函数。</p>
</li>
<li><p>Promise.race</p>
<p>  Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。返回率先改变状态的Promise结果，不管这个Promise结果是成功还是失败。</p>
</li>
<li><p>Promise.all</p>
<p>  类方法，多个Promise任务同时执行。如果全部<strong>成功执行</strong>，则以数组的方式返回所有Promise任务的执行结果。 如果有一个Promise任务rejected，则<strong>只返回rejected任务的结果</strong>。</p>
</li>
<li><p>Promise.prototype.done</p>
<p>  Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
</li>
<li><p>Promise.prototype.finally</p>
<p>  finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="comment">//初始化state为等待态</span></span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="comment">//为啥是数组而不是一个函数，主要是考虑的是一个promise有可能多次调用</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="comment">// 一旦resolve执行，调用成功数组的函数</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.state = <span class="string">'rejected'</span>;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果executor执行报错，直接执行reject</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// then 方法 有两个参数onFulfilled onRejected</span></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">//对传入的两个参数做判断，如果不是函数将其转为函数 透传 </span></span><br><span class="line">        <span class="comment">//Promise.resolve(4).then().then((value) =&gt; console.log(value))</span></span><br><span class="line">        <span class="comment">// onFulfilled如果不是函数，就忽略onFulfilled，直接返回value</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        <span class="comment">// onRejected如果不是函数，就忽略onRejected，直接扔出错误</span></span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> err</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//声明返回的promise2</span></span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 状态为fulfilled，执行onFulfilled，传入成功的值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">                <span class="comment">//异步 因为下面要用到promise2，所以用异步让其进入下一轮事件循环</span></span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 状态为rejected，执行onRejected，传入失败的原因</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当状态state为pending时</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">                <span class="comment">//当resolve在setTomeout内执行，then时state还是pending等待状态 </span></span><br><span class="line">                <span class="comment">//我们就需要在then调用的时候，将成功和失败存到各自的数组，</span></span><br><span class="line">                <span class="comment">//一旦reject或者resolve，就调用它们</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//这个返回的值用来作为传递给下一个then的值</span></span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//返回promise,完成链式</span></span><br><span class="line">        <span class="comment">//主要是为了解决链式调用new Promise().then().then()</span></span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, fn);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    done(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="keyword">this</span>.then(onFulfilled, onRejected).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 抛出一个全局错误</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> reason</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 promise对象的原数据继续向下传递，</span></span><br><span class="line">    <span class="comment">// 失败数据则需要抛出供后续catch 使用</span></span><br><span class="line">    <span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> val)</span><br><span class="line">        &#125;, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> err</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让不同的promise代码互相套用，叫做resolvePromise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//循环引用报错</span></span><br><span class="line">    <span class="keyword">if</span> (x === promise2) <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">    <span class="comment">//防止多次调用</span></span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// A+规定，声明then = x的then方法</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="comment">//then有可能只是属性值，不是方法，直接resolve</span></span><br><span class="line">            <span class="comment">// 如果then是函数，就默认是promise了</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="comment">// 就让then执行 第一个参数是this   后面是成功的回调 和 失败的回调</span></span><br><span class="line">                then.call(x, y =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// resolve的结果依旧是promise 那就继续解析</span></span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, err =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 也属于失败</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 取then出错了那就不要在继续执行了</span></span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(val);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(val);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> resolvedCount = <span class="number">0</span>,</span><br><span class="line">            promiseNum = promises.length,</span><br><span class="line">            resolveValue = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promisesNum; i++) &#123;</span><br><span class="line">            <span class="comment">//MyPromise.resolve()方法把不是MyPromise的参数转为MyPromise对象。</span></span><br><span class="line">            <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                resolveValue[i] = value;</span><br><span class="line">                resolvedCount++;</span><br><span class="line">                <span class="keyword">if</span> (resolvedCount === promisesNum) <span class="keyword">return</span> resolveValue;</span><br><span class="line">            &#125;, (reason) =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(reason);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.defer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        dfd.resolve = resolve</span><br><span class="line">        dfd.reject = reject</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//promises-aplus-tests promise.js</span></span><br></pre></td></tr></table></figure>



<h1 id="16-异步手写代码"><a href="#16-异步手写代码" class="headerlink" title="16.异步手写代码"></a>16.异步手写代码</h1><h2 id="实现一个sleep函数"><a href="#实现一个sleep函数" class="headerlink" title="实现一个sleep函数"></a>实现一个sleep函数</h2><p>Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>Generator</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//next()返回的是一个generator</span></span><br><span class="line">sleep(<span class="number">1000</span>).next().value.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Async</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, time);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>ES5</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> cb === <span class="string">'function'</span>) &#123;</span><br><span class="line">        setTimeout(cb, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="实现每隔一秒钟输出1-2-3…数字"><a href="#实现每隔一秒钟输出1-2-3…数字" class="headerlink" title="实现每隔一秒钟输出1,2,3…数字"></a>实现每隔一秒钟输出1,2,3…数字</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i + <span class="number">1</span>);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then: '</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'catch: '</span>, err)</span><br><span class="line">    &#125;)</span><br><span class="line">-----------------------------------</span><br><span class="line">then: <span class="built_in">Error</span>: error!!!</span><br><span class="line">    at <span class="built_in">Promise</span>.resolve.then (...)</span><br><span class="line">    at ...复制</span><br></pre></td></tr></table></figure>

<p><code>.then</code> 或者 <code>.catch</code> 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 <code>.catch</code> 捕获，需要改成其中一种：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>))</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)复制代码</span><br></pre></td></tr></table></figure>

<p>因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 <code>return new Error(&#39;error!!!&#39;)</code> 等价于 <code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">    &#125;)</span><br><span class="line">promise.catch(<span class="built_in">console</span>.error)</span><br><span class="line"><span class="comment">//TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">    .then(<span class="number">2</span>)</span><br><span class="line">    .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val))</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值穿透。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">-------------------------</span><br><span class="line">end</span><br><span class="line">nextTick</span><br><span class="line">then</span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure>

<p><code>process.nextTick</code> 和 <code>promise.then</code> 都属于 microtask，而 <code>setImmediate</code> 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'once'</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line">----------------</span><br><span class="line">once</span><br><span class="line">success <span class="number">1008</span></span><br><span class="line">success <span class="number">1009</span></span><br></pre></td></tr></table></figure>

<p>promise 的 <code>.then</code> 或者 <code>.catch</code> 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 <code>.then</code> 或者 <code>.catch</code> 都会直接拿到该值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p2</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure>

<p>上面代码中， p1是一个Promise，3秒之后变为rejected 。p2的状态在1秒之后改变， resolve 方法返回的是 p1 。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（ p1 ）。又过了2秒，p1 变为rejected ，导致触发catch方法指定的回调函数。</p>
<h2 id="每间隔3s输出"><a href="#每间隔3s输出" class="headerlink" title="每间隔3s输出"></a>每间隔3s输出</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">func, times, wait</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">const</span> repeatFunc = repeat(alert, <span class="number">4</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 会alert4次 helloworld, 每次间隔3秒</span></span><br><span class="line">repeatFunc(<span class="string">'hellworld'</span>);</span><br><span class="line"><span class="comment">// 会alert4次 worldhellp, 每次间隔3秒</span></span><br><span class="line">repeatFunc(<span class="string">'worldhello'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">func, times, s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                func.apply(<span class="literal">null</span>, args);</span><br><span class="line">            &#125;, s * i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> log = <span class="built_in">console</span>.log</span><br><span class="line"><span class="keyword">let</span> repeatFunc = repeat(log, <span class="number">4</span>, <span class="number">3000</span>)</span><br><span class="line">repeatFunc(<span class="string">'HelloWorld'</span>)</span><br><span class="line">repeatFunc(<span class="string">'WorldHello'</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">seconds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(res, seconds);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">func, times, s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            func.apply(<span class="literal">null</span>, args);</span><br><span class="line">            <span class="keyword">await</span> wait(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> log = <span class="built_in">console</span>.log</span><br><span class="line"><span class="keyword">let</span> repeatFunc = repeat(log, <span class="number">4</span>, <span class="number">3000</span>)</span><br><span class="line">repeatFunc(<span class="string">'HelloWorld'</span>)</span><br><span class="line">repeatFunc(<span class="string">'WorldHello'</span>)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JS基础总结</title>
    <url>/2020/01/18/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1-变量类型和类型转换"><a href="#1-变量类型和类型转换" class="headerlink" title="1.变量类型和类型转换"></a>1.变量类型和类型转换</h1><h2 id="JS-变量类型"><a href="#JS-变量类型" class="headerlink" title="JS 变量类型"></a>JS 变量类型</h2><p>JS中有 6 种原始值，分别是：</p>
<ol>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>undefined</li>
<li>symbol</li>
<li>null</li>
</ol>
<p>引用类型：</p>
<ol>
<li>对象</li>
<li>数组</li>
<li>函数</li>
</ol>
<a id="more"></a>

<h2 id="JS中使用typeof能得到哪些类型？"><a href="#JS中使用typeof能得到哪些类型？" class="headerlink" title="JS中使用typeof能得到哪些类型？"></a>JS中使用typeof能得到哪些类型？</h2><p>其中一个奇怪的 null，虽然是基本变量，但是因为设计的时候<code>null</code>是全0，而对象是<code>000</code>开头，所以有这个误判。</p>
<ol>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>undefined</li>
<li>symbol</li>
<li><strong>object</strong></li>
<li><strong>function</strong></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">bigint</a></li>
</ol>
<h2 id="instanceof-能正确判断对象的原理是什么？"><a href="#instanceof-能正确判断对象的原理是什么？" class="headerlink" title="instanceof 能正确判断对象的原理是什么？"></a>instanceof 能正确判断对象的原理是什么？</h2><p>判断一个对象与构造函数是否在一个原型链上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>)</span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对于原始类型来说，你想直接通过 <code>instanceof</code> 来判断类型是不行的，当然我们还是有办法让 <code>instanceof</code> 判断原始类型的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimitiveString</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">'string'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span> <span class="keyword">instanceof</span> PrimitiveString) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>你可能不知道 <code>Symbol.hasInstance</code> 是什么东西，其实就是一个能让我们自定义 <code>instanceof</code> 行为的东西，以上代码等同于 <code>typeof &#39;hello world&#39; === &#39;string&#39;</code>，所以结果自然是 <code>true</code> 了。这其实也侧面反映了一个问题， <code>instanceof</code> 也不是百分之百可信的。</p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><blockquote>
<p>能检测出object、undefined、string、number、boolean、function,但对于object下的细分不能够识别</p>
</blockquote>
<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><blockquote>
<p>When the toString method is called, the following steps are taken:</p>
</blockquote>
<blockquote>
<ol>
<li>If the <strong>this</strong> value is <strong>undefined</strong>, return “<strong>[object Undefined]</strong>“.</li>
<li>If the <strong>this</strong> value is <strong>null</strong>, return “<strong>[object Null]</strong>“.</li>
<li>Let <em>O</em> be the result of calling ToObject passing the <strong>this</strong> value as the argument.</li>
<li>Let <em>class</em> be the value of the [[Class]] internal property of <em>O</em>.</li>
<li>Return the String value that is the result of concatenating the three Strings “<strong>[object</strong> “, <em>class</em>, and “<strong>]</strong>“.</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是11种：</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">1</span>;          <span class="comment">// [object Number]</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'123'</span>;      <span class="comment">// [object String]</span></span><br><span class="line"><span class="keyword">var</span> boolean = <span class="literal">true</span>;      <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="keyword">var</span> und = <span class="literal">undefined</span>;     <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="keyword">var</span> nul = <span class="literal">null</span>;          <span class="comment">// [object Null]</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;         <span class="comment">// [object Object]</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   <span class="comment">// [object Array]</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();   <span class="comment">// [object Date]</span></span><br><span class="line"><span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// [object Error]</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;          <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// [object Function]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>[i]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func)</span><br></pre></td></tr></table></figure>

<p>除了以上 11 种之外，还有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>)); <span class="comment">// [object Math]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>)); <span class="comment">// [object JSON]</span></span><br></pre></td></tr></table></figure>

<p>除了以上 13 种之外，还有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>)); <span class="comment">// [object Arguments]</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>所以我们可以识别至少 14 种类型，当然我们也可以算出来，[[class]] 属性至少有 12 个。</p>
<p><img src="/2020/01/18/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/6.png" alt></p>
<h2 id="实现一个类型判断函数"><a href="#实现一个类型判断函数" class="headerlink" title="实现一个类型判断函数"></a>实现一个类型判断函数</h2><ol>
<li>判断null</li>
<li>判断基本类型</li>
<li>使用Object.prototype.toString.call(target)来判断<strong>引用类型</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//先处理最特殊的null</span></span><br><span class="line">    <span class="keyword">if</span>(target === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'null'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是基本类型</span></span><br><span class="line">    <span class="keyword">const</span> typeOfT = <span class="keyword">typeof</span> target</span><br><span class="line">    <span class="keyword">if</span>(typeOfT !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> typeOfT</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//肯定是引用类型</span></span><br><span class="line">    <span class="keyword">const</span> template = &#123;</span><br><span class="line">        <span class="string">"[object Object]"</span>: <span class="string">"object"</span>,</span><br><span class="line">        <span class="string">"[object Array]"</span>: <span class="string">"array"</span>,</span><br><span class="line">        <span class="comment">//一些包装类型</span></span><br><span class="line">        <span class="string">"[object String]"</span>: <span class="string">"object - string"</span>,</span><br><span class="line">        <span class="string">"[object Number]"</span>: <span class="string">"object - number"</span>,</span><br><span class="line">        <span class="string">"[object Boolean]"</span>: <span class="string">"object - boolean"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> typeStr = <span class="built_in">Object</span>.prototype.toString.call(target)</span><br><span class="line">    <span class="keyword">return</span> template[typeStr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转Boolean</h2><p>以下都为假值，其他所有值都转为 true，包括所有对象（空对象，空数组也转为真）。</p>
<ul>
<li>false</li>
<li>undfined</li>
<li>null</li>
<li>‘’</li>
<li>NaN</li>
<li>0</li>
<li>-0</li>
</ul>
<h2 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h2><p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下：</p>
<ul>
<li>如果已经是原始类型了，那就不需要转换了</li>
<li>如果需要转字符串类型就调用 <code>x.toString()</code>，转换为基础类型的话就返回转换的值。不是字符串类型的话就先调用 <code>valueOf</code>，结果不是基础类型的话再调用 <code>toString</code></li>
<li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li>
<li>如果都没有返回原始类型，就会报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + a           <span class="comment">// 1</span></span><br><span class="line"><span class="string">'1'</span>.concat(a)   <span class="comment">//"11"</span></span><br></pre></td></tr></table></figure>

<p>也可以重写 <code>Symbol.toPrimitive</code> ，该方法在转基本类型时调用<strong>优先级最高</strong>。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive" target="_blank" rel="noopener">Symbol.toPrimitive</a> 指将被调用的指定函数值的属性转换为相对应的原始值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(+object1);</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> + a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li>
<li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment">// '11'</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// "41,2,3"</span></span><br></pre></td></tr></table></figure>

<p>还需要注意这个表达式<code>&#39;a&#39; + + &#39;b&#39;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'a'</span> + + <span class="string">'b'</span> <span class="comment">// -&gt; "aNaN"</span></span><br></pre></td></tr></table></figure>

<p>因为 + ‘b’ 等于 NaN，所以结果为 “aNaN”，你可能也会在一些代码中看到过 + ‘1’ 的形式来快速获取 number 类型。</p>
<p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> * <span class="string">'3'</span> <span class="comment">// 12</span></span><br><span class="line"><span class="number">4</span> * [] <span class="comment">// 0</span></span><br><span class="line"><span class="number">4</span> * [<span class="number">1</span>, <span class="number">2</span>] <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ol>
<li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li>
<li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a &gt; <span class="number">-1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在以上代码中，因为 <code>a</code> 是对象，所以会通过 <code>valueOf</code> 转换为原始类型再比较值。</p>
<h2 id="100-问题"><a href="#100-问题" class="headerlink" title="100 + 问题"></a><code>100 +</code> 问题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'100'</span> + <span class="number">100</span>   <span class="comment">// "100100"</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> + <span class="string">'100'</span>   <span class="comment">// "100100"</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> + <span class="literal">true</span>    <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> + <span class="literal">false</span>   <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> + <span class="literal">undefined</span> <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> + <span class="literal">null</span>    <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h2 id="“a-common-string”为什么会有length属性"><a href="#“a-common-string”为什么会有length属性" class="headerlink" title="“a common string”为什么会有length属性"></a>“a common string”为什么会有length属性</h2><p>通过字面量的方式创建：var a = ‘string’;，这时它就是基本类型值；通过构造函数的方式创建：var a = new String(‘string’);这时它是对象类型。</p>
<p>基本类型是没有属性和方法的，但仍然可以使用对象才有的属性方法。这时因为在对基本类型使用属性方法的时候，后台会隐式的创建这个基本类型的对象，之后再销毁这个对象</p>
<h2 id="console-log-new-Boolean-false-输出什么-易混淆"><a href="#console-log-new-Boolean-false-输出什么-易混淆" class="headerlink" title="console.log(!!(new Boolean(false))输出什么 [易混淆]"></a>console.log(!!(new Boolean(false))输出什么 [易混淆]</h2><p>true   布尔的包装对象 Boolean 的对象实例，对象只有在 null 与 undefined 时，才会认定为布尔的 false 值，布尔包装对象本身是个对象，对象-&gt;布尔 都是 true，所以 new Boolean(false)其实是布尔的 true，看下面这段代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))&#123;</span><br><span class="line">    alert(<span class="string">'true!!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有使用了 valueOf 后才是真正的转换布尔值，与上面包装对象与原始资料转换说明的相同:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!!(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))  <span class="comment">//true</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)).valueOf() <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="vs"><a href="#vs" class="headerlink" title="== vs ==="></a>== vs ===</h2><h3 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a>== 操作符</h3><ol>
<li>首先会判断两者类型是否相同。相同的话就是比大小了</li>
<li>类型不相同的话，那么就会进行类型转换</li>
<li>会先判断是否在对比 null 和 undefined，是的话就会返回 true</li>
<li>判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number</li>
<li>判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断</li>
<li>判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断</li>
<li>两边都是对象的话，那么只要不是同一对象的不同引用，都为false</li>
</ol>
<p>只要出现NaN，就一定是false，因为就连NaN自己都不等于NaN 对于NaN，判断的方法是使用全局函数 <code>isNaN()</code></p>
<p><img src="/2020/01/18/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/7.png" alt></p>
<h3 id="操作符-1"><a href="#操作符-1" class="headerlink" title="=== 操作符"></a>=== 操作符</h3><p>不转类型，直接判断类型和值是否相同。 但是 NaN === NaN 还是false</p>
<h3 id="等于true还是false"><a href="#等于true还是false" class="headerlink" title="{} 等于true还是false"></a>{} 等于true还是false</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a == <span class="literal">true</span> <span class="comment">// -&gt; ?</span></span><br><span class="line">a == <span class="literal">false</span> <span class="comment">// -&gt; ?</span></span><br></pre></td></tr></table></figure>

<p>答案是两个都为false 因为a.toString() -&gt; ‘[object Object]’ -&gt; NaN</p>
<p>但是一般情况下对象的toString方法都被重写了，所以在判断类型的时候都会调用Object.prototype.toString.call()</p>
<h3 id="1-与-Number-1-有什么区别"><a href="#1-与-Number-1-有什么区别" class="headerlink" title="1 与 Number(1)有什么区别"></a>1 与 Number(1)有什么区别</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)  <span class="comment">// Number &#123;[[PrimitiveValue]]: 1&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> (a) <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> (b) <span class="comment">// object</span></span><br><span class="line">a == b <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>var a = 1 是一个常量，而 Number(1)是一个函数</li>
<li>new Number(1)返回的是一个对象</li>
<li>a==b 为 true 是因为所以在求值过程中，总是会强制转为原始数据类型而非对象，例如下面的代码:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// "object"</span></span><br><span class="line"><span class="number">123</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>)) <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">123</span> === <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title="[]==![]"></a>[]==![]</h3><ol>
<li>根据运算符优先级 ，！ 的优先级是大于 == 的，所以先会执行 ![]，！可将变量转换成boolean类型，null、undefined、NaN以及空字符串(‘’)取反都为true，其余都为false。所以 ! [] 运算后的结果就是 false，也就是 [] == ! [] 相当于 [] == false</li>
<li>根据上面提到的规则（如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1），则需要把 false 转成 0，也就是 [] == ! [] 相当于 [] == false 相当于 [] == 0</li>
<li>根据上面提到的规则（如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较，如果对象没有valueOf()方法，则调用 toString()）而对于空数组，[].toString() -&gt;  ‘’ (返回的是空字符串)也就是  [] == 0 相当于 ‘’ == 0</li>
<li>根据上面提到的规则（如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值）Number(‘’) -&gt; 返回的是 0，相当于 0 == 0 自然就返回 true了</li>
</ol>
<p>总结一下：</p>
<p>[] == ! []   -&gt;   [] == false  -&gt;  [] == 0  -&gt;   ‘’ == 0   -&gt;  0 == 0   -&gt;  true </p>
<p>那么对于 {} == !{} 也是同理的</p>
<p>关键在于  {}.toString() -&gt;   ‘[object Object]’ -&gt; NaN(返回的是NaN)</p>
<p>根据上面的规则（如果有一个操作数是NaN，则相等操作符返回 false）</p>
<p>总结一下：</p>
<p>{} == ! {}   -&gt;   {} == false  -&gt;  {} == 0  -&gt;   NaN == 0    -&gt;  false</p>
<p>[]==[] //false</p>
<h3 id="输出以下代码运行结果"><a href="#输出以下代码运行结果" class="headerlink" title="输出以下代码运行结果"></a>输出以下代码运行结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 + &quot;1&quot;</span><br><span class="line"></span><br><span class="line">2 * &quot;2&quot;</span><br><span class="line"></span><br><span class="line">[1, 2] + [2, 1]</span><br><span class="line"></span><br><span class="line">&quot;a&quot; + + &quot;b&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>1 + “1”<ul>
<li>加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来</li>
<li>所以值为：“11”</li>
</ul>
</li>
<li>2 * “2”<ul>
<li>乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值</li>
</ul>
</li>
<li>[1, 2] + [2, 1]<ul>
<li>Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法。</li>
<li>所以两个数组对象的toString方法相加，值为：”1,22,1”</li>
</ul>
</li>
<li>“a” + + “b”<ul>
<li>后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。</li>
<li>所以值为：”aNaN”</li>
</ul>
</li>
</ul>
<h2 id="如何判断一个数据是不是Array"><a href="#如何判断一个数据是不是Array" class="headerlink" title="如何判断一个数据是不是Array"></a>如何判断一个数据是不是Array</h2><ul>
<li><pre><code>Array.isArray(obj)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - ECMAScript 5种的函数，当使用ie8的时候就会出现问题。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
obj instanceof Array
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 当用来检测在不同的window或iframe里构造的数组时会失败。这是因为每一个iframe都有它自己的执行环境，彼此之间并不共享原型链，所以此时的判断一个对象是否为数组就会失败。此时我们有一个更好的方式去判断一个对象是否为数组。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
Object.prototype.toString.call(obj) == &apos;[object Array]&apos;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 这个方法比较靠谱</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
obj.constructor === Array
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - constructor属性返回对创建此对象的函数的引用</span><br><span class="line"></span><br><span class="line">## Object.prototype.toString</span><br><span class="line"></span><br><span class="line">如果是原始类型，他会将原始类型包装为引用类型，然后调用对应方法</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;JS</span><br><span class="line">function dd()&#123;&#125;</span><br><span class="line">var toString &#x3D; Object.prototype.toString;</span><br><span class="line">toString.call(dd);          &#x2F;&#x2F;[object Function]</span><br><span class="line">toString.call(new Object);  &#x2F;&#x2F;[object Object]</span><br><span class="line">toString.call(new Array);   &#x2F;&#x2F;[object Array]</span><br><span class="line">toString.call(new Date);    &#x2F;&#x2F;[object Date]</span><br><span class="line">toString.call(new String);  &#x2F;&#x2F;[object String]</span><br><span class="line">toString.call(Math);        &#x2F;&#x2F;[object Math]</span><br><span class="line">toString.call(undefined);   &#x2F;&#x2F;[object Undefined]</span><br><span class="line">toString.call(null);        &#x2F;&#x2F;[object Null]</span><br><span class="line">toString.call(123)          &#x2F;&#x2F;[object Number]</span><br><span class="line">toString.call(&#39;abc&#39;)        &#x2F;&#x2F;[object String]</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<h2 id="obj-toString-和Object-prototype-toString-call-obj"><a href="#obj-toString-和Object-prototype-toString-call-obj" class="headerlink" title="obj.toString() 和Object.prototype.toString.call(obj)"></a>obj.toString() 和Object.prototype.toString.call(obj)</h2><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p>
<p>这是因为toString为Object的原型方法，而Array ，function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…..），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;,</span><br><span class="line">  b = &#123;</span><br><span class="line">    n: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  c = &#123;</span><br><span class="line">    m: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">a[b] = <span class="string">'z'</span>;</span><br><span class="line">a[c] = <span class="string">'j'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"><span class="comment">//j</span></span><br></pre></td></tr></table></figure>

<p>转换成属性名，调用toString()，所以b.toString()=&gt;’[object Object]’，c.toString()=&gt;’[object Object]’，会覆盖前一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(&#123;&#125;)</span><br><span class="line"><span class="comment">//'[object Object]'</span></span><br><span class="line">alert(&#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'3'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// '3'</span></span><br></pre></td></tr></table></figure>

<p>alert()会将里面的强转为字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>,</span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  A = <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A(<span class="number">1</span>);</span><br><span class="line">A(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//1 4</span></span><br></pre></td></tr></table></figure>

<p>闭包</p>
<h2 id="对象引用问题-1"><a href="#对象引用问题-1" class="headerlink" title="对象引用问题 - 1"></a>对象引用问题 - 1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x) 	<span class="comment">// --&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x)  <span class="comment">// --&gt; &#123;n: 2&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>优先级</strong>。<code>.</code>的优先级高于<code>=</code>，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。</li>
<li><strong>赋值操作是从右到左</strong>，所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2}</li>
</ol>
<h2 id="对象引用问题-2"><a href="#对象引用问题-2" class="headerlink" title="对象引用问题 - 2"></a>对象引用问题 - 2</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeObjProperty</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.siteUrl = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">  o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.siteUrl = <span class="string">"http://www.google.com"</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> webSite = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">changeObjProperty(webSite);</span><br><span class="line"><span class="built_in">console</span>.log(webSite.siteUrl);</span><br></pre></td></tr></table></figure>

<p>答案： “<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com</a>“ 原因： o = new Object() 这句代码切断了原本对 o 的引用</p>
<h2 id="‘1’-‘2’-‘3’-map-parseInt-答案是多少？"><a href="#‘1’-‘2’-‘3’-map-parseInt-答案是多少？" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt) 答案是多少？"></a>[‘1’, ‘2’, ‘3’].map(parseInt) 答案是多少？</h2><p>答案 [1, NaN, NaN]</p>
<p>map会给函数传递3个参数： (elem, index, array)，当相与：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>(item, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>parseInt接收两个参数(string, radix)，其中radix代表进制。省略 radix 或 radix = 0，则数字将以十进制解析</p>
<p>因此，map 遍历 [“1”, “2”, “3”]，相应 parseInt 接收参数如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>);  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="考-Symbol"><a href="#考-Symbol" class="headerlink" title="考 Symbol"></a>考 Symbol</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">'123'</span>, c=<span class="number">123</span>;  </span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">'123'</span>), c=<span class="built_in">Symbol</span>(<span class="string">'123'</span>);  </span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">'123'</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">'456'</span>&#125;;  </span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">'123'</span>, c=<span class="number">123</span>;</span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉。</span></span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 c</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">'123'</span>), c=<span class="built_in">Symbol</span>(<span class="string">'123'</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// b 是 Symbol 类型，不需要转换。</span></span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。</span></span><br><span class="line">a[c]=<span class="string">'c'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 b</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">'123'</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">'456'</span>&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// b 不是字符串也不是 Symbol 类型，需要转换成字符串。</span></span><br><span class="line"><span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。</span></span><br><span class="line">a[b]=<span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 不是字符串也不是 Symbol 类型，需要转换成字符串。</span></span><br><span class="line"><span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。</span></span><br><span class="line">a[c]=<span class="string">'c'</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 c</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure>



<p>这个ToPrimitive可能不太好懂，我给你解释一下吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ToPrimitive(obj,preferredType)</span><br><span class="line"></span><br><span class="line">JS引擎内部转换为原始值ToPrimitive(obj,preferredType)函数接受两个参数，第一个obj为被转换的对象，第二个</span><br><span class="line">preferredType为希望转换成的类型（默认为空，接受的值为<span class="built_in">Number</span>或<span class="built_in">String</span>）</span><br><span class="line"></span><br><span class="line">在执行ToPrimitive(obj,preferredType)时如果第二个参数为空并且obj为<span class="built_in">Date</span>的事例时，此时preferredType会</span><br><span class="line">被设置为<span class="built_in">String</span>，其他情况下preferredType都会被设置为<span class="built_in">Number</span>如果preferredType为<span class="built_in">Number</span>，ToPrimitive执</span><br><span class="line">行过程如</span><br><span class="line">下：</span><br><span class="line"><span class="number">1.</span> 如果obj为原始值，直接返回；</span><br><span class="line"><span class="number">2.</span> 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；</span><br><span class="line"><span class="number">3.</span> 否则调用 obj.toString()，如果执行结果是原始值，返回之；</span><br><span class="line"><span class="number">4.</span> 否则抛异常。</span><br><span class="line"></span><br><span class="line">如果preferredType为<span class="built_in">String</span>，将上面的第<span class="number">2</span>步和第<span class="number">3</span>步调换，即：</span><br><span class="line"><span class="number">1.</span> 如果obj为原始值，直接返回；</span><br><span class="line"><span class="number">2.</span> 否则调用 obj.toString()，如果执行结果是原始值，返回之；</span><br><span class="line"><span class="number">3.</span> 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；</span><br><span class="line"><span class="number">4.</span> 否则抛异常。</span><br></pre></td></tr></table></figure>

<p>首先我们要明白 <strong>obj.valueOf()</strong> 和 <strong>obj.toString()</strong> 还有原始值分别是什么意思,这是弄懂上面描述的前提之一:</p>
<p><strong>toString用来返回对象的字符串表示。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString());<span class="comment">//[object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.toString());<span class="comment">//""空字符串</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date.toString());<span class="comment">//Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>

<p><strong>valueOf方法返回对象的原始值，可能是字符串、数值或bool值等，看具体的对象。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"obj"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.valueOf());<span class="comment">//Object &#123;name: "obj"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.valueOf());<span class="comment">//[1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date.valueOf());<span class="comment">//1456638436303</span></span><br><span class="line">如代码所示，三个不同的对象实例调用valueOf返回不同的数据</span><br></pre></td></tr></table></figure>

<p><strong>原始值指的是[‘Null’,’Undefined’,’String’,’Boolean’,’Number’,’Symbol’]6种基本数据类型之一</strong></p>
<p>最后分解一下其中的过程：<br>+new Date():</p>
<blockquote>
<ol>
<li>运算符new的优先级高于一元运算符+，所以过程可以分解为：<br> var time=new Date()；<pre><code>+time</code></pre></li>
</ol>
</blockquote>
<blockquote>
<p>2.根据上面提到的规则相当于：ToNumber(time)</p>
</blockquote>
<blockquote>
<p>3.time是个日期对象，根据ToNumber的转换规则，所以相当于：ToNumber(ToPrimitive(time))</p>
</blockquote>
<blockquote>
<p>4.根据ToPrimitive的转换规则：ToNumber(time.valueOf())，time.valueOf()就是 <strong>原始值</strong> 得到的是个时间戳，假设time.valueOf()=1503479124652</p>
</blockquote>
<blockquote>
<p>5.所以ToNumber(1503479124652)返回值是1503479124652这个数字。</p>
</blockquote>
<h1 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h1><h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><ul>
<li>Configurable：能否通过delete删除属性从而重新定义属性</li>
<li>Enumerable：表示能否通过for-in循环返回属性</li>
<li>Writable：表示能否修改属性的值</li>
<li>Value：属性的数据值，默认为undefined</li>
</ul>
<p>在调用Object.defineProperty()时，如果不指定，configurable、enumerable和writable特性的默认值都是false。</p>
<blockquote>
<p>IE8是第一个实现Object.defineProperty()方法的浏览器版本，但是问题多，如只能创建访问器属性，所以最好不要在IE8中使用这个方法。</p>
</blockquote>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><ul>
<li>Configurable</li>
<li>Enumerable</li>
<li>Get</li>
<li>Set</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book=&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2020</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> thie._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue &gt; <span class="number">2020</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2020</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述例子中_year、edition是数据属性，year是访问器属性。</p>
<p>可以通过<code>Object.getOwnPropertyDescriptor(object,属性名)</code>读取属性的特性</p>
<p><code>Object.hasOwnProperty()</code>可以检测一个属性是存在于实例中还是原型中。</p>
<p><code>in</code>操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</p>
<p><code>for-in</code>返回的是所有能够通过对象访问的、可枚举的属性</p>
<p><code>Object.keys()</code>返回对象上所有可枚举的实例属性。</p>
<p><code>Object.getOwnPropertyNames()</code>返回对象上所有的实例属性，无论可枚举不可枚举。</p>
<h1 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3.创建对象"></a>3.创建对象</h1><h2 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>缺点：对象无法识别，因为所有的实例都指向一个原型</p>
<h2 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2. 构造函数模式"></a>2. 构造函数模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>优点：实例可以识别为一个特定的类型</p>
<p>缺点：每次创建实例时，每个方法都要被创建一次</p>
<h2 id="2-1-构造函数模式优化"><a href="#2-1-构造函数模式优化" class="headerlink" title="2.1 构造函数模式优化"></a>2.1 构造函数模式优化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getName = getName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure>

<p>优点：解决了每个方法都要被重新创建的问题</p>
<p>缺点：这叫啥封装……</p>
<h2 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'keivn'</span>;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：方法不会重新创建</p>
<p>缺点：1. 所有的属性和方法都共享 2. 不能初始化参数</p>
<h2 id="3-1-原型模式优化"><a href="#3-1-原型模式优化" class="headerlink" title="3.1 原型模式优化"></a>3.1 原型模式优化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：封装性好了一点</p>
<p>缺点：重写了原型，丢失了constructor属性</p>
<h2 id="3-2-原型模式优化"><a href="#3-2-原型模式优化" class="headerlink" title="3.2 原型模式优化"></a>3.2 原型模式优化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'kevin',</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：实例可以通过constructor属性找到所属构造函数</p>
<p>缺点：原型模式该有的缺点还是有</p>
<h2 id="4-组合模式"><a href="#4-组合模式" class="headerlink" title="4. 组合模式"></a>4. 组合模式</h2><p>构造函数模式与原型模式双剑合璧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>优点：该共享的共享，该私有的私有，使用最广泛的方式</p>
<p>缺点：有的人就是希望全部都写在一起，即更好的封装性</p>
<h2 id="4-1-动态原型模式"><a href="#4-1-动态原型模式" class="headerlink" title="4.1 动态原型模式"></a>4.1 动态原型模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>注意：使用动态原型模式时，不能用对象字面量重写原型</p>
<p>解释下为什么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: Person,</span><br><span class="line">            getName: function () &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 并没有该方法</span></span><br><span class="line">person1.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释掉上面的代码，这句是可以执行的。</span></span><br><span class="line">person2.getName();</span><br></pre></td></tr></table></figure>

<p>为了解释这个问题，假设开始执行<code>var person1 = new Person(&#39;kevin&#39;)</code>。</p>
<blockquote>
<p>当执行 var person1 = new Person(‘kevin’) 的时候，person1.的原型并不是指向 Person.prototype，而是指向 Person.prototype 指向的原型对象，我们假设这个原型对象名字为 O, 然后再修改 Person.prototype 的值为一个字面量，只是将一个新的值赋值给 Person.prototype, 并没有修改 O 对象，也不会切断已经建立的 person1 和 O 的原型关系，访问 person.getName 方法，依然会从 O 上查找</p>
</blockquote>
<p>如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。</p>
<p>我们回顾下 new 的实现步骤：</p>
<ol>
<li>首先新建一个对象</li>
<li>然后将对象的原型指向 Person.prototype指向的对象</li>
<li>然后 Person.apply(obj)</li>
<li>返回这个对象</li>
</ol>
<p>注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！</p>
<p>如果你就是想用字面量方式写代码，可以尝试下这种：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: Person,</span><br><span class="line">            getName: function () &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line">person1.getName(); <span class="comment">// kevin</span></span><br><span class="line">person2.getName();  <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-寄生构造函数模式"><a href="#5-1-寄生构造函数模式" class="headerlink" title="5.1 寄生构造函数模式"></a>5.1 寄生构造函数模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>寄生构造函数模式，我个人认为应该这样读：</p>
<p>寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。</p>
<p>也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！</p>
<p>这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        values.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>);</span><br><span class="line"><span class="keyword">var</span> colors2 = SpecialArray(<span class="string">'red2'</span>, <span class="string">'blue2'</span>, <span class="string">'green2'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString()); <span class="comment">// red|blue|green</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors2);</span><br><span class="line"><span class="built_in">console</span>.log(colors2.toPipedString()); <span class="comment">// red2|blue2|green2</span></span><br></pre></td></tr></table></figure>

<p>你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。</p>
<p>但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。</p>
<p>在可以使用其他模式的情况下，不要使用这种模式。</p>
<p>但是值得一提的是，上面例子中的循环：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    values.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以替换成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">values.push.apply(values, arguments);</span><br></pre></td></tr></table></figure>

<h2 id="5-2-稳妥构造函数模式"><a href="#5-2-稳妥构造函数模式" class="headerlink" title="5.2 稳妥构造函数模式"></a>5.2 稳妥构造函数模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = person(<span class="string">'kevin'</span>);</span><br><span class="line"></span><br><span class="line">person1.sayName(); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">"daisy"</span>;</span><br><span class="line"></span><br><span class="line">person1.sayName(); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure>

<p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。</p>
<p>与寄生构造函数模式有两点不同：</p>
<ol>
<li>新创建的实例方法不引用 this</li>
<li>不使用 new 操作符调用构造函数</li>
</ol>
<p>稳妥对象最适合在一些安全的环境中。</p>
<p>稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。</p>
<p>类的声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'name'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'name'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-原型链与继承"><a href="#4-原型链与继承" class="headerlink" title="4.原型链与继承"></a>4.原型链与继承</h1><p>ES6之前中并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实例。构造函数和普通函数其实形式上一样，唯一区别是构造函数命名通常首字母是大写，并且调用的时候是new。</p>
<h3 id="一、普通对象和函数对象"><a href="#一、普通对象和函数对象" class="headerlink" title="一、普通对象和函数对象"></a>一、普通对象和函数对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">凡是通过 <span class="keyword">new</span> <span class="built_in">Function</span>() 创建的对象都是函数对象，其他的都是普通对象</span><br></pre></td></tr></table></figure>

<p>所有函数对象的<strong>proto</strong>都指向Function.prototype，它是一个空函数（Empty function）</p>
<p>函数对象包括：</p>
<blockquote>
<p>内置的函数对象：Array Date Number String等等</p>
<p>自定义函数对象：如function Person() {}; 此时Person就是函数对象</p>
</blockquote>
<p>这些构造器都是函数对象：</p>
<p><img src="/2020/01/18/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/2.png" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.constructor == <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">RegExp</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Error</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Date</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><code>Function.prototype</code>也是唯一一个<code>typeof XXX.prototype</code>为 <code>function</code>的<code>prototype</code>。其它的构造器的<code>prototype</code>都是一个对象</p>
<p><img src="/2020/01/18/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/5.png" alt></p>
<h3 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">//true</span></span><br><span class="line">实例的构造函数属性（<span class="keyword">constructor</span>）指向构造函数</span><br></pre></td></tr></table></figure>

<h3 id="三、原型对象"><a href="#三、原型对象" class="headerlink" title="三、原型对象"></a>三、原型对象</h3><p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 <code>prototype</code> 属性了。对于 ECMAScript 中的引用类型而言，<code>prototype</code> 是保存着它们所有实例方法的真正所在。换句话所说，诸如 <code>toString()</code>和 <code>valuseOf()</code> 等方法实际上都保存在 <code>prototype</code> 名下，只不过是通过各自对象的实例访问罢了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype</span><br><span class="line"><span class="comment">//es5的方法,可以获得对象的原型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性</span><br><span class="line">其中函数对象也有__proto__，因为函数对象是<span class="built_in">Function</span>的实例对象</span><br></pre></td></tr></table></figure>

<p>==<strong>prototype是函数才会有的属性</strong>==</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">   name:  <span class="string">'Zaxlct'</span>,</span><br><span class="line">   age: <span class="number">28</span>,</span><br><span class="line">   job: <span class="string">'Software Engineer'</span>,</span><br><span class="line">   sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     alert(<span class="keyword">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person.prototype就是原型对象,还有一个默认属性:constructor</span></span><br><span class="line"><span class="comment">//这个属性（是一个指针）指向 prototype 属性所在的函数（Person）</span></span><br></pre></td></tr></table></figure>

<p>==Person.prototype.constructor == Person==</p>
<h3 id="四、构造器"><a href="#四、构造器" class="headerlink" title="四、构造器"></a>四、构造器</h3><p>所有的构造器都来自于 <code>Function.prototype</code>，甚至包括根构造器<code>Object</code>及<code>Function</code>自身。所有构造器都继承了Function.prototype·的属性及方法。如length、call、apply、bind</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建对象的构造器不仅仅有 Object，也可以是 Array，Date，Function等。</span></span><br><span class="line"><span class="comment">//所以我们也可以构造函数来创建 Array、 Date、Function</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">b.constructor === <span class="built_in">Array</span>;</span><br><span class="line">b.__proto__ === <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line">c.constructor === <span class="built_in">Date</span>;</span><br><span class="line">c.__proto__ === <span class="built_in">Date</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">d.constructor === <span class="built_in">Function</span>;</span><br><span class="line">d.__proto__ === <span class="built_in">Function</span>.prototype;</span><br></pre></td></tr></table></figure>

<h3 id="五、原型链"><a href="#五、原型链" class="headerlink" title="五、原型链"></a>五、原型链</h3><ol>
<li><p><code>person1.__proto__</code> 是什么？</p>
<p> Person.prototype</p>
</li>
<li><p><code>Person.__proto__</code> 是什么？</p>
<p> Function.prototype</p>
</li>
<li><p><code>Person.prototype.__proto__</code> 是什么？</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。</span><br><span class="line">因为一个普通对象的构造函数 === <span class="built_in">Object</span></span><br><span class="line">所以Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.__proto__</code> 是什么？</p>
<p> Function.prototype</p>
<p> <strong>Object.<strong>proto</strong></strong> 可以理解为是一个指针，指向了构造函数的原型对象，由于Objec是一个构造函数，函数继承自Function.prototype,所以此处 Objec.<strong>proto</strong> === Function.prototype;</p>
<p> <strong>Object.prototype</strong> 是作为构造函数的Object的原型对象，比较有意思的是，由于Function.prototype也是一个对象，所以它也继承自Object,所以Function.prototype.<strong>proto</strong> === Object.prototype;</p>
<p> 所以，你要问他们有什么关系 Object.<strong>proto</strong>.<strong>proto</strong> === Object.prototype</p>
</li>
<li><p><code>Object.prototype__proto__</code> 是什么？</p>
<p> null</p>
</li>
<li><p><code>Function__proto__===Function.prototype</code>//true</p>
</li>
</ol>
<p><img src="/2020/01/18/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/1.png" alt></p>
<h3 id="六、原型的原型"><a href="#六、原型的原型" class="headerlink" title="六、原型的原型"></a>六、原型的原型</h3><p><img src="/2020/01/18/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/3.png" alt></p>
<p>蓝色的线就是<strong><code>原型链</code></strong>,原型链是通过<strong>proto</strong>来串起来的</p>
<p>==原型对象是通过Object构造函数生成的==</p>
<p>==<strong>null</strong>==有俩个用处:</p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象</li>
<li>作为对象原型链的终点==Object.getPrototypeOf(Object.prototype) //null==</li>
</ul>
<h3 id="七、补充"><a href="#七、补充" class="headerlink" title="七、补充"></a>七、补充</h3><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//这里其实person中并没有constructor属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性</span></span><br><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>

<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h4 id="真的是继承吗"><a href="#真的是继承吗" class="headerlink" title="真的是继承吗?"></a>真的是继承吗?</h4><p>一般我们所说”每一个对象都会从原型’继承’属性”,然而继承意味着复制操作,但是Javascript默认不会复制对象的属性,相反,Javascript只是在俩个对象之间创建一个关联,这样,一个对象就可以通过委托访问另一个对象的属性和函数,所以与其叫继承，委托的说法反而更准确些。</p>
<h3 id="八、梳理流程"><a href="#八、梳理流程" class="headerlink" title="八、梳理流程"></a>八、梳理流程</h3><p>JS对象的圈子里有这么个游戏规则:</p>
<blockquote>
<p>如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.</p>
</blockquote>
<p>如果让原型对象指向另一个类型的实例…..有趣的事情便发生了.</p>
<p>即: constructor1.prototype = instance2</p>
<p>鉴于上述游戏规则生效,如果试图引用constructor1构造的实例instance1的某个属性p1:</p>
<p>1).首先会在instance1内部属性中找一遍;</p>
<p>2).接着会在instance1.<strong>proto</strong>(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;</p>
<p>3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.<strong>proto</strong>(constructor2.prototype)中寻找…直至Object的原型对象</p>
<blockquote>
<p>搜索轨迹: instance1–&gt; instance2 –&gt; constructor2.prototype…–&gt;Object.prototype</p>
</blockquote>
<p>这种搜索的轨迹,形似一条长链, 又因prototype在这个游戏规则中充当链接的作用,于是我们把这种实例与原型的链条称作 <strong>原型链</strong> . 下面有个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sonProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承 Father</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//Son.prototype被重写,导致Son.prototype.constructor也一同被重写</span></span><br><span class="line">Son.prototype.getSonVaule = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sonProperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance.getFatherValue());<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>instance实例通过原型链找到了Father原型中的getFatherValue方法.</p>
<p>注意: 此时instance.constructor指向的是Father,这是因为Son.prototype中的constructor被重写的缘故.</p>
<p>判断原型与实例的这种继承关系:</p>
<blockquote>
<p>第一种是使用 <strong>instanceof</strong> 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回true.</p>
<p>判断实例对象的<strong>proto</strong>属性与构造函数的prototype是不是用一个引用。如果不是，他会沿着对象的<strong>proto</strong>向上查找的，直到顶端Object。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> Father);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> Son);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二种是使用 <strong>isPrototypeOf()</strong> 方法, 同样只要是原型链中出现过的原型,isPrototypeOf() 方法就会返回true, 如下所示.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(Father.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(Son.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h4><blockquote>
<p>原理：把子类的prototype（原型对象）直接设置为父类的实例</p>
<p>缺点：因为子类只进行一次原型更改，所以子类的所有实例保存的是同一个父类的值。 当子类对象上进行值修改时，如果是修改的原始类型的值，那么会在实例上新建这样一个值； 但如果是引用类型的话，他就会去修改子类上唯一一个父类实例里面的这个引用类型，这会影响所有子类实例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'kevin'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// kevin</span></span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：</p>
<ol>
<li><p>当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">'kevin'</span>, <span class="string">'daisy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'yayu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数。实际上没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
</li>
</ol>
<p>因为子类只进行一次原型更改，所以子类的所有实例保存的是同一个父类的值。 当子类对象上进行值修改时，如果是修改的原始类型的值，那么会在实例上新建这样一个值； 但如果是引用类型的话，他就会去修改子类上唯一一个父类实例里面的这个引用类型，这会影响所有子类实例</p>
<p>有鉴于此, 实践中很少会单独使用原型链。</p>
<p>为此,下面将有一些尝试以弥补原型链的不足。</p>
<h4 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h4><blockquote>
<p>基本思想:在子类构造函数中 使用<code>Parent.call(this)</code>的方法继承父类属性。</p>
<p>原理： 将子类的this使用父类的构造函数跑一遍</p>
<p>缺点： Parent原型链上的属性和方法并不会被子类继承</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>);<span class="comment">//继承了Father,且向父类型传递参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red,blue,green" 可见引用类型值是独立的</span></span><br></pre></td></tr></table></figure>

<p>很明显,借用构造函数一举解决了原型链的两大问题:</p>
<p>其一, 保证了原型链中引用类型值的独立,不再被所有实例共享;</p>
<p>其二, 子类型创建时也能够向父类型传递参数.</p>
<p>随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Father)中定义的方法,对子类型而言也是不可见的。考虑此,借用构造函数的技术也很少单独使用.</p>
<p>缺点:</p>
<ul>
<li>方法都在构造函数中定义，每次创建实例都会创建一遍方法</li>
<li>只能继承父类实例的属性和方法，不能继承原型上的属性和方法</li>
</ul>
<h4 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h4><blockquote>
<p>基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</p>
<p>组合构造函数中使用call继承和原型链继承。</p>
<p>原理： 子类构造函数中使用<code>Parent.call(this);</code>的方式可以继承写在父类构造函数中this上绑定的各属性和方法； 使用<code>Child.prototype = new Parent()</code>的方式可以继承挂在在父类原型上的各属性和方法</p>
<p>缺点： 父类构造函数在子类构造函数中执行了一次，在子类绑定原型时又执行了一次</p>
</blockquote>
<p>这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下所示.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,name);<span class="comment">//继承实例属性，第一次调用Father()</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//继承父类方法,第二次调用Father()</span></span><br><span class="line">Son.prototype.contructor = Son;</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName();<span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中最常用的继承模式. 而且, instanceof 和 isPrototypeOf( )也能用于识别基于组合继承创建的对象.</p>
<p>同时我们还注意到组合继承其实==调用了两次父类构造函数==, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢, 这个我们将在后面讲到.</p>
<h5 id="3-1-组合继承优化1："><a href="#3-1-组合继承优化1：" class="headerlink" title="3.1 组合继承优化1："></a>3.1 组合继承优化1：</h5><p>因为这时父类构造函数的方法已经被执行过了，只需要关心原型链上的属性和方法了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Son.prototype = Father.prototype;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>因为原型上有一个属性为<code>constructor</code>，此时直接使用父类的prototype的话那么会导致 实例的constructor为Father，即不能区分这个实例对象是Son的实例还是父类的实例对象。</li>
<li>子类不可直接在prototype上添加属性和方法，因为会影响父类的原型</li>
</ul>
<p><code>注意：这个时候instanceof是可以判断出实例为Son的实例的，因为instanceof的原理是沿着对象的__proto__判断是否有一个原型是等于该构造函数的原型的。这里把Son的原型直接设置为了父类的原型，那么: 实例.__proto__ === Son.prototype === Father.prototype</code></p>
<h5 id="3-2组合继承方式-优化2-添加中间对象【最通用版本】："><a href="#3-2组合继承方式-优化2-添加中间对象【最通用版本】：" class="headerlink" title="3.2组合继承方式 优化2 - 添加中间对象【最通用版本】："></a>3.2组合继承方式 优化2 - 添加中间对象【最通用版本】：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'child'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype); <span class="comment">//提供__proto__</span></span><br><span class="line">Child.prototype.constrctor = Child;</span><br></pre></td></tr></table></figure>

<p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong></p>
<h4 id="封装一个原生的继承方法"><a href="#封装一个原生的继承方法" class="headerlink" title="封装一个原生的继承方法"></a>封装一个原生的继承方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">Parent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">Child</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendsClass</span>(<span class="params">Parent, Child</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = Parent.prototype</span><br><span class="line">  Child.prototype = <span class="keyword">new</span> F()</span><br><span class="line">  Child.prototype.constrctor = Child</span><br><span class="line">  <span class="keyword">return</span> Child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h4><p>该方法最初由道格拉斯·克罗克福德于2006年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript中的原型式继承) 的文章中提出. 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型. 大意如下：</p>
<blockquote>
<p>原理：就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p>
<p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从本质上讲, object() 对传入其中的对象执行了一次浅复制. 下面我们来看看为什么是浅复制.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line">alert(person.friends);<span class="comment">//"Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中,可以作为另一个对象基础的是person对象,于是我们把它传入到object()函数中,然后该函数就会返回一个新对象. 这个新对象将person作为原型,因此它的原型中就包含引用类型值属性. 这意味着</p>
<p>person.friends不仅属于person所有,而且也会被anotherPerson以及yetAnotherPerson共享.</p>
<p>在 ECMAScript5 中,通过新增 <strong>Object.create()</strong> 方法规范化了上面的原型式继承.</p>
<p><strong>Object.create()</strong> 接收两个参数:</p>
<ul>
<li>一个用作新对象原型的对象</li>
<li>(可选的)一个为新对象定义额外属性的对象</li>
</ul>
<p><strong>Object.create()</strong> 只有一个参数时功能与上述object方法相同, 它的第二个参数与Object.defineProperties()方法的第二个参数格式相同: 每个属性都是通过自己的描述符定义的.以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"Van"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name : &#123;</span><br><span class="line">        value : <span class="string">"Louis"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);<span class="comment">//"Louis"</span></span><br></pre></td></tr></table></figure>

<p>目前支持 <strong>Object.create()</strong> 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome.</p>
<p><strong>提醒:</strong> 原型式继承中, 包含引用类型值的属性始终都会共享相应的值, 就像使用原型模式一样.</p>
<h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h4><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h4 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h4><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure>

<p>组合继承最大的缺点是会调用两次父构造函数。</p>
<p>一次是设置子类型实例的原型的时候：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>

<p>一次在创建子类型实例的时候：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br></pre></td></tr></table></figure>

<p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Parent.call(<span class="keyword">this</span>, name);</span><br></pre></td></tr></table></figure>

<p>在这里，我们又会调用了一次 Parent 构造函数。</p>
<p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p>
<p>那么我们该如何精益求精，避免这一次重复调用呢？</p>
<p>如果我们不使用 Child.prototype = new Parent() ，而是==间接的让 Child.prototype 访问到 Parent.prototype== 呢？</p>
<p>看看如何实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="comment">// var F = function () &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// F.prototype = Parent.prototype;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.prototype = new F();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> temp = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line">temp.constructor = Child</span><br><span class="line">Child.prototype = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>

<p>最后我们封装一下这个继承方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(parent.prototype);</span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure>

<p>为什么不让 Child.prototype 直接访问到 Parent.prototype ？一定要通过寄生的方式呢。。。</p>
<blockquote>
<p>你这样的话，增加 Child.prototype.testProp = 1; 同时会影响 Parent.prototype 的<br>如果不模拟，直接上 es5 的话应该是下面这样吧<br>Child.prototype = Object.create(Parent.prototype);</p>
</blockquote>
<p>关键在于直接访问的时候，会产生多余的属性值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="/2020/01/18/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/4.png" alt></p>
<p>你会发现有两个 [‘red’, ‘blue’, ‘green’] 数组，实际上，Parent 中的那个是没有必要的</p>
<p>为了避免这种情况，才采用了间接调用</p>
<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h3 id="ES5-ES6-的继承除了写法以外还有什么区别？"><a href="#ES5-ES6-的继承除了写法以外还有什么区别？" class="headerlink" title="ES5/ES6 的继承除了写法以外还有什么区别？"></a>ES5/ES6 的继承除了写法以外还有什么区别？</h3><ul>
<li>class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。</li>
<li>class 声明内部会启用严格模式。</li>
<li>class 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li>
<li>class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。</li>
<li>必须使用 new 调用 class。</li>
<li>class 内部无法重写类名。</li>
</ul>
<h3 id="js中new和object-create区别"><a href="#js中new和object-create区别" class="headerlink" title="js中new和object.create区别"></a>js中new和object.create区别</h3><h3 id="下面的代码会输出什么？"><a href="#下面的代码会输出什么？" class="headerlink" title="下面的代码会输出什么？"></a>下面的代码会输出什么？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span></span><br><span class="line">  <span class="keyword">this</span>.msg = <span class="string">"use 'this.' set in function"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">B.prototype = A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b.name);</span><br><span class="line"><span class="built_in">console</span>.log(b.msg);</span><br></pre></td></tr></table></figure>

<p>答案是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>b.name</code>返回 <code>A</code>，是因为<code>b</code>上面没有<code>name</code>属性，他就会沿着原型链向上查找，然而 <code>b.__proto__</code> 为<code>函数A</code>，每一个函数都有一个属性为name，其值是函数的名字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* 这是一个名为'abc'的函数 */</span> &#125;</span><br><span class="line">abc.name <span class="comment">// -&gt; 'abc'</span></span><br></pre></td></tr></table></figure>

<p><code>b.msg</code> 为什么是<code>undefined</code>哪？ 因为<code>b.__proto__</code> 是 <code>函数A</code>，那怎么修改才能拿到<code>msg</code>哪？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">B.prototype = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>修改后的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tom</span><br><span class="line">VM731:12 use &#39;this.&#39; set in function</span><br></pre></td></tr></table></figure>



<h1 id="5-this"><a href="#5-this" class="headerlink" title="5.this"></a>5.this</h1><h2 id="this的指向有哪几种情况"><a href="#this的指向有哪几种情况" class="headerlink" title="this的指向有哪几种情况"></a>this的指向有哪几种情况</h2><blockquote>
<p>this代表函数调用相关联的对象，通常也称之为执行上下文</p>
</blockquote>
<ol>
<li>作为函数直接调用，非严格模式下，this指向window，严格模式下，this指向undefined</li>
<li>作为某对象的方法调用，this通常指向调用的对象</li>
<li>使用apply、call、bind 可以绑定this的指向</li>
<li>在构造函数中，this指向新创建的对象</li>
<li>箭头函数没有单独的this值，this在箭头函数创建时确定，它与声明所在的上下文相同</li>
</ol>
<h2 id="如果对一个函数进行多次-bind，那么上下文会是什么呢？"><a href="#如果对一个函数进行多次-bind，那么上下文会是什么呢？" class="headerlink" title="如果对一个函数进行多次 bind，那么上下文会是什么呢？"></a>如果对一个函数进行多次 bind，那么上下文会是什么呢？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// =&gt; ?</span></span><br></pre></td></tr></table></figure>

<p>不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply()</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>

<h2 id="多个this规则出现时，this最终指向哪里？"><a href="#多个this规则出现时，this最终指向哪里？" class="headerlink" title="多个this规则出现时，this最终指向哪里？"></a>多个this规则出现时，this最终指向哪里？</h2><p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 </p>
<p><img src="/2020/01/18/JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/8.jpg" alt></p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName();      <span class="comment">//-&gt; 2    Foo对象上的getName() ，这里不会是3，因为只有Foo的实例对象才会是3，Foo上面是没有3的</span></span><br><span class="line">getName();          <span class="comment">//-&gt; 4    window上的getName，console.log(5)的那个函数提升后，在console.log(4)的那里被重新赋值</span></span><br><span class="line">Foo().getName();    <span class="comment">//-&gt; 1    在Foo函数中，getName是全局的getName，覆盖后输出 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName();  <span class="comment">//-&gt; 2    Foo后面不带括号而直接 '.'，那么点的优先级会比new的高，所以把 Foo.getName 作为构造函数</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName();<span class="comment">//-&gt; 3    此时是Foo的实例，原型上会有输出3这个方法</span></span><br></pre></td></tr></table></figure>



<p>箭头函数里面的this是继承它作用域父级的this， 即声明箭头函数处的this</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) </span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.b()   <span class="comment">// a</span></span><br><span class="line">a.c()   <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = a.b</span><br><span class="line">d()     <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="string">'kin'</span>;</span><br><span class="line">    <span class="keyword">let</span> a = &#123;</span><br><span class="line">        name1: <span class="string">'jack'</span>,</span><br><span class="line">        fn: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> name1 = <span class="string">'black'</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().fn() <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>答案： 输出1</p>
<p>因为fn处绑定的是箭头函数，箭头函数并不创建this，它只会从自己的作用域链的上一层继承this。这里它的上一层是test()，非严格模式下test中this值为window。</p>
<ul>
<li>如果在绑定fn的时候使用了function，那么答案会是 ‘jack’</li>
<li>如果第一行的 var 改为了 let，那么答案会是 undefind， 因为let不会挂到window上</li>
</ul>
<h1 id="6-作用域和作用域链"><a href="#6-作用域和作用域链" class="headerlink" title="6.作用域和作用域链"></a>6.作用域和作用域链</h1><h2 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h2><p>作用域是指程序源代码中定义变量的区域。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
<h2 id="二、静态作用域与动态作用域"><a href="#二、静态作用域与动态作用域" class="headerlink" title="二、静态作用域与动态作用域"></a>二、静态作用域与动态作用域</h2><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p>
<p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>接下来看俩段代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure>

<p>结果都是<code>local scope</code></p>
<p>JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。</p>
<blockquote>
<p>Like most modern programming languages, JavaScript uses <code>lexical scoping</code>. This means that <code>functions are executed using the variable scope that was in effect when they were defined</code>, not the variable scope that is in effect when they are invoked. In order to implement lexical scoping, the internal state of a JavaScript function object must in- clude not only the code of the function but also a reference to the current scope chain. (Before reading the rest of this section, you may want to review the material on variable scope and the scope chain in §3.10 and §3.10.3.) This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. (This is an old term that refers to the fact that the function’s variables have bindings in the scope chain and that therefore the function is “closed over” its variables.)</p>
</blockquote>
<blockquote>
<p>Technically, all JavaScript functions are closures: they are objects, and they have a scope chain associated with them. Most functions are invoked using the same scope chain that was in effect when the function was defined, and it doesn’t really matter that there is a closure involved. Closures become interesting when they are invoked under a different scope chain than the one that was in effect when they were defined. This happens most commonly when a nested function object is returned from the function within which it was defined. There are a number of powerful programming techniques that involve this kind of nested function closures, and their use has become relatively common in JavaScript programming. Closures may seem confusing when you first en- counter them, but it is important that you understand them well enough to use them comfortably.</p>
</blockquote>
<blockquote>
<p>JavaScript, The Definite Guide</p>
</blockquote>
<p>核心就是: <code>函数的作用域在函数定义的时候就决定了</code></p>
<p>翻译成中文的话也许是这样：</p>
<p>和大多数的现代化编程语言一样，<code>JavaScript</code>是采用词法作用域的，这就意味着函数的执行依赖于函数定义的时候所产生（而不是函数调用的时候产生的）的变量作用域。为了去实现这种词法作域，<code>JavaScript</code>函数对象的内部状态不仅包含函数逻辑的代码，除此之外还包含当前作用域链的引用。函数对象可以通过这个作用域链相互关联起来，如此，函数体内部的变量都可以保存在函数的作用域内，这在计算机的文献中被称之为闭包。</p>
<p>从技术的角度去将，所有的<code>JavaScript</code>函数都是闭包：他们都是对象，他们都有一个关联到他们的作用域链。绝大多数函数在调用的时候使用的作用域链和他们在定义的时候的作用域链是相同的，但是这并不影响闭包。当调用函数的时候闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链的时候，闭包become interesting。这种interesting的事情往往发生在这样的情况下： 当一个函数嵌套了另外的一个函数，外部的函数将内部嵌套的这个函数作为对象返回。一大批强大的编程技术都利用了这类嵌套的函数闭包，当然，<code>javascript</code>也是这样。可能你第一次碰见闭包觉得比较难以理解，但是去明白闭包然后去非常自如的使用它是非常重要的。</p>
<p>通俗点说，在程序语言范畴内的闭包是指函数把其的变量作用域也包含在这个函数的作用域内，形成一个所谓的“闭包”，这样的话外部的函数就无法去访问内部变量。所以按照第二段所说的，严格意义上所有的函数都是闭包。</p>
<p>需要注意的是：我们常常所说的闭包指的是让外部函数访问到内部的变量，也就是说，按照一般的做法，是使内部函数返回一个函数，然后操作其中的变量。这样做的话一是可以读取函数内部的变量，二是可以让这些变量的值始终保存在内存中。</p>
<p><code>JavaScript</code>利用闭包的这个特性，就意味着当前的作用域总是能够访问外部作用域中的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">     a:<span class="number">11</span>,</span><br><span class="line">     b:&#123;</span><br><span class="line">         fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(a);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果是 10 ，因为变量 a 并不能读取到对象 o 的属性 a ，如果 console.log(o.a)，就会打印 11，函数 fn 的作用域链为 [AO, Global.VO]，而 Global.VO 中包括了变量 a 和变量 o。</p>
</blockquote>
<h2 id="三、执行上下文栈"><a href="#三、执行上下文栈" class="headerlink" title="三、执行上下文栈"></a>三、执行上下文栈</h2><p>JavaScript 的可执行代码(executable code)的类型有哪些了？</p>
<blockquote>
<p>全局代码、函数代码、eval代码</p>
</blockquote>
<p>当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。</p>
<p>Javascript开始解释执行代码时,最先遇到的就是全局代码,用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>此时遇到如下代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fun3'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure>

<p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1()</span></span><br><span class="line">ECStack.push(<span class="xml"><span class="tag">&lt;<span class="name">fun1</span>&gt;</span> functionContext);</span></span><br><span class="line"></span><br><span class="line"><span class="xml">// fun1中竟然调用了fun2，还要创建fun2的执行上下文</span></span><br><span class="line">ECStack.push(&lt;fun2&gt; functionContext);</span><br><span class="line"></span><br><span class="line">// 擦，fun2还调用了fun3！</span><br><span class="line">ECStack.push(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line">// fun3执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// fun2执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// fun1执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span><br></pre></td></tr></table></figure>

<p>对于每个执行上下文都有三个重要属性:</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p><strong>一个执行上下文的生命周期可以分为两个阶段。</strong></p>
<ol>
<li>创建阶段</li>
</ol>
<blockquote>
<p>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。</p>
</blockquote>
<ol start="2">
<li>代码执行阶段</li>
</ol>
<blockquote>
<p>创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。</p>
</blockquote>
<h3 id="1-变量对象"><a href="#1-变量对象" class="headerlink" title="1.变量对象"></a>1.变量对象</h3><p>变量对象的创建是在EC(执行上下文)的创建阶段</p>
<p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：</p>
<ol>
<li>进入执行上下文</li>
<li>代码执行</li>
</ol>
<h5 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h5><p>当进入执行上下文时，这时候还没有执行代码，</p>
<p>变量对象会包括：</p>
<ol>
<li>函数的所有形参 (如果是函数上下文)<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 undefined</li>
</ul>
</li>
<li>函数声明<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
</li>
<li>变量声明<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li>
</ul>
</li>
</ol>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在进入执行上下文后，这时候的 AO 是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h5><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p>
<p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p>
<ol>
<li>全局上下文的变量对象初始化是全局对象</li>
<li>函数上下文的变量对象初始化只包括 Arguments 对象</li>
<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li>
<li>在代码执行阶段，会再次修改变量对象的属性值</li>
</ol>
<p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p>
<p><strong>AO = VO + function parameters + arguments</strong></p>
<p>未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
<p>它们其实都是同一个对象，只是处于执行上下文的不同生命周期。</p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>1.第一题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>

<p>第一段会报错：<code>Uncaught ReferenceError: a is not defined</code>。</p>
<p>第二段会打印：<code>1</code>。</p>
<p>这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</p>
<p>第一段执行 console 的时候， AO 的值是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        length: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</p>
<p>当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。</p>
<p>2.第二题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>会打印函数，而不是 undefined 。</p>
<p>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p>
<p>3.第三题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的1</p>
<p>执行上下文的生命周期可以分为两个阶段(也就是这段代码从开始到结束经历的过程)。</p>
<ul>
<li><strong>创建阶段</strong><br>  在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向</li>
<li><strong>代码执行阶段</strong><br>  创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。</li>
</ul>
<p><strong>这里我们先重点了解执行上下文中变量对象的创建。</strong></p>
<p>变量对象的创建，依次经历了以下几个过程。</p>
<ol>
<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值(全局环境下没有这步)。</li>
<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。<strong>如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</strong></li>
<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。<strong>如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</strong>(上面的例子就属于这种情况，foo函数名与变量foo同名)</li>
</ol>
<p><strong>在上面的规则中我们看出，function声明会比var声明优先级更高一点。</strong></p>
<p>我们直接从全局执行上下文开始理解。全局作用域中运行时，全局执行上下文开始创建。为了便于理解，我们用如下的形式来表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建过程</span><br><span class="line">global:EC = &#123;</span><br><span class="line">    <span class="comment">// 变量对象</span></span><br><span class="line">    VO: &#123;&#125;,</span><br><span class="line">    scopeChain: &#123;&#125;,</span><br><span class="line">    <span class="keyword">this</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为暂时不详细解释作用域链和this，所以把变量对象专门提出来说明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// VO 为 Variable Object的缩写，即变量对象</span></span><br><span class="line">VO = &#123;</span><br><span class="line">    foo: <span class="xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">reference</span>&gt;</span>  // 表示foo的地址引用</span></span><br><span class="line"><span class="xml">   // foo: undefined</span></span><br><span class="line"><span class="xml">(如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。这个过程已被忽略)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line">VO -&gt;  AO   <span class="comment">// Active Object</span></span><br><span class="line">AO = &#123;</span><br><span class="line">    foo: <span class="number">1</span>(此时函数已被重新赋值)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，上面的代码，执行顺序就变成了这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br></pre></td></tr></table></figure>

<p>所以最后打印的是1.</p>
<h3 id="2-作用域链"><a href="#2-作用域链" class="headerlink" title="2.作用域链"></a>2.作用域链</h3><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
<h4 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h4><p>函数的作用域在函数定义的时候就决定了。</p>
<p>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数创建时，各自的[[scope]]为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h4><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。</p>
<p>这时候执行上下文的作用域链，我们命名为 Scope：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure>

<p>至此，作用域链创建完毕。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope2 = <span class="string">'local scope'</span>;</span><br><span class="line">    <span class="keyword">return</span> scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>执行过程如下：</p>
<p>1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkscope.[[scope]] &#x3D; [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: &#39;local scope&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>



<p>checkscope函数创建的时候，保存的是根据词法所生成的作用域链，checkscope执行的时候，会复制这个作用域链，作为自己作用域链的初始化，然后根据环境生成变量对象，然后将这个变量对象，添加到这个复制的作用域链，这才完整的构建了自己的作用域链。至于为什么会有两个作用域链，是因为在函数创建的时候并不能确定最终的作用域的样子，为什么会采用复制的方式而不是直接修改呢？应该是因为函数会被调用很多次吧。</p>
<p>在源代码中当你定义（书写）一个函数的时候（并未调用），js引擎也能根据你函数书写的位置，函数嵌套的位置，给你生成一个[[scope]]，作为该函数的属性存在（这个属性属于函数的）。即使函数不调用，所以说==基于词法作用域（静态作用域）==。</p>
<p>然后进入函数执行阶段，生成执行上下文，执行上下文你可以宏观的看成一个对象，（包含vo,scope,this），此时，执行上下文里的scope和之前属于函数的那个[[scope]]不是同一个，执行上下文里的scope，是在之前函数的[[scope]]的基础上，又新增一个当前的AO对象构成的。</p>
<p>函数定义时候的[[scope]]和函数执行时候的scope，前者作为函数的属性，后者作为函数执行上下文的属性。</p>
<h3 id="3-this"><a href="#3-this" class="headerlink" title="3.this"></a>3.this</h3><h4 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h4><p>首先是第 8 章 Types：</p>
<blockquote>
<p>Types are further subclassified into ECMAScript language types and specification types.</p>
</blockquote>
<blockquote>
<p>An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.</p>
</blockquote>
<blockquote>
<p>A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record.</p>
</blockquote>
<p>我们简单的翻译一下：</p>
<p>ECMAScript 的类型分为语言类型和规范类型。</p>
<p>ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。</p>
<p>而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。</p>
<p>没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。</p>
<p>今天我们要讲的重点是便是其中的 Reference 类型。它与 this 的指向有着密切的关联。</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>那什么又是 Reference ？</p>
<p>让我们看 8.7 章 The Reference Specification Type：</p>
<blockquote>
<p>The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators.</p>
</blockquote>
<p>所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。</p>
<p>抄袭尤雨溪大大的话，就是：</p>
<blockquote>
<p>这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。</p>
</blockquote>
<p>再看接下来的这段具体介绍 Reference 的内容：</p>
<blockquote>
<p>A Reference is a resolved name binding.</p>
</blockquote>
<blockquote>
<p>A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.</p>
</blockquote>
<blockquote>
<p>The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1).</p>
</blockquote>
<blockquote>
<p>A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.</p>
</blockquote>
<p>这段讲述了 Reference 的构成，由三个组成部分，分别是：</p>
<ul>
<li>==base value==</li>
<li>==referenced name==</li>
<li>==strict reference==</li>
</ul>
<p>可是这些到底是什么呢？</p>
<p>我们简单的理解的话：</p>
<p>base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。</p>
<p>referenced name 就是属性的名称。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对应的Reference是：</span><br><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); &#x2F;&#x2F; foo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; bar对应的Reference是：</span><br><span class="line">var BarReference &#x3D; &#123;</span><br><span class="line">    base: foo,</span><br><span class="line">    propertyName: &#39;bar&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。</p>
<p>这两个方法很简单，简单看一看：</p>
<p>1.GetBase</p>
<blockquote>
<p>GetBase(V). Returns the base value component of the reference V.</p>
</blockquote>
<p>返回 reference 的 base value。</p>
<p>2.IsPropertyReference</p>
<blockquote>
<p>IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.</p>
</blockquote>
<p>简单的理解：如果 base value 是一个对象，就返回true。</p>
<h4 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h4><p>除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。</p>
<p>简单模拟 GetValue 的使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GetValue(fooReference) &#x2F;&#x2F; 1;</span><br></pre></td></tr></table></figure>

<p>GetValue 返回对象属性真正的值，但是要注意：</p>
<p><strong>调用 GetValue，返回的将是具体的值，而不再是一个 Reference</strong></p>
<p>这个很重要，这个很重要，这个很重要。</p>
<h4 id="如何确定this的值"><a href="#如何确定this的值" class="headerlink" title="如何确定this的值"></a>如何确定this的值</h4><p>关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段：</p>
<p>看规范 11.2.3 Function Calls：</p>
<p>这里讲了当函数调用的时候，如何确定 this 的取值。</p>
<p>只看第一步、第六步、第七步：</p>
<blockquote>
<p>1.Let <em>ref</em> be the result of evaluating MemberExpression.</p>
</blockquote>
<blockquote>
<p>6.If Type(<em>ref</em>) is Reference, then</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.If IsPropertyReference(ref) is true, then</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i.Let thisValue be GetBase(ref).</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b.Else, the base of ref is an Environment Record</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref).</span><br></pre></td></tr></table></figure>

<p>7.Else, Type(<em>ref</em>) is not Reference.</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a. Let thisValue be undefined.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>让我们描述一下：</p>
<p>1.计算 MemberExpression 的结果赋值给 ref</p>
<p>2.判断 ref 是不是一个 Reference 类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</span><br><span class="line"></span><br><span class="line">2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</span><br><span class="line"></span><br><span class="line">2.3 如果 ref 不是 Reference，那么 this 的值为 undefined</span><br></pre></td></tr></table></figure>

<h4 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h4><p>让我们一步一步看：</p>
<ol>
<li>计算 MemberExpression 的结果赋值给 ref</li>
</ol>
<p>什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions：</p>
<p>MemberExpression :</p>
<ul>
<li>PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》</li>
<li>FunctionExpression // 函数定义表达式</li>
<li>MemberExpression [ Expression ] // 属性访问表达式</li>
<li>MemberExpression . IdentifierName // 属性访问表达式</li>
<li>new MemberExpression Arguments // 对象创建表达式</li>
</ul>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// MemberExpression 是 foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); <span class="comment">// MemberExpression 是 foo()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// MemberExpression 是 foo.bar</span></span><br></pre></td></tr></table></figure>

<p>所以简单理解 MemberExpression 其实就是()左边的部分。</p>
<p>2.判断 ref 是不是一个 Reference 类型。</p>
<p>关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。</p>
<p>举最后一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar());</span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar)());</span><br><span class="line"><span class="comment">//示例3</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar = foo.bar)());</span><br><span class="line"><span class="comment">//示例4</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">false</span> || foo.bar)());</span><br><span class="line"><span class="comment">//示例5</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar, foo.bar)());</span><br></pre></td></tr></table></figure>

<h5 id="foo-bar"><a href="#foo-bar" class="headerlink" title="foo.bar()"></a>foo.bar()</h5><p>在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？</p>
<p>查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步：</p>
<blockquote>
<p>Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict.</p>
</blockquote>
<p>我们得知该表达式返回了一个 Reference 类型！</p>
<p>根据之前的内容，我们知道该值为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Reference &#x3D; &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: &#39;bar&#39;,</span><br><span class="line">  strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来按照 2.1 的判断流程走：</p>
<blockquote>
<p>2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p>
</blockquote>
<p>该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？</p>
<p>前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。</p>
<p>base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。</p>
<p>这个时候我们就可以确定 this 的值了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this &#x3D; GetBase(ref)，</span><br></pre></td></tr></table></figure>

<p>GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！</p>
<p>唉呀妈呀，为了证明 this 指向foo，真是累死我了！但是知道了原理，剩下的就更快了。</p>
<h5 id="foo-bar-foo-bar"><a href="#foo-bar-foo-bar" class="headerlink" title="(foo.bar = foo.bar)()"></a>(foo.bar = foo.bar)()</h5><p>看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = ):</p>
<p>计算的第三步：</p>
<blockquote>
<p>3.Let rval be GetValue(rref).</p>
</blockquote>
<p>因为使用了 GetValue，所以返回的值不是 Reference 类型，</p>
<p>按照之前讲的判断逻辑：</p>
<blockquote>
<p>2.3 如果 ref 不是Reference，那么 this 的值为 undefined</p>
</blockquote>
<p>this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。</p>
<h5 id="false-foo-bar"><a href="#false-foo-bar" class="headerlink" title="(false || foo.bar)()"></a>(false || foo.bar)()</h5><p>看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators：</p>
<p>计算第二步：</p>
<blockquote>
<p>2.Let lval be GetValue(lref).</p>
</blockquote>
<p>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</p>
<h5 id="揭晓结果"><a href="#揭晓结果" class="headerlink" title="揭晓结果"></a>揭晓结果</h5><p>所以最后一个例子的结果是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar()); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar)()); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//示例3</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar = foo.bar)()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//示例4</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">false</span> || foo.bar)()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//示例5</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar, foo.bar)()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。</p>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>最最后，忘记了一个最最普通的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: <span class="string">'foo'</span>,</span><br><span class="line">    strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来进行判断：</p>
<blockquote>
<p>2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p>
</blockquote>
<p>因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。</p>
<p>IsPropertyReference(ref) 的结果为 false，进入下个判断：</p>
<blockquote>
<p>2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</p>
</blockquote>
<p>base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref)</p>
<p>查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。</p>
<p>所以最后 this 的值就是 undefined。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">1</span>);					</span><br><span class="line">        &#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo().getName();</span><br></pre></td></tr></table></figure>

<p>Foo()函数返回的this指window对吧，然后Foo().getName()，不就是指window.getName()吗，所以执行结果应该是5呀？</p>
<blockquote>
<p>this 确实是指向 window ，但是这道题的陷阱在于 Foo 函数执行的时候，里面的 getName 函数覆盖了外层的 getName 函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">1</span>);					</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Foo().getName()<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>你会发现 成员访问 和 new (带参数列表)的优先级都为 19，相同等级下，遇到谁先执行谁，所以 new Foo().getName()相当于 (new Foo()).getName()</p>
<p>接下来的就比较简单了, new 返回一个对象，这个对象的原型指向 Foo.prototype，然后访问这个对象上的getName方法，自然是调用写在原型上的这个方法啦，结果也就是 3。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName();</span><br><span class="line">getName();</span><br><span class="line">Foo().getName();</span><br><span class="line">getName();</span><br><span class="line"><span class="keyword">new</span> Foo.getName();</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();</span><br><span class="line"><span class="comment">//2,4,1,1,2,3,3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  A = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fn.A = A;</span><br><span class="line">Fn.prototype = &#123;</span><br><span class="line">  A: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A();</span><br><span class="line">Fn.A();</span><br><span class="line">Fn().A();</span><br><span class="line"><span class="keyword">new</span> Fn.A();</span><br><span class="line"><span class="keyword">new</span> Fn().A();</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Fn().A(); <span class="comment">//箭头函数不能被new</span></span><br><span class="line"><span class="comment">//1 1 2 1 3</span></span><br></pre></td></tr></table></figure>

<p>==</p>
<p>1.对象和字符串，对象toString变成字符串</p>
<p>2.null==undefined，但是和其他值不相等</p>
<p>3.NaN和所有的都不相等</p>
<p>4.剩下的都是转换为数字</p>
<p>类型转换实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  i: <span class="number">1</span>,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据劫持实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列弹出+toString</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.toString = a.shift;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、执行上下文"><a href="#四、执行上下文" class="headerlink" title="四、执行上下文"></a>四、执行上下文</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<p>执行过程如下：</p>
<p>1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>2.全局上下文初始化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: [global],</span><br><span class="line">    Scope: [globalContext.VO],</span><br><span class="line">    <span class="keyword">this</span>: globalContext.VO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>4.checkscope 函数执行上下文初始化：</p>
<ol>
<li>复制函数 [[scope]] 属性创建作用域链，</li>
<li>用 arguments 创建活动对象，</li>
<li>初始化活动对象，即加入形参、函数声明、变量声明，</li>
<li>将活动对象压入 checkscope 作用域链顶端。</li>
</ol>
<p>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope: <span class="literal">undefined</span>,</span><br><span class="line">        f: reference to <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, globalContext.VO],</span><br><span class="line">    <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    fContext,</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>6.f 函数执行上下文初始化, 以下跟第 4 步相同：</p>
<ol>
<li>复制函数 [[scope]] 属性创建作用域链</li>
<li>用 arguments 创建活动对象</li>
<li>初始化活动对象，即加入形参、函数声明、变量声明</li>
<li>将活动对象压入 f 作用域链顶端</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">    <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</p>
<p>8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>





<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">var</span> t2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	n++</span><br><span class="line">    	<span class="built_in">console</span>.log(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = t();</span><br><span class="line"><span class="keyword">var</span> a2 = t();</span><br><span class="line"></span><br><span class="line">a1(); <span class="comment">// 100</span></span><br><span class="line">a1(); <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">a2(); <span class="comment">// 100</span></span><br><span class="line">a2(); <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<p>我们会发现，n 的值都是从 99 开始，执行 一次a1() 的时候，值会加一，再执行一次，值再加一，但是 n 在 a1() 和 a2() 并不是公用的。你可以理解为：==同一个函数形成的多个闭包的值都是相互独立的==。</p>
<p>接下来看这道题目，关键在于 nAdd 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nAdd;</span><br><span class="line"><span class="keyword">var</span> t = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">99</span>;</span><br><span class="line">    nAdd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	 n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> t2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = t();</span><br><span class="line"><span class="keyword">var</span> a2 = t();</span><br><span class="line"></span><br><span class="line">nAdd();</span><br><span class="line"></span><br><span class="line">a1(); <span class="comment">//99</span></span><br><span class="line">a2(); <span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<p>当执行 <code>var a1 = t()</code>的时候，变量 nAdd 被赋值为一个函数 ，这个函数是<code>function (){n++}</code>，我们命名这个匿名函数为 fn1 吧。接着执行 <code>var a = t()</code>的时候，变量 nAdd 又被重写了，这个函数跟以前的函数长得一模一样，也是<code>function (){n++}</code>，但是这已经是一个新的函数了，我们就命名为 fn2 吧。</p>
<p>所以当执行 nAdd 函数，我们执行的是其实是 fn2，而不是 fn1，我们更改的是 a2 形成的闭包里的 n 的值，并没有更改 a1 形成的闭包里的 n 的值。所以 a1() 的结果为 99 ，a2()的结果为 100。</p>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setFirstName</span>(<span class="params">firstName</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">lastName</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName+<span class="string">" "</span>+lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setLastName = setFirstName(<span class="string">"kuitos"</span>);</span><br><span class="line"><span class="keyword">var</span> name = setLastName(<span class="string">"lau"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 乍看之下这段代码没有任何问题，但是世界就是这样，大部分东西都禁不起考究(我认真起来连自己都害怕哈哈哈哈)。。</span></span><br><span class="line"><span class="comment">// 调用setFirstName函数时返回一个匿名函数，该匿名函数会持有setFirstName函数作用域的变量对象(里面包含arguments和firstName)，不管匿名函数是否会使用该变量对象里的信息，这个持有逻辑均不会改变。</span></span><br><span class="line"><span class="comment">// 也就是当setFirstName函数执行完之后其执行环境被销毁，但是他的变量对象会一直保存在内存中不被销毁(因为被匿名函数hold)。同样的，垃圾回收机制会因为变量对象被一直hold而不做回收处理。这个时候内存泄露就发生了。这时候我们需要做手动释放内存的处理。like this:</span></span><br><span class="line">setLastName = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 由于匿名函数的引用被置为null，那么其hold的setFirstName的活动对象就能被安全回收了。</span></span><br><span class="line"><span class="comment">// 当然，现代浏览器引擎(以V8为首)都会尝试回收闭包所占用的内存，所以这一点我们也不必过多处理。</span></span><br></pre></td></tr></table></figure>

<h2 id="五、闭包"><a href="#五、闭包" class="headerlink" title="五、闭包"></a>五、闭包</h2><p>MDN对闭包的定义为:</p>
<blockquote>
<p>能够访问自由变量的函数</p>
</blockquote>
<p>那什么是自由变量呢?</p>
<blockquote>
<p>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。</p>
</blockquote>
<p>由此，我们可以看出闭包共有两部分组成：</p>
<blockquote>
<p>闭包 = 函数 + 函数能够访问的自由变量</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。</p>
<p>那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛……</p>
<p>还真是这样的！</p>
<p>所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。</p>
<p>咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？</p>
<p>别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义：</p>
<p>ECMAScript中，闭包指的是：</p>
<ol>
<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>
<li>从实践角度：以下函数才算是闭包：<ol>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
</li>
</ol>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p>
<p>这里直接给出简要的执行过程：</p>
<ol>
<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li>
<li>全局执行上下文初始化</li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li>
<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>
<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li>
<li>f 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>
</ol>
<p>了解到这个过程，我们应该思考一个问题，那就是：</p>
<p>当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p>
<p>以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……)</p>
<p>然而 JavaScript 却是可以的！</p>
<p>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</p>
<p>所以，让我们再看一遍实践角度上闭包的定义：</p>
<ol>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
<p>在这里再补充一个《JavaScript权威指南》英文原版对闭包的定义:</p>
<blockquote>
<p>This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature.</p>
</blockquote>
<p>闭包在计算机科学中也只是一个普通的概念，不要去想得太复杂。</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure>

<p>答案是都是 3，让我们分析一下原因：</p>
<p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。</p>
<p>data[1] 和 data[2] 是一样的道理。</p>
<p>所以让我们改成闭包看看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure>

<p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟没改之前一模一样。</p>
<p>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    Scope: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名函数执行上下文的AO为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">匿名函数Context = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        i: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。</p>
<p>data[1] 和 data[2] 是一样的道理。</p>
<h3 id="闭包问题"><a href="#闭包问题" class="headerlink" title="闭包问题"></a>闭包问题</h3><h4 id="循环中赋值为引用的问题"><a href="#循环中赋值为引用的问题" class="headerlink" title="循环中赋值为引用的问题"></a>循环中赋值为引用的问题</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法有3种</p>
<p>第一种，使用<code>立即执行函数</code>方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (fuction(j)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, j * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，使用ES6的<code>let</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种，使用<code>setTimeout的第三个参数</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>实现一个foo函数 可以这么使用:</p>
<p><code>a = foo();b = foo();c = foo();
// a === 1;b === 2;c === 3;
foo.clear();d = foo(); //d === 1;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIndex</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        index = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = myIndex();</span><br></pre></td></tr></table></figure>



<h2 id="六、参数按值传递"><a href="#六、参数按值传递" class="headerlink" title="六、参数按值传递"></a>六、参数按值传递</h2><blockquote>
<p>ECMAScript中所有函数的参数都是按值传递的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(o); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运算符<code>=</code>就是<strong>创建或修改</strong>变量在内存中的指向.</p>
<p>初始化变量时为创建,重新赋值即为修改.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;;<span class="comment">// a = &#123;b: 1&#125;</span></span><br><span class="line"><span class="keyword">var</span> c = a;<span class="comment">// c = &#123;b: 1&#125;</span></span><br><span class="line">a = <span class="number">2</span>;<span class="comment">// 重新赋值a</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">// &#123;b: 1&#125;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">堆</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a, c</td>
<td align="center">{b: 1}</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">栈</td>
<td align="center">堆</td>
<td align="center">常量区</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center"></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">{b: 1}</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    v = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(value);</span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>内存分布如下：</p>
<p>改变前：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th>堆内存</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>v</td>
<td>1</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>改变后：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th>堆内存</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>v</td>
<td>2</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o.value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(o.value); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>内存分布如下：</p>
<p>改变前：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th>堆内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>obj，o</td>
<td>指针地址</td>
<td>{value: 1}</td>
</tr>
</tbody></table>
<p>改变后：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th>堆内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>obj，o</td>
<td>指针地址</td>
<td>{value: 2}</td>
</tr>
</tbody></table>
<h4 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(o); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>内存分布如下：</p>
<p>改变前：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th>堆内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>obj，o</td>
<td>指针地址</td>
<td>{value: 1}</td>
</tr>
</tbody></table>
<p>改变后：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th>堆内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>obj</td>
<td>指针地址</td>
<td>{value: 1}</td>
</tr>
<tr>
<td>o</td>
<td>2</td>
<td></td>
</tr>
</tbody></table>
<p>==拷贝传递，不管是基本数据类型还是对象类型的，都是拷贝。前者拷贝值，后者拷贝引用。==</p>
<p>简单来说，就是</p>
<ul>
<li><strong>基本类型</strong>存在栈里</li>
<li><strong>引用类型</strong>存在堆里，而引用变量的指针存在栈里</li>
</ul>
<p>对于深浅拷贝</p>
<ul>
<li><strong>基本类型</strong>全部都是深拷贝</li>
<li><strong>引用类型</strong>具体看是不是递归地拷贝基本类型的键值对</li>
</ul>
<p>对于函数参数传值/址</p>
<ul>
<li><strong>基本类型</strong>传的是值</li>
<li><strong>引用类型</strong>传的是址</li>
</ul>
<p>所以，</p>
<ul>
<li>例一中两者不一样的原因是，基本类型的深拷贝导致这就是两个内存数据</li>
<li>例二中是按址传值，在函数中改变堆内存中的基本数据类型，相当于重新开辟了一块栈内存</li>
<li>例三中还是按址传值，形参和实参是两个都指向相同堆内存的指针，在函数中改变了形参的指针，而实参的指针不变，所以不影响原始值。</li>
</ul>
<h1 id="7-全局内置对象"><a href="#7-全局内置对象" class="headerlink" title="7.全局内置对象"></a>7.全局内置对象</h1><h2 id="JS中有那些内置对象"><a href="#JS中有那些内置对象" class="headerlink" title="JS中有那些内置对象"></a>JS中有那些内置对象</h2><ul>
<li>数据封装类对象<ul>
<li>String、Array、Object、Boolean、Number</li>
</ul>
</li>
<li>其他对象<ul>
<li>Math、Date、RegExp、Error、Function、Arguments</li>
</ul>
</li>
<li>ES6 新增对象<ul>
<li>Promise、Map、Set、Symbol、Proxy、Reflect</li>
</ul>
</li>
</ul>
<h2 id="数组Array对象常用方法"><a href="#数组Array对象常用方法" class="headerlink" title="数组Array对象常用方法"></a>数组Array对象常用方法</h2><h3 id="修改器方法"><a href="#修改器方法" class="headerlink" title="修改器方法"></a>修改器方法</h3><p>下面的这些方法会<code>改变调用它们的对象自身的值</code>：</p>
<ul>
<li>Array.prototype.pop()<ul>
<li>删除数组的最后一个元素，并返回这个元素。</li>
</ul>
</li>
<li>Array.prototype.push()<ul>
<li>在数组的末尾增加一个或多个元素，并返回数组的新长度。</li>
</ul>
</li>
<li>Array.prototype.shift()<ul>
<li>删除数组的第一个元素，并返回这个元素。</li>
</ul>
</li>
<li>Array.prototype.unshift()<ul>
<li>在数组的开头增加一个或多个元素，并返回数组的新长度。</li>
</ul>
</li>
<li>Array.prototype.splice()<ul>
<li>在任意的位置给数组添加或删除任意个元素。</li>
</ul>
</li>
<li>Array.prototype.reverse()<ul>
<li>颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。</li>
</ul>
</li>
<li>Array.prototype.sort()<ul>
<li>对数组元素进行排序，并返回当前数组。</li>
</ul>
</li>
<li>Array.prototype.fill()<ul>
<li>将数组中指定区间的所有元素的值，都替换成某个固定的值。</li>
</ul>
</li>
<li>Array.prototype.copyWithin()<ul>
<li>在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。</li>
</ul>
</li>
</ul>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p>下面的这些方法绝对<code>不会改变调用它们的对象的值</code>，只会返回一个新的数组或者返回一个其它的期望值。</p>
<ul>
<li>Array.prototype.join()<ul>
<li>连接所有数组元素组成一个字符串。</li>
</ul>
</li>
<li>Array.prototype.slice()<ul>
<li>抽取当前数组中的一段元素组合成一个新数组。</li>
</ul>
</li>
<li>Array.prototype.concat()<ul>
<li>返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。</li>
</ul>
</li>
<li>Array.prototype.includes()<ul>
<li>判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。</li>
</ul>
</li>
<li>Array.prototype.indexOf()<ul>
<li>返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。</li>
</ul>
</li>
<li>Array.prototype.lastIndexOf()<ul>
<li>返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。</li>
</ul>
</li>
<li>Array.prototype.toSource()<ul>
<li>返回一个表示当前数组字面量的字符串。遮蔽了原型链上的 Object.prototype.toSource() 方法。</li>
</ul>
</li>
<li>Array.prototype.toString()<ul>
<li>返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。</li>
</ul>
</li>
<li>Array.prototype.toLocaleString()<ul>
<li>返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的 Object.prototype.toLocaleString() 方法。</li>
</ul>
</li>
</ul>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的length属性会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。</p>
<ul>
<li>Array.prototype.forEach()<ul>
<li>为数组中的每个元素执行一次回调函数。</li>
</ul>
</li>
<li>Array.prototype.map()<ul>
<li>返回一个由回调函数的返回值组成的新数组。</li>
</ul>
</li>
<li>Array.prototype.reduce()<ul>
<li>从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。</li>
</ul>
</li>
<li>Array.prototype.filter()<ul>
<li>将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。</li>
</ul>
</li>
<li>Array.prototype.every()<ul>
<li>如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。</li>
</ul>
</li>
<li>Array.prototype.some()<ul>
<li>如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。</li>
</ul>
</li>
<li>Array.prototype.find()<ul>
<li>找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。</li>
</ul>
</li>
<li>Array.prototype.findIndex()<ul>
<li>找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。</li>
</ul>
</li>
<li>Array.prototype.keys()<ul>
<li>返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。</li>
</ul>
</li>
<li>Array.prototype.entries()<ul>
<li>返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。</li>
</ul>
</li>
</ul>
<h2 id="字符串常用API"><a href="#字符串常用API" class="headerlink" title="字符串常用API"></a>字符串常用API</h2><ul>
<li>String.prototype.split()<ul>
<li>通过分离字符串成字串，将字符串对象分割成字符串数组。</li>
</ul>
</li>
<li>String.prototype.slice(start, end)<ul>
<li>摘取一个字符串区域，返回一个新的字符串。</li>
</ul>
</li>
<li>String.prototype.substr(start, len)<ul>
<li>通过指定字符数返回在指定位置开始的字符串中的字符。</li>
</ul>
</li>
<li>String.prototype.substring()<ul>
<li>返回在字符串中指定两个下标之间的字符。</li>
</ul>
</li>
<li>String.prototype.trim()<ul>
<li>从字符串的开始和结尾去除空格</li>
</ul>
</li>
<li>String.prototype.concat()<ul>
<li>连接两个字符串文本，并返回一个新的字符串。</li>
</ul>
</li>
<li>String.prototype.match()<ul>
<li>使用正则表达式与字符串相比较。</li>
</ul>
</li>
<li>String.prototype.replace()<ul>
<li>被用来在正则表达式和字符串直接比较，然后用新的子串来替换被匹配的子串。</li>
</ul>
</li>
<li>String.prototype.search()<ul>
<li>对正则表达式和指定字符串进行匹配搜索，返回第一个出现的匹配项的下标。</li>
</ul>
</li>
<li>String.prototype.toString()<ul>
<li>返回用字符串表示的特定对象。重写 Object.prototype.toString 方法。</li>
</ul>
</li>
</ul>
<h3 id="Set、Map、WeakSet-和-WeakMap-的区别？"><a href="#Set、Map、WeakSet-和-WeakMap-的区别？" class="headerlink" title="Set、Map、WeakSet 和 WeakMap 的区别？"></a>Set、Map、WeakSet 和 WeakMap 的区别？</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li>表示有没有，成员的值都是唯一的，没有重复的值</li>
<li>可以接受一个数组（或可迭代的数据结构）作为参数</li>
<li>注：两个对象总是不相等的</li>
</ul>
<p>属性：</p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
</ul>
<p>方法：</p>
<ul>
<li>add(value)：添加某个值，返回 Set 结构本身。<ul>
<li><code>s.add(1).add(2).add(2)</code>;</li>
</ul>
</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
<p>遍历方法</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但与 Set 有几个区别：</p>
<ul>
<li>WeakSet 的成员<strong>只能是对象</strong>，而不能是其他类型的值</li>
<li>WeakSet 中的对象都是弱引用<ul>
<li>如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存</li>
<li>垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</li>
</ul>
</li>
<li>WeakSet 不可遍历<ul>
<li>由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的</li>
</ul>
</li>
<li>WeakSet 结构中没有clear方法。</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，<strong>各种类型的值（包括对象）都可以当作Map的键</strong>。</p>
<p>遍历方法 Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历 Map 的所有成员。</li>
</ul>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap的设计目的在于: 有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用，而一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放被引用对象占用的内存。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</p>
<p>一个典型应用<strong>场景</strong>是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</p>
<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><blockquote>
<p>reduce()方法接收一个回调函数作为第一个参数，回调函数又接受四个参数，分别是；<br>1、previousValue =&gt;初始值或上一次回调函数叠加的值；<br>2、currentValue =&gt; 本次回调（循环）将要执行的值；<br>3、index=&gt;“currentValue”的索引值；<br>4、arr =&gt; 数组本身；<br>reduce()方法返回的是最后一次调用回调函数的返回值；</p>
</blockquote>
<h3 id="用reduce实现map的功能"><a href="#用reduce实现map的功能" class="headerlink" title="用reduce实现map的功能"></a>用reduce实现map的功能</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> array = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(<span class="function">(<span class="params">pre, cur, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">        pre.push(callback(cur, index, array));</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item + item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">//[ 2, 4, 6, 8, 10 ]</span></span><br></pre></td></tr></table></figure>



<p>reduce实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [&#123;</span><br><span class="line">    selector: <span class="string">'sss'</span>,</span><br><span class="line">    rules: <span class="string">'rrrr'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    selector: <span class="string">'sss2'</span>,</span><br><span class="line">    rules: <span class="string">'rrr3'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    selector: <span class="string">'sss'</span>,</span><br><span class="line">    rules: <span class="string">'rrr2'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    selector: <span class="string">'sss2'</span>,</span><br><span class="line">    rules: <span class="string">'rrr4'</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transform</span>(<span class="params">array, key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        pre[cur[key]] = (pre[cur[key]] || []).concat(cur[value]);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tree = transform(array, <span class="string">'selector'</span>, <span class="string">'rules'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tree)</span><br><span class="line"><span class="comment">//&#123; sss: [ 'rrrr', 'rrr2' ], sss2: [ 'rrr3', 'rrr4' ] &#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="8-JS中的垃圾回收和内存泄漏"><a href="#8-JS中的垃圾回收和内存泄漏" class="headerlink" title="8.JS中的垃圾回收和内存泄漏"></a>8.JS中的垃圾回收和内存泄漏</h1><p>下面这段话引自《JavaScript权威指南（第四版）》：</p>
<blockquote>
<p>  由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</p>
</blockquote>
<p>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>
<p>垃圾回收有两种方法：<strong>标记清除、引用计数</strong>。引用计数不太常用，标记清除较为常用。</p>
<h2 id="1-标记清除"><a href="#1-标记清除" class="headerlink" title="1.标记清除"></a>1.标记清除</h2><p><strong>这是javascript中最常用的垃圾回收方式</strong>。当变量进入执行环境时，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>
<h2 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2.引用计数"></a>2.引用计数</h2><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p>
<p>但是如果一个值不再被需要了，但是它的引用计数不为0，从而导致内存泄漏。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> objA = &#123;&#125;;</span><br><span class="line">	<span class="keyword">let</span> objB = &#123;&#125;;</span><br><span class="line">	objA.b = objB;</span><br><span class="line">	objB.a = objA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objA 和objB 还将继续存在，可以看出objA、objB的引用计数都是2，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。假如这个函数被重复多次调用，就会导致大量内存得不到回收。</p>
<p>要解决循环引用的问题，最好是在不使用它们的时候将它们设为空。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objA = <span class="literal">null</span>;</span><br><span class="line">objB = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>



<h2 id="3-哪些会导致内存泄漏？"><a href="#3-哪些会导致内存泄漏？" class="headerlink" title="3.哪些会导致内存泄漏？"></a>3.哪些会导致内存泄漏？</h2><ol>
<li>意外的全局变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    bar = <span class="string">"this is a hidden global variable"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bar没被声明,会变成一个全局变量,在页面关闭之前不会被释放。</p>
<p>另一种意外的全局变量可能由 <code>this</code> 创建:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.variable = <span class="string">"potential accidental global"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 文件头部加上 ‘use strict’，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。</p>
<ol start="2">
<li>被遗忘的计时器或回调函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>这样的代码很常见，如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放。</p>
<ol start="3">
<li>闭包</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj=<span class="built_in">document</span>.createElement(<span class="string">'xxx'</span>)</span><br><span class="line">  obj.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Even if it is a empty function</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包可以维持函数内局部变量，使其得不到释放。上例定义事件回调时，由于是函数内定义函数，并且内部函数–事件回调引用外部函数，形成了闭包。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将事件处理函数定义在外面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">'xxx'</span>)</span><br><span class="line">  obj.onclick = onclickHandler</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者在定义事件处理函数的外部函数中，删除对dom的引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">'xxx'</span>)</span><br><span class="line">  obj.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Even if it is a empty function</span></span><br><span class="line">  &#125;</span><br><span class="line">  obj = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决之道，将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对dom的引用。</p>
<ol start="4">
<li>没有清理的DOM元素引用</li>
</ol>
<p>有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>),</span><br><span class="line">    text: <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    image.src = <span class="string">'http://some.url/image'</span>;</span><br><span class="line">    button.click();</span><br><span class="line">    <span class="built_in">console</span>.log(text.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>));</span><br><span class="line">    <span class="comment">// 此时，仍旧存在一个全局的 #button 的引用</span></span><br><span class="line">    <span class="comment">// elements 字典。button 元素仍旧在内存中，不能被 GC 回收。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们用removeChild移除了button，但是还在elements对象里保存着#button的引用，换言之，DOM元素还在内存里面。</p>
<h2 id="4-垃圾回收的使用场景优化"><a href="#4-垃圾回收的使用场景优化" class="headerlink" title="4.垃圾回收的使用场景优化"></a>4.垃圾回收的使用场景优化</h2><ol>
<li>数组array优化</li>
</ol>
<p>将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'浪里行舟'</span>);</span><br><span class="line">arr.length = <span class="number">0</span>  <span class="comment">// 可以直接让数字清空，而且数组类型不变。意义的话，避免新数组的创建、以及旧元素的回收</span></span><br><span class="line"><span class="comment">// arr = []; 虽然让a变量成一个空数组,但是在堆上重新申请了一个空数组对象。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对象尽量复用</li>
</ol>
<p>对象尽量复用，尤其是在循环等地方出现创建新对象，能复用就复用。不用的对象，尽可能设置为null，尽快被垃圾回收掉。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = &#123;&#125; <span class="comment">// 每次循环都会创建一个新对象。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// var t = &#123;&#125;;// 每次循环都会创建一个新对象。</span></span><br><span class="line">  t.age = <span class="number">19</span></span><br><span class="line">  t.name = <span class="string">'123'</span></span><br><span class="line">  t.index = i</span><br><span class="line">  <span class="built_in">console</span>.log(t)</span><br><span class="line">&#125;</span><br><span class="line">t = <span class="literal">null</span> <span class="comment">//对象如果已经不用了，那就立即设置为null；等待垃圾回收。</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在循环中的函数表达式，能复用最好放到循环外面。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在循环中最好也别使用函数表达式。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">  <span class="keyword">var</span> t = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建了10次  函数对象。</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  t(k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推荐用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">  t(k)</span><br><span class="line">&#125;</span><br><span class="line">t = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="常见的内存泄露的场景"><a href="#常见的内存泄露的场景" class="headerlink" title="常见的内存泄露的场景"></a>常见的内存泄露的场景</h3><ul>
<li>缓存</li>
<li>作用域未释放（闭包）</li>
<li>没有必要的全局变量</li>
<li>无效的DOM引用</li>
<li>定时器未清除</li>
<li>事件监听为空白</li>
</ul>
<h3 id="内存泄露优化"><a href="#内存泄露优化" class="headerlink" title="内存泄露优化"></a>内存泄露优化</h3><ol>
<li>在业务不需要的用到的内部函数，可以重构到函数外，实现解除闭包。</li>
<li>避免创建过多的生命周期较长的对象，或者将对象分解成多个子对象。</li>
<li>避免过多使用闭包。</li>
<li>注意清除定时器和事件监听器。</li>
<li>nodejs中使用stream或buffer来操作大文件，不会受nodejs内存限制。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2020/01/10/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="面试题03-数组中重复的数字"><a href="#面试题03-数组中重复的数字" class="headerlink" title="面试题03. 数组中重复的数字"></a>面试题03. 数组中重复的数字</h2><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123; <span class="comment">//坐标法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]!==i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]===nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            [nums[nums[i]],nums[i]]=[nums[i],nums[nums[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题04-二维数组中的查找"><a href="#面试题04-二维数组中的查找" class="headerlink" title="面试题04. 二维数组中的查找"></a>面试题04. 二维数组中的查找</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//站在右上角看，是一个类似的二叉搜索树，双指针</span></span><br><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!matrix||!matrix.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> m=matrix.length,</span><br><span class="line">        n=matrix[<span class="number">0</span>].length,</span><br><span class="line">        i=<span class="number">0</span>,</span><br><span class="line">        j=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m&amp;&amp;j&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j]&gt;target) j--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&lt;target) i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题05-替换空格"><a href="#面试题05-替换空格" class="headerlink" title="面试题05. 替换空格"></a>面试题05. 替换空格</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">' '</span>).join(<span class="string">'%20'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>解法一：栈 使得倒过来输出</p>
<p>解法二：递归</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reversePrint = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> reversePrint(head.next).concat(head.val);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题07-重建二叉树"><a href="#面试题07-重建二叉树" class="headerlink" title="面试题07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题07. 重建二叉树</a></h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pLeft=<span class="number">0</span>,</span><br><span class="line">        pRight=preorder.length<span class="number">-1</span>,</span><br><span class="line">        iLeft=<span class="number">0</span>,</span><br><span class="line">        iRight=inorder.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> build(pLeft,pRight,iLeft,iRight);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">pLeft,pRight,iLeft,iRight</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pLeft&gt;pRight||iLeft&gt;iRight) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> i=iLeft;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=iRight) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]===preorder[pLeft]) <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node=<span class="keyword">new</span> TreeNode(preorder[pLeft]);</span><br><span class="line">        node.left=build(pLeft+<span class="number">1</span>,pLeft+i-iLeft,iLeft,i<span class="number">-1</span>);</span><br><span class="line">        node.right=build(pLeft+i-iLeft+<span class="number">1</span>,pRight,i+<span class="number">1</span>,iRight);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题26-树的子结构"><a href="#面试题26-树的子结构" class="headerlink" title="面试题26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">面试题26. 树的子结构</a></h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">B</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSubStructure = <span class="function"><span class="keyword">function</span>(<span class="params">A, B</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!A||!B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubStructure(A.left,B)||isSubStructure(A.right,B)||isSubWithRoot(A,B);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSubWithRoot</span>(<span class="params">A,B</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!A&amp;&amp;!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(A&amp;&amp;!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!A&amp;&amp;B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(A.val!==B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubWithRoot(A.left,B.left)&amp;&amp;isSubWithRoot(A.right,B.right);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试题27-二叉树的镜像"><a href="#面试题27-二叉树的镜像" class="headerlink" title="面试题27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">面试题27. 二叉树的镜像</a></h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    [root.left,root.right]=[mirrorTree(root.right),mirrorTree(root.left)];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=queue.shift();</span><br><span class="line">        <span class="keyword">if</span>(node) &#123;</span><br><span class="line">            [node.left,node.right]=[node.right,node.left];</span><br><span class="line">            queue.push(node.left,node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题28-对称的二叉树"><a href="#面试题28-对称的二叉树" class="headerlink" title="面试题28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题28. 对称的二叉树</a></h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> queue=[root.left,root.right];</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node1=queue.pop(),</span><br><span class="line">            node2=queue.pop();</span><br><span class="line">        <span class="keyword">if</span>(!node1&amp;&amp;!node2) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node1||!node2||node1.val!==node2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue.push(node1.left,node2.right,node1.right,node2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSame(root.left,root.right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSame</span>(<span class="params">l,r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l&amp;&amp;!r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!l||!r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(l.val!==r.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSame(l.left,r.right)&amp;&amp;isSame(l.right,r.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试题32-I-从上到下打印二叉树"><a href="#面试题32-I-从上到下打印二叉树" class="headerlink" title="面试题32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32 - I. 从上到下打印二叉树</a></h2><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回：</p>
<p>[3,9,20,15,7]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res=[],</span><br><span class="line">          queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=queue.shift();</span><br><span class="line">        <span class="keyword">if</span>(node) &#123;</span><br><span class="line">            res.push(node.val);</span><br><span class="line">            queue.push(node.left,node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题32-II-从上到下打印二叉树-II"><a href="#面试题32-II-从上到下打印二叉树-II" class="headerlink" title="面试题32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32 - II. 从上到下打印二叉树 II</a></h2><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res=[],</span><br><span class="line">          queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> len=queue.length,</span><br><span class="line">            temp=[];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> node=queue[i];</span><br><span class="line">            temp.push(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left) queue.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right) queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(temp);</span><br><span class="line">        queue.splice(<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题32-III-从上到下打印二叉树-III"><a href="#面试题32-III-从上到下打印二叉树-III" class="headerlink" title="面试题32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III</a></h2><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p>
<p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[],</span><br><span class="line">        queue=[root],</span><br><span class="line">        flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> len=queue.length,</span><br><span class="line">            temp=[];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> node=queue[i];</span><br><span class="line">            <span class="keyword">if</span>(flag) temp.push(node.val);</span><br><span class="line">            <span class="keyword">else</span> temp.unshift(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left) queue.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right) queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(temp);</span><br><span class="line">        queue.splice(<span class="number">0</span>,len);</span><br><span class="line">        flag=!flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题34-二叉树中和为某一值的路径"><a href="#面试题34-二叉树中和为某一值的路径" class="headerlink" title="面试题34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题34. 二叉树中和为某一值的路径</a></h2><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1</code></pre><p>返回:</p>
<p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">sum</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    backtrack(root,[],sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">root,tempArr,sum</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root&amp;&amp;!root.left&amp;&amp;!root.right&amp;&amp;root.val===sum) res.push([...tempArr,root.val]);</span><br><span class="line">        tempArr.push(root.val);</span><br><span class="line">        backtrack(root.left,tempArr,sum-root.val);</span><br><span class="line">        backtrack(root.right,tempArr,sum-root.val);</span><br><span class="line">        tempArr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题37-序列化二叉树"><a href="#面试题37-序列化二叉树" class="headerlink" title="面试题37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37. 序列化二叉树</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encodes a tree to a single string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">const</span> queue=[root],</span><br><span class="line">          res=[];</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=queue.shift();</span><br><span class="line">        <span class="keyword">if</span>(node) &#123;</span><br><span class="line">            res.push(node.val)</span><br><span class="line">            queue.push(node.left);</span><br><span class="line">            queue.push(node.right);</span><br><span class="line">        &#125;<span class="keyword">else</span> res.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res[res.length<span class="number">-1</span>]===<span class="literal">null</span>) res.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(res);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decodes your encoded data to tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!data) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> arr=<span class="built_in">JSON</span>.parse(data);</span><br><span class="line">    <span class="keyword">const</span> root=<span class="keyword">new</span> TreeNode(arr.shift());</span><br><span class="line">    <span class="keyword">const</span> queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=queue.shift(),val;</span><br><span class="line">        <span class="keyword">let</span> l=arr.shift(),</span><br><span class="line">            r=arr.shift();</span><br><span class="line">        node.left = (l || l === <span class="number">0</span>) ? <span class="keyword">new</span> TreeNode(l) : <span class="literal">null</span>;</span><br><span class="line">        node.right = (r || r === <span class="number">0</span>) ? <span class="keyword">new</span> TreeNode(r) : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left) queue.push(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right) queue.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your functions will be called as such:</span></span><br><span class="line"><span class="comment"> * deserialize(serialize(root));</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="面试题54-二叉搜索树的第k大节点"><a href="#面试题54-二叉搜索树的第k大节点" class="headerlink" title="面试题54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">面试题54. 二叉搜索树的第k大节点</a></h2><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> kthLargest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res,</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inorder</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">        <span class="keyword">if</span>(++num===k) <span class="keyword">return</span> res=root.val;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> kthLargest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> now=find(root.right);</span><br><span class="line">    <span class="keyword">if</span>(now===k<span class="number">-1</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(now&gt;k<span class="number">-1</span>) <span class="keyword">return</span> kthLargest(root.right,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> kthLargest(root.left,k<span class="number">-1</span>-now);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> l=find(root.left),</span><br><span class="line">        r=find(root.right);</span><br><span class="line">    <span class="keyword">return</span> l+r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试题55-I-二叉树的深度"><a href="#面试题55-I-二叉树的深度" class="headerlink" title="面试题55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">面试题55 - I. 二叉树的深度</a></h2><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="面试题55-II-平衡二叉树"><a href="#面试题55-II-平衡二叉树" class="headerlink" title="面试题55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题55 - II. 平衡二叉树</a></h2><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isBalanced = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root.left)&amp;&amp;isBalanced(root.right)&amp;&amp;<span class="built_in">Math</span>.abs(depth(root.left)-depth(root.right))&lt;=<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">depth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(depth(root.left),depth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试题68-I-二叉搜索树的最近公共祖先"><a href="#面试题68-I-二叉搜索树的最近公共祖先" class="headerlink" title="面试题68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - I. 二叉搜索树的最近公共祖先</a></h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">q</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="面试题68-II-二叉树的最近公共祖先"><a href="#面试题68-II-二叉树的最近公共祖先" class="headerlink" title="面试题68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - II. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">q</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root||root===p||root===q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">let</span> l=lowestCommonAncestor(root.left,p,q),</span><br><span class="line">        r=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(!l) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/2020/01/10/leetcode/</url>
    <content><![CDATA[<p>leetcode刷题汇总</p>
<a id="more"></a>

<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> num=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.has(target-nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(target-nums[i]),i];</span><br><span class="line">        &#125;<span class="keyword">else</span> map.set(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>), </span><br><span class="line">        cur=dummy,</span><br><span class="line">        carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1||l2) &#123;</span><br><span class="line">        <span class="keyword">let</span> val1=l1?l1.val:<span class="number">0</span>,</span><br><span class="line">            val2=l2?l2.val:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> val=val1+val2+carry;</span><br><span class="line">        <span class="keyword">let</span> node=<span class="keyword">new</span> ListNode(val%<span class="number">10</span>);</span><br><span class="line">        carry=<span class="built_in">Math</span>.floor(val/<span class="number">10</span>);</span><br><span class="line">        cur.next=node;</span><br><span class="line">        cur=node;</span><br><span class="line">        <span class="keyword">if</span>(l1) l1=l1.next;</span><br><span class="line">        <span class="keyword">if</span>(l2) l2=l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=<span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        cur.next=node;</span><br><span class="line">        cur=node;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h2><p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    nums=nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length<span class="number">-2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]===nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//去除重复的</span></span><br><span class="line">        <span class="keyword">let</span> start=i+<span class="number">1</span>,</span><br><span class="line">            end=nums.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end) &#123;</span><br><span class="line">            <span class="keyword">let</span> sum=nums[i]+nums[start]+nums[end];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">0</span>) end--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) start++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push([nums[i],nums[start],nums[end]]);</span><br><span class="line">                <span class="keyword">while</span>(nums[start]===nums[start+<span class="number">1</span>]) start++; <span class="comment">//关键 这里会出现重复的</span></span><br><span class="line">                start++</span><br><span class="line">                <span class="keyword">while</span>(nums[end]===nums[end<span class="number">-1</span>]) end--;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h2><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [-1, 2, 1, -4], and target &#x3D; 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 &#x3D; 2).</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> min=<span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">    nums=nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=nums.length;i&lt;len<span class="number">-2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> start=i+<span class="number">1</span>,</span><br><span class="line">            end=nums.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end) &#123;</span><br><span class="line">            <span class="keyword">let</span> sum=nums[i]+nums[start]+nums[end];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(sum-target)&lt;<span class="built_in">Math</span>.abs(min-target)) min=sum;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;target) start++;</span><br><span class="line">            <span class="keyword">else</span> end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h2><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="img"></p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>

<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">digits</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map=&#123;</span><br><span class="line">        <span class="string">'2'</span>:<span class="string">"abc"</span>,</span><br><span class="line">        <span class="string">'3'</span>:<span class="string">"def"</span>,</span><br><span class="line">        <span class="string">'4'</span>:<span class="string">"ghi"</span>,</span><br><span class="line">        <span class="string">'5'</span>:<span class="string">"jkl"</span>,</span><br><span class="line">        <span class="string">'6'</span>:<span class="string">"mno"</span>,</span><br><span class="line">        <span class="string">'7'</span>:<span class="string">"prqs"</span>,</span><br><span class="line">        <span class="string">'8'</span>:<span class="string">"tuv"</span>,</span><br><span class="line">        <span class="string">'9'</span>:<span class="string">"wxyz"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    backtrack(<span class="string">''</span>,digits)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">temp,digits</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!digits)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!temp) <span class="keyword">return</span>; <span class="comment">//digits=""时</span></span><br><span class="line">            <span class="keyword">return</span> res.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;map[digits[<span class="number">0</span>]].length;i++) &#123;</span><br><span class="line">            backtrack(temp+map[digits[<span class="number">0</span>]][i],digits.slice(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h2><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    nums=nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length<span class="number">-3</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;nums[i]===nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;nums.length<span class="number">-2</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]===nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> l=j+<span class="number">1</span>,</span><br><span class="line">                r=nums.length<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">                <span class="keyword">let</span> sum=nums[i]+nums[j]+nums[l]+nums[r];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;target) r--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target) l++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.push([nums[i],nums[j],nums[l],nums[r]]);</span><br><span class="line">                    <span class="keyword">while</span>(nums[l]===nums[l+<span class="number">1</span>]) l++;</span><br><span class="line">                    l++;</span><br><span class="line">                    <span class="keyword">while</span>(nums[r]===nums[r<span class="number">-1</span>]) r--;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h2><p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>Given <em>n</em> will always be valid.</p>
<p><strong>Follow up:</strong></p>
<p>Could you do this in one pass?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=&#123;<span class="attr">val</span>:<span class="number">0</span>,<span class="attr">next</span>:head&#125;,</span><br><span class="line">        fast=dummy,</span><br><span class="line">        slow=dummy;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast.next) &#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next=slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>),</span><br><span class="line">        cur=dummy;</span><br><span class="line">    <span class="keyword">while</span>(l1&amp;&amp;l2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val) &#123;</span><br><span class="line">            cur.next=l1;</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next=l2;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next=l1||l2;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h2><p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n</em> = 3, a solution set is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>每一个状态的左括号数大于右括号数，一旦小于，肯定是不满足的</strong></p>
<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    generate(n,n,<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">l,r,s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!l&amp;&amp;!r) <span class="keyword">return</span> res.push(s);</span><br><span class="line">        <span class="keyword">if</span>(l) generate(l<span class="number">-1</span>,r,s+<span class="string">'('</span>);</span><br><span class="line">        <span class="keyword">if</span>(r) generate(l,r<span class="number">-1</span>,s+<span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h2><p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode[]&#125;</span> <span class="variable">lists</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeKLists = <span class="function"><span class="keyword">function</span>(<span class="params">lists</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.length===<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(lists.length===<span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> mid=<span class="built_in">Math</span>.floor(lists.length/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> l1=lists.slice(<span class="number">0</span>,mid),</span><br><span class="line">        l2=lists.slice(mid);</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(mergeKLists(l1),mergeKLists(l2));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeTwoLists</span>(<span class="params">l1,l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>),</span><br><span class="line">        cur=dummy;</span><br><span class="line">    <span class="keyword">while</span>(l1&amp;&amp;l2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val) &#123;</span><br><span class="line">            cur.next=l1;</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next=l2;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next=l1||l2;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a>24. Swap Nodes in Pairs</h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=&#123;<span class="attr">val</span>:<span class="number">0</span>,<span class="attr">next</span>:head&#125;,</span><br><span class="line">        cur=dummy;</span><br><span class="line">    <span class="keyword">while</span>(cur.next&amp;&amp;cur.next.next) &#123;</span><br><span class="line">        <span class="keyword">let</span> node1=cur.next,</span><br><span class="line">            node2=cur.next.next;</span><br><span class="line">        node1.next=node2.next;</span><br><span class="line">        node2.next=node1;</span><br><span class="line">        cur.next=node2;</span><br><span class="line">        cur=cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h2><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
<p><strong>Example:</strong></p>
<p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For <em>k</em> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For <em>k</em> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>Note:</strong></p>
<ul>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseKGroup = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> prev=cur=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span> head;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newList=reverseK(prev,cur);</span><br><span class="line">    prev.next=reverseKGroup(cur,k); <span class="comment">//继续反转后面k个节点</span></span><br><span class="line">    <span class="keyword">return</span> newList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseK</span>(<span class="params">a,b</span>) </span>&#123; <span class="comment">//翻转[a,b)的链表</span></span><br><span class="line">    <span class="keyword">let</span> prev=<span class="literal">null</span>,</span><br><span class="line">        cur=a;</span><br><span class="line">    <span class="keyword">while</span>(cur!==b) &#123;</span><br><span class="line">        <span class="keyword">let</span> next=cur.next;</span><br><span class="line">        cur.next=prev;</span><br><span class="line">        prev=cur;</span><br><span class="line">        cur=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h2><p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum = <span class="function"><span class="keyword">function</span>(<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    backtrack(res,<span class="number">0</span>,[],candidates,target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,temp,tempArr,candidates,target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp===target) <span class="keyword">return</span> res.push([...tempArr]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;candidates.length;i++) &#123;</span><br><span class="line">        <span class="comment">//和Combination一样，不能出现相同组合的子集，所以要规定选的范围</span></span><br><span class="line">        <span class="keyword">if</span>(candidates[i]&lt;tempArr[tempArr.length<span class="number">-1</span>]) <span class="keyword">continue</span></span><br><span class="line">        tempArr.push(candidates[i]);</span><br><span class="line">        backtrack(res,temp+candidates[i],tempArr,candidates,target);</span><br><span class="line">        tempArr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h2><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum2 = <span class="function"><span class="keyword">function</span>(<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    backtrack(res,<span class="number">0</span>,[],candidates.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b),target,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,temp,tempArr,candidates,target,start</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp===target) <span class="keyword">return</span> res.push([...tempArr]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;candidates.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;start&amp;&amp;candidates[i]===candidates[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//同一深度把相同的元素排除掉</span></span><br><span class="line">        tempArr.push(candidates[i]);</span><br><span class="line">        backtrack(res,temp+candidates[i],tempArr,candidates,target,i+<span class="number">1</span>);</span><br><span class="line">        tempArr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="60-Permutation-Sequence"><a href="#60-Permutation-Sequence" class="headerlink" title="60. Permutation Sequence"></a>60. Permutation Sequence</h2><p>The set <code>[1,2,3,...,*n*]</code> contains a total of <em>n</em>! unique permutations.</p>
<p>By listing and labeling all of the permutations in order, we get the following sequence for <em>n</em> = 3:</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>Given <em>n</em> and <em>k</em>, return the <em>k</em>th permutation sequence.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Given <em>n</em> will be between 1 and 9 inclusive.</li>
<li>Given <em>k</em> will be between 1 and <em>n</em>! inclusive.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 3, k &#x3D; 3</span><br><span class="line">Output: &quot;213&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 4, k &#x3D; 9</span><br><span class="line">Output: &quot;2314&quot;</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>如果直接把所有的排列组合算出来再输出第k个组合的话，时间和空间复杂度会很高。</p>
<p>我们可以观察到：</p>
<p>n=3时</p>
<ul>
<li>123</li>
<li>132</li>
<li>213</li>
<li>231</li>
<li>312</li>
<li>321</li>
</ul>
<p>发现开头的数字俩俩一组，即(n-1)!所以我们可以对k进行操作，k/(n-1)!是第几组，即确定了前面的数字，k%(n-1)!是下个递归的开始。</p>
<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getPermutation = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=<span class="built_in">Array</span>(n),</span><br><span class="line">        temp=<span class="number">1</span>,</span><br><span class="line">        res=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        arr[i]=i+<span class="number">1</span>;</span><br><span class="line">        temp*=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    temp/=n;</span><br><span class="line">    k--;<span class="comment">//如果k整除temp的话，会出现边界数组找不到情况，所以统一处理-1</span></span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="keyword">let</span> index=<span class="built_in">Math</span>.floor(k/temp); <span class="comment">//第几组</span></span><br><span class="line">        k%=temp; <span class="comment">//下一个循环</span></span><br><span class="line">        n--;</span><br><span class="line">        temp/=n; <span class="comment">//基底</span></span><br><span class="line">        res+=arr[index];</span><br><span class="line">        arr.splice(index,<span class="number">1</span>); <span class="comment">//加入的数字移除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. Rotate List</h2><p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class="line">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotateRight = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cur=head,</span><br><span class="line">        len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next=head;</span><br><span class="line">    k=len-k%len;</span><br><span class="line">    cur=head;</span><br><span class="line">    <span class="keyword">while</span>(--k) &#123;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newNode=cur.next;</span><br><span class="line">    cur.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h2><p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p> <strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    backtrack(res,[],n,k,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,tempArr,n,k,start</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tempArr.length===k) <span class="keyword">return</span> res.push([...tempArr]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tempArr.includes(i)) <span class="keyword">continue</span>; <span class="comment">//重复的过滤掉</span></span><br><span class="line">        tempArr.push(i);</span><br><span class="line">        backtrack(res,tempArr,n,k,i+<span class="number">1</span>); <span class="comment">//防止下次选的比前面一个数小</span></span><br><span class="line">        tempArr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h2><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    backtrack(res,[],nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,tempArr,nums,start</span>) </span>&#123;</span><br><span class="line">    res.push([...tempArr]); <span class="comment">//不限制长度 所以这里直接插入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;nums.length;i++) &#123;</span><br><span class="line">        tempArr.push(nums[i]);</span><br><span class="line">        backtrack(res,tempArr,nums,i+<span class="number">1</span>);</span><br><span class="line">        tempArr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82. Remove Duplicates from Sorted List II"></a>82. Remove Duplicates from Sorted List II</h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">Output: 2-&gt;3</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> dummy=&#123;<span class="attr">val</span>:<span class="number">0</span>,<span class="attr">next</span>:head&#125;,</span><br><span class="line">        cur=dummy;</span><br><span class="line">    <span class="keyword">while</span>(cur.next&amp;&amp;cur.next.next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next.val===cur.next.next.val) &#123;</span><br><span class="line">            <span class="keyword">let</span> val=cur.next.val;</span><br><span class="line">            <span class="keyword">while</span>(cur.next&amp;&amp;cur.next.val===val) &#123;</span><br><span class="line">                cur.next=cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a>83. Remove Duplicates from Sorted List</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> cur=head,</span><br><span class="line">        nxt=head; </span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        <span class="keyword">while</span>(nxt&amp;&amp;nxt.val===cur.val) nxt=nxt.next; <span class="comment">//和当前的cur指向的节点比较</span></span><br><span class="line">        cur.next=nxt; <span class="comment">//下一个不相同的节点找到-&gt;连接</span></span><br><span class="line">        cur=nxt; <span class="comment">// 移到下一个需要比较的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a>86. Partition List</h2><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span>(<span class="params">head, x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l=<span class="keyword">new</span> ListNode(<span class="number">0</span>), <span class="comment">//俩个用来存放小于x和大于等于x的头节点，最后再拼接</span></span><br><span class="line">        h=<span class="keyword">new</span> ListNode(<span class="number">0</span>),</span><br><span class="line">        high=h, <span class="comment">//这俩个用来标记初始节点，用于返回和拼接</span></span><br><span class="line">        res=l;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val&lt;x) &#123;</span><br><span class="line">            l.next=head;</span><br><span class="line">            l=l.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            h.next=head;</span><br><span class="line">            h=h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    l.next=high.next; <span class="comment">//拼接</span></span><br><span class="line">    h.next=<span class="literal">null</span>; <span class="comment">//尾节点为null</span></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h2><p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsetsWithDup = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res=[];</span><br><span class="line">  backtrack(res,[],nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b),<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,tempArr,nums,start</span>) </span>&#123;</span><br><span class="line">    res.push([...tempArr]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;start&amp;&amp;nums[i]===nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        tempArr.push(nums[i]);</span><br><span class="line">        backtrack(res,tempArr,nums,i+<span class="number">1</span>);</span><br><span class="line">        tempArr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a>92. Reverse Linked List II</h2><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span>(<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    prev.next=head;</span><br><span class="line">    <span class="keyword">let</span> dummy=prev; <span class="comment">//虚拟节点 用于返回结果</span></span><br><span class="line">    <span class="keyword">while</span>(--m) &#123; <span class="comment">//找到需要翻转节点的前一个</span></span><br><span class="line">        prev=prev.next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> len=n-m+<span class="number">1</span>; <span class="comment">//需要翻转的节点数</span></span><br><span class="line">    <span class="keyword">let</span> n1=prev, </span><br><span class="line">        n2=prev.next, <span class="comment">//n1、n2是用来翻转的临时节点</span></span><br><span class="line">        n3=prev.next;<span class="comment">//prev、n3一个是翻转节点的前一个节点 一个是翻转节点的第一个</span></span><br><span class="line">    <span class="keyword">while</span>(--len) &#123;</span><br><span class="line">        <span class="keyword">let</span> n4=n2.next;</span><br><span class="line">        n2.next=n1;</span><br><span class="line">        n1=n2;</span><br><span class="line">        n2=n4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时n1是翻转节点的最后一个、n2是翻转节点的最后一个的下一个节点</span></span><br><span class="line">    prev.next=n1;</span><br><span class="line">    n3.next=n2;<span class="comment">//这俩步是拼接</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a>93. Restore IP Addresses</h2><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    backtrack(res,<span class="number">0</span>,[],s);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isValid</span>(<span class="params">s</span>) </span>&#123; <span class="comment">//如果大于一位数，但是首字符是'0'，也要排除</span></span><br><span class="line">    <span class="keyword">if</span>(s.length&gt;<span class="number">3</span>||(s.length===<span class="number">3</span>&amp;&amp;<span class="built_in">parseInt</span>(s)&gt;<span class="number">255</span>)||(s.length&gt;<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]===<span class="string">'0'</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,count,tempArr,s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s||count===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s&amp;&amp;count===<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp=<span class="string">''</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;tempArr.length;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i) temp+=<span class="string">'.'</span>+tempArr[i];</span><br><span class="line">                <span class="keyword">else</span> temp+=tempArr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isValid(s.slice(<span class="number">0</span>,i+<span class="number">1</span>))) &#123;</span><br><span class="line">            tempArr.push(s.slice(<span class="number">0</span>,i+<span class="number">1</span>));</span><br><span class="line">            backtrack(res,count+<span class="number">1</span>,tempArr,s.slice(i+<span class="number">1</span>));</span><br><span class="line">            tempArr.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h2><p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>?</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numTrees = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map=&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> unique(n);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(map[n]) <span class="keyword">return</span> map[n];</span><br><span class="line">        <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            res+=unique(i<span class="number">-1</span>)*unique(n-i);</span><br><span class="line">        &#125;</span><br><span class="line">        map[n]=res;</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a>100. Same Tree</h2><p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">q</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p&amp;&amp;!q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p||!q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p.val!==q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>



<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p><strong>recursively</strong></p>
<p>你将根节点的左子树和根节点的右子树的翻转比较是否一样，其实就是<code>100. Same Tree</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> isSame(root.left,root.right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSame</span>(<span class="params">p,q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p&amp;&amp;!q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p||!q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p.val!==q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSame(p.left,q.right)&amp;&amp;isSame(p.right,q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>iteratively</strong></p>
<p>相当于二叉树的层序遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> stack=[root.left,root.right];</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node1=stack.pop(),</span><br><span class="line">            node2=stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(!node1&amp;&amp;!node2) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node1||!node2||node1.val!==node2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//可以很好的俩俩比较</span></span><br><span class="line">        stack.push(node1.left);</span><br><span class="line">        stack.push(node2.right);</span><br><span class="line">        stack.push(node1.right);</span><br><span class="line">        stack.push(node2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h2><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>



<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[],</span><br><span class="line">        queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp=[],</span><br><span class="line">            len=queue.length;</span><br><span class="line">        <span class="comment">//保证了这一循环都是处于一层的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            temp.push(queue[i].val);</span><br><span class="line">            <span class="keyword">if</span>(queue[i].left) queue.push(queue[i].left);</span><br><span class="line">            <span class="keyword">if</span>(queue[i].right) queue.push(queue[i].right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(temp);</span><br><span class="line">        queue.splice(<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h2><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>



<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>和上一题不同的是，根据层次不同插入方向也不同</p>
<ul>
<li>push 尾插</li>
<li>unshift 头插</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> zigzagLevelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[],</span><br><span class="line">        queue=[root],</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=[],</span><br><span class="line">            len=queue.length;</span><br><span class="line">        flag=!flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) temp.push(queue[i].val);</span><br><span class="line">            <span class="keyword">else</span> temp.unshift(queue[i].val)</span><br><span class="line">            <span class="keyword">if</span>(queue[i].left) queue.push(queue[i].left);</span><br><span class="line">            <span class="keyword">if</span>(queue[i].right) queue.push(queue[i].right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(temp);</span><br><span class="line">        queue.splice(<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a>107. Binary Tree Level Order Traversal II</h2><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>



<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[],</span><br><span class="line">        queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=[],</span><br><span class="line">            len=queue.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            temp.push(queue[i].val);</span><br><span class="line">            <span class="keyword">if</span>(queue[i].left) queue.push(queue[i].left);</span><br><span class="line">            <span class="keyword">if</span>(queue[i].right) queue.push(queue[i].right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.unshift(temp);</span><br><span class="line">        queue.splice(<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="109. Convert Sorted List to Binary Search Tree"></a>109. Convert Sorted List to Binary Search Tree</h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedListToBST = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(!head.next) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">    <span class="keyword">let</span> pre=findMid(head),</span><br><span class="line">        mid=pre.next;</span><br><span class="line">    pre.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> node=<span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line">    <span class="keyword">let</span> nxt=mid.next;</span><br><span class="line">    node.left=sortedListToBST(head);</span><br><span class="line">    node.right=sortedListToBST(nxt);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMid</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre=slow=fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast&amp;&amp;fast.next) &#123;</span><br><span class="line">        pre=slow;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. Balanced Binary Tree</h2><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>Return true.</p>
<p><strong>Example 2:</strong></p>
<p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>

<p>Return false.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isBalanced = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="literal">true</span>;</span><br><span class="line">    maxDepth(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">maxDepth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> left=maxDepth(root.left),</span><br><span class="line">            right=maxDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(left-right)&gt;<span class="number">1</span>) <span class="keyword">return</span> res=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its minimum depth = 2.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left=minDepth(root.left),</span><br><span class="line">        right=minDepth(root.right);</span><br><span class="line">    <span class="comment">//这里和求最大深度不一样。当左右子节点为0时，不能以0为标准，而是比0大的高度中较小的那个</span></span><br><span class="line">    <span class="keyword">if</span>(!left||!right) <span class="keyword">return</span> left+right+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(left,right)+<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a>112. Path Sum</h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>

<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">sum</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root.left&amp;&amp;!root.right) <span class="keyword">return</span> sum===root.val;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a>113. Path Sum II</h2><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>

<p>Return:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">sum</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    backtrack(res,[],root,sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,tempArr,root,sum</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//注意边界条件的处理</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val===sum&amp;&amp;!root.left&amp;&amp;!root.right) <span class="keyword">return</span> res.push([...tempArr,root.val]);</span><br><span class="line">    tempArr.push(root.val);</span><br><span class="line">    backtrack(res,tempArr,root.left,sum-root.val);</span><br><span class="line">    backtrack(res,tempArr,root.right,sum-root.val);</span><br><span class="line">    tempArr.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a>131. Palindrome Partitioning</h2><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of <em>s</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res=[];</span><br><span class="line">  backtrack(res,[],s);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,</span><br><span class="line">        j=s.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!==s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,tempArr,s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="keyword">return</span> res.push([...tempArr]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPalindrome(s.slice(<span class="number">0</span>,i+<span class="number">1</span>)))&#123;</span><br><span class="line">            tempArr.push(s.slice(<span class="number">0</span>,i+<span class="number">1</span>));</span><br><span class="line">            backtrack(res,tempArr,s.slice(i+<span class="number">1</span>));</span><br><span class="line">            tempArr.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow=fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast&amp;&amp;fast.next) &#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(slow===fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. Linked List Cycle II</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Note:</strong> Do not modify the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head.next) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> slow=fast=cur=head,</span><br><span class="line">        isCycle=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast&amp;&amp;fast.next) &#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(slow===fast) &#123;</span><br><span class="line">            isCycle=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isCycle) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=slow) &#123;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h2><p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> slow=fast=pre=head;</span><br><span class="line">    <span class="keyword">while</span>(fast&amp;&amp;fast.next) &#123;</span><br><span class="line">        pre=slow;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwo(sortList(head),sortList(slow));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeTwo</span>(<span class="params">l1,l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>),</span><br><span class="line">        cur=dummy;</span><br><span class="line">    <span class="keyword">while</span>(l1&amp;&amp;l2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val) &#123;</span><br><span class="line">            cur.next=l1;</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next=l2;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next=l1||l2;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt="img"></p>
<p>begin to intersect at node c1.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headA</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headB</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l1=headA,</span><br><span class="line">        l2=headB;</span><br><span class="line">    <span class="keyword">while</span>(l1!==l2) &#123; <span class="comment">//走俩遍</span></span><br><span class="line">        l1=l1?l1.next:headB;</span><br><span class="line">        l2=l2?l2.next:headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167. Two Sum II - Input array is sorted"></a>167. Two Sum II - Input array is sorted</h2><p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Your returned answers (both index1 and index2) are not zero-based.</li>
<li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2.</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start=<span class="number">0</span>,</span><br><span class="line">        end=numbers.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end) &#123;</span><br><span class="line">        <span class="keyword">let</span> sum=numbers[start]+numbers[end];</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target) start++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target) end--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> [start+<span class="number">1</span>,end+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a>199. Binary Tree Right Side View</h2><p>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rightSideView = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[],</span><br><span class="line">        queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> len=queue.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i===len<span class="number">-1</span>) res.push(queue[i].val); <span class="comment">//每一层最右边的数</span></span><br><span class="line">            <span class="keyword">if</span>(queue[i].left) queue.push(queue[i].left);</span><br><span class="line">            <span class="keyword">if</span>(queue[i].right) queue.push(queue[i].right);</span><br><span class="line">        &#125;</span><br><span class="line">        queue.splice(<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203. Remove Linked List Elements"></a>203. Remove Linked List Elements</h2><p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=&#123;<span class="attr">val</span>:<span class="number">0</span>,<span class="attr">next</span>:head&#125;,</span><br><span class="line">        pre=dummy,</span><br><span class="line">        cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val!==val) &#123; <span class="comment">//将需要的节点链接起来</span></span><br><span class="line">            pre.next=cur;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a>216. Combination Sum III</h2><p>Find all possible combinations of <strong><em>k</em></strong> numbers that add up to a number <strong><em>n</em></strong>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">Output: [[1,2,4]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">Output: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>

<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum3 = <span class="function"><span class="keyword">function</span>(<span class="params">k, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    backtrack(res,<span class="number">0</span>,[],k,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,temp,tempArr,num,target,start</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp&gt;target||tempArr.length&gt;num) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp===target&amp;&amp;tempArr.length===num) <span class="keyword">return</span> res.push([...tempArr]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;=<span class="number">9</span>;i++) &#123;</span><br><span class="line">        tempArr.push(i);</span><br><span class="line">        backtrack(res,temp+i,tempArr,num,target,i+<span class="number">1</span>);</span><br><span class="line">        tempArr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h2><p>Invert a binary tree.</p>
<p><strong>Example:</strong></p>
<p>Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p><strong>Trivia:</strong><br>This problem was inspired by <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="noopener">this original tweet</a> by <a href="https://twitter.com/mxcl" target="_blank" rel="noopener">Max Howell</a>:</p>
<blockquote>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    [root.left,root.right]=[invertTree(root.right),invertTree(root.left)];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queue=[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=queue.shift();</span><br><span class="line">        <span class="keyword">if</span>(node) &#123;</span><br><span class="line">            [node.left,node.right]=[node.right,node.left];</span><br><span class="line">            queue.push(node.left,node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a>230. Kth Smallest Element in a BST</h2><p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p>
<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> kthSmallest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack=[],</span><br><span class="line">        now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(root||stack.length) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root=root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node=stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(++now===k) <span class="keyword">return</span> node.val;</span><br><span class="line">        root=node.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>联想到二叉搜索树的性质，root 大于左子树，小于右子树，如果左子树的节点数目等于 K-1，那么 root 就是结果，否则如果左子树节点数目小于 K-1，那么结果必然在右子树，否则就在左子树。 因此在搜索的时候同时返回节点数目，跟 K 做对比，就能得出结果了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> kthSmallest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count=nodeCount(root.left);</span><br><span class="line">    <span class="keyword">if</span>(count&lt;k<span class="number">-1</span>) <span class="keyword">return</span> kthSmallest(root.right,k<span class="number">-1</span>-count);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(count&gt;k<span class="number">-1</span>) <span class="keyword">return</span> kthSmallest(root.left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nodeCount</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> l=nodeCount(root.left),</span><br><span class="line">        r=nodeCount(root.right);</span><br><span class="line">    <span class="keyword">return</span> l+r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a>234. Palindrome Linked List</h2><p>Given a singly linked list, determine if it is a palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>另外一种使用栈的方法也可以，但是空间复杂度高，因为要维护一个栈。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head.next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> slow=fast=head,</span><br><span class="line">        pre=<span class="literal">null</span>,</span><br><span class="line">        nxt;</span><br><span class="line">    <span class="keyword">while</span>(fast&amp;&amp;fast.next) &#123; <span class="comment">//前半部分翻转</span></span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        nxt=slow.next;</span><br><span class="line">        slow.next=pre;</span><br><span class="line">        pre=slow;</span><br><span class="line">        slow=nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast) fast=slow.next;</span><br><span class="line">    <span class="keyword">else</span> fast=slow;</span><br><span class="line">    slow=pre;</span><br><span class="line">    <span class="keyword">while</span>(slow&amp;&amp;fast) &#123; <span class="comment">//开始比较 前半部分和后半部分</span></span><br><span class="line">        <span class="keyword">if</span>(slow.val!==fast.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a>235. Lowest Common Ancestor of a Binary Search Tree</h2><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">q</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">q</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>((root.val-p.val)*(root.val-q.val)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        root=root.val&gt;p.val?root.left:root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">q</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root||root===p||root===q) <span class="keyword">return</span> root; <span class="comment">//边界</span></span><br><span class="line">    <span class="keyword">let</span> l=lowestCommonAncestor(root.left,p,q),</span><br><span class="line">        r=lowestCommonAncestor(root.right,p,q); <span class="comment">//从上往下</span></span><br><span class="line">    <span class="keyword">if</span>(!l) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!r) <span class="keyword">return</span> l; <span class="comment">//从下往上</span></span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">//l r都找到了说明此时的这个节点就是LCA</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a>257. Binary Tree Paths</h2><p>Given a binary tree, return all root-to-leaf paths.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line"></span><br><span class="line">Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    backtrack(res,[],root)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">res,tempArr,root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root&amp;&amp;!root.left&amp;&amp;!root.right) res.push(buildPath([...tempArr,root.val]));</span><br><span class="line">    tempArr.push(root.val);</span><br><span class="line">    backtrack(res,tempArr,root.left);</span><br><span class="line">    backtrack(res,tempArr,root.right);</span><br><span class="line">    tempArr.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildPath</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">        res+=arr[i];</span><br><span class="line">        <span class="keyword">if</span>(i!=arr.length<span class="number">-1</span>) res+=<span class="string">'-&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328. Odd Even Linked List"></a>328. Odd Even Linked List</h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>The relative order inside both the even and odd groups should remain as it was in the input.</li>
<li>The first node is considered odd, the second node even and so on …</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> oddEvenList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> odd=head,</span><br><span class="line">        even=head.next, <span class="comment">//保存头节点，为了后续的拼接</span></span><br><span class="line">        evenCur=even; </span><br><span class="line">    <span class="keyword">while</span>(odd&amp;&amp;evenCur&amp;&amp;evenCur.next) &#123;</span><br><span class="line">        odd.next=odd.next.next;</span><br><span class="line">        odd=odd.next;</span><br><span class="line">        evenCur.next=evenCur.next.next;</span><br><span class="line">        evenCur=evenCur.next;</span><br><span class="line">        cur=odd;</span><br><span class="line">    &#125;</span><br><span class="line">    odd.next=even;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a>377. Combination Sum IV</h2><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">target &#x3D; 4</span><br><span class="line"></span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">Note that different sequences are counted as different combinations.</span><br><span class="line"></span><br><span class="line">Therefore the output is 7.</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>DP: when solve the problem return the count</strong></li>
<li><strong>DFS : for return all the possible result</strong></li>
</ul>
<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum4 = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="built_in">Array</span>(target+<span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;dp.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i-nums[j]&gt;=<span class="number">0</span>) dp[i]+=dp[i-nums[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a>404. Sum of Left Leaves</h2><p>Find the sum of all left leaves in a given binary tree.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isLeaf(root.left)) <span class="keyword">return</span> root.left.val+sumOfLeftLeaves(root.right);</span><br><span class="line">    <span class="keyword">return</span> sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLeaf</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> !root.left&amp;&amp;!root.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="429-N-ary-Tree-Level-Order-Traversal"><a href="#429-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="429. N-ary Tree Level Order Traversal"></a>429. N-ary Tree Level Order Traversal</h2><p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,3,2,4,null,5,6]</span><br><span class="line">Output: [[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res=[],</span><br><span class="line">          stack=[root];</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> len=stack.length,</span><br><span class="line">            temp=[];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            temp.push(stack[i].val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;stack[i].children.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack[i].children[j]) stack.push(stack[i].children[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(temp);</span><br><span class="line">        stack.splice(<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a>437. Path Sum III</h2><p>You are given a binary tree in which each node contains an integer value.</p>
<p>Find the number of paths that sum to a given value.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">sum</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    res+=pathSum(root.left,sum)+pathSum(root.right,sum)+pathSumStartWith(root,sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pathSumStartWith</span>(<span class="params">root,sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val===sum) res++;</span><br><span class="line">    res+=pathSumStartWith(root.left,sum-root.val)+pathSumStartWith(root.right,sum-root.val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="445-Add-Two-Numbers-II"><a href="#445-Add-Two-Numbers-II" class="headerlink" title="445. Add Two Numbers II"></a>445. Add Two Numbers II</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Follow up:</strong><br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack1=[],</span><br><span class="line">          stack2=[],</span><br><span class="line">          stack=[];</span><br><span class="line">    <span class="keyword">let</span> carry=<span class="number">0</span>,</span><br><span class="line">        dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>),</span><br><span class="line">        cur=dummy;</span><br><span class="line">    <span class="keyword">while</span>(l1) &#123;</span><br><span class="line">        stack1.push(l1.val);</span><br><span class="line">        l1=l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2) &#123;</span><br><span class="line">        stack2.push(l2.val);</span><br><span class="line">        l2=l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stack1.length||stack2.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> val1=stack1.length?stack1.pop():<span class="number">0</span>,</span><br><span class="line">            val2=stack2.length?stack2.pop():<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> val=val1+val2+carry;</span><br><span class="line">        stack.push(val%<span class="number">10</span>);</span><br><span class="line">        carry=<span class="built_in">Math</span>.floor(val/<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry) stack.push(carry);</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=<span class="keyword">new</span> ListNode(stack.pop());</span><br><span class="line">        cur.next=node;</span><br><span class="line">        cur=node;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a>454. 4Sum II</h2><p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p>
<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">A &#x3D; [ 1, 2]</span><br><span class="line">B &#x3D; [-2,-1]</span><br><span class="line">C &#x3D; [-1, 2]</span><br><span class="line">D &#x3D; [ 0, 2]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">B</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">C</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">D</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSumCount = <span class="function"><span class="keyword">function</span>(<span class="params">A, B, C, D</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//空间换时间</span></span><br><span class="line">    <span class="keyword">let</span> map=&#123;&#125;,</span><br><span class="line">        res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;A.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;B.length;j++) &#123;</span><br><span class="line">            map[A[i]+B[j]]=(map[A[i]+B[j]]||<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;C.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;D.length;j++) &#123;</span><br><span class="line">            res+=map[-(C[i]+D[j])]||<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a>501. Find Mode in Binary Search Tree</h2><p>Given a binary search tree (BST) with duplicates, find all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics)" target="_blank" rel="noopener">mode(s)</a> (the most frequently occurred element) in the given BST.</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>For example:<br>Given BST <code>[1,null,2,2]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<p>return <code>[2]</code>.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMode = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxVal=[],</span><br><span class="line">        maxNum=<span class="number">0</span>,</span><br><span class="line">        pre=<span class="literal">null</span>,</span><br><span class="line">        nowNum=<span class="number">0</span>;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> maxVal;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inorder</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre&amp;&amp;root.val===pre.val) &#123;</span><br><span class="line">            nowNum++;</span><br><span class="line">            pre=root;</span><br><span class="line">            <span class="keyword">if</span>(nowNum&gt;maxNum) &#123;</span><br><span class="line">                maxNum=nowNum;</span><br><span class="line">                maxVal=[root.val];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nowNum===maxNum) &#123;</span><br><span class="line">                maxVal.push(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre&amp;&amp;root.val!==pre.val) &#123;</span><br><span class="line">            pre=root;</span><br><span class="line">            nowNum=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nowNum===maxNum) maxVal.push(root.val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pre=root;</span><br><span class="line">            nowNum++;</span><br><span class="line">            maxVal=[root.val];</span><br><span class="line">            maxNum=nowNum;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a>513. Find Bottom Left Tree Value</h2><p>Given a binary tree, find the leftmost value in the last row of the tree.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue=[root],</span><br><span class="line">        node;</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123; <span class="comment">//层序遍历的时候可以从右向左放 这样最后一个pop出来的就是最后一行最左边的元素</span></span><br><span class="line">        node=queue.pop();</span><br><span class="line">        <span class="keyword">if</span>(node.right) queue.unshift(node.right);</span><br><span class="line">        <span class="keyword">if</span>(node.left) queue.unshift(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a>518. Coin Change 2</h2><p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;2+2+1</span><br><span class="line">5&#x3D;2+1+1+1</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: amount &#x3D; 3, coins &#x3D; [2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: the amount of 3 cannot be made up just with coins of 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: amount &#x3D; 10, coins &#x3D; [10] </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>



<p><strong>code</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a>530. Minimum Absolute Difference in BST</h2><p>Given a binary search tree with non-negative values, find the minimum <a href="https://en.wikipedia.org/wiki/Absolute_difference" target="_blank" rel="noopener">absolute difference</a> between values of any two nodes.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    &#x2F;</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getMinimumDifference = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node=root,</span><br><span class="line">        stack=[],</span><br><span class="line">        prenode=<span class="literal">null</span>,</span><br><span class="line">        min=<span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span>(node||stack.length) &#123;</span><br><span class="line">        <span class="keyword">while</span>(node) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node=node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> now=stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(prenode) min=<span class="built_in">Math</span>.min(<span class="built_in">Math</span>.abs(now.val-prenode.val),min);</span><br><span class="line">        prenode=now</span><br><span class="line">        node=now.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a>538. Convert BST to Greater Tree</h2><p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: The root of a Binary Search Tree like this:</span><br><span class="line">              5</span><br><span class="line">            &#x2F;   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">Output: The root of a Greater Tree like this:</span><br><span class="line">             18</span><br><span class="line">            &#x2F;   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;<span class="comment">//递归的话 就按照右-根-左累加</span></span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span>,</span><br><span class="line">        cur=root,</span><br><span class="line">        stack=[];</span><br><span class="line">    <span class="keyword">while</span>(cur||stack.length) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node=stack.pop();</span><br><span class="line">        node.val+=sum;</span><br><span class="line">        sum=node.val;</span><br><span class="line">        cur=node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="572-Subtree-of-Another-Tree"><a href="#572-Subtree-of-Another-Tree" class="headerlink" title="572. Subtree of Another Tree"></a>572. Subtree of Another Tree</h2><p>Given two non-empty binary trees <strong>s</strong> and <strong>t</strong>, check whether tree <strong>t</strong> has exactly the same structure and node values with a subtree of <strong>s</strong>. A subtree of <strong>s</strong> is a tree consists of a node in <strong>s</strong> and all of this node’s descendants. The tree <strong>s</strong> could also be considered as a subtree of itself.</p>
<p><strong>Example 1:</strong><br>Given tree s:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>Given tree t:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>Return true, because t has the same structure and node values with a subtree of s.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSubtree = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtree(s.left,t)||isSubtree(s.right,t)||isSubtreeWithRoot(s,t);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSubtreeWithRoot</span>(<span class="params">s,t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s&amp;&amp;!t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!s||!t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.val!=t.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s.left,t.left)&amp;&amp;isSubtreeWithRoot(s.right,t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="589-N-ary-Tree-Preorder-Traversal"><a href="#589-N-ary-Tree-Preorder-Traversal" class="headerlink" title="589. N-ary Tree Preorder Traversal"></a>589. N-ary Tree Preorder Traversal</h2><p>Given an n-ary tree, return the <em>preorder</em> traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Follow up:</strong></p>
<p>Recursive solution is trivial, could you do it iteratively?</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,3,2,4,null,5,6]</span><br><span class="line">Output: [1,3,5,6,2,4]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res=[],</span><br><span class="line">          stack=[root];</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node=stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=node.children.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children[i]) stack.push(node.children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a>617. Merge Two Binary Trees</h2><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>
<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">t1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">t2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span>(<span class="params">t1, t2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t1&amp;&amp;!t2) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(!t1||!t2) <span class="keyword">return</span> t1||t2;</span><br><span class="line">    <span class="keyword">let</span> root=<span class="keyword">new</span> TreeNode(t1.val+t2.val);</span><br><span class="line">    root.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">    root.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a>637. Average of Levels in Binary Tree</h2><p>Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">Output: [3, 14.5, 11]</span><br><span class="line">Explanation:</span><br><span class="line">The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> averageOfLevels = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queue=[root],</span><br><span class="line">          res=[];</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> len=queue.length,</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            sum+=queue[i].val;</span><br><span class="line">            <span class="keyword">if</span>(queue[i].left) queue.push(queue[i].left)</span><br><span class="line">            <span class="keyword">if</span>(queue[i].right) queue.push(queue[i].right)</span><br><span class="line">        &#125;</span><br><span class="line">        sum/=len;</span><br><span class="line">        res.push(sum);</span><br><span class="line">        queue.splice(<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="653-Two-Sum-IV-Input-is-a-BST"><a href="#653-Two-Sum-IV-Input-is-a-BST" class="headerlink" title="653. Two Sum IV - Input is a BST"></a>653. Two Sum IV - Input is a BST</h2><p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target &#x3D; 9</span><br><span class="line"></span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findTarget = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inorder</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,</span><br><span class="line">        j=res.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j) &#123; <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">if</span>(res[i]+res[j]&gt;k) j--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(res[i]+res[j]&lt;k) i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="669-Trim-a-Binary-Search-Tree"><a href="#669-Trim-a-Binary-Search-Tree" class="headerlink" title="669. Trim a Binary Search Tree"></a>669. Trim a Binary Search Tree</h2><p>Given a binary search tree and the lowest and highest boundaries as <code>L</code> and <code>R</code>, trim the tree so that all its elements lies in <code>[L, R]</code> (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  0   2</span><br><span class="line"></span><br><span class="line">  L &#x3D; 1</span><br><span class="line">  R &#x3D; 2</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">    1</span><br><span class="line">      \</span><br><span class="line">       2</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">L</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">R</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trimBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, L, R</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;L) <span class="keyword">return</span> trimBST(root.right,L,R);</span><br><span class="line">    <span class="keyword">if</span>(root.val&gt;R) <span class="keyword">return</span> trimBST(root.left,L,R);</span><br><span class="line">    root.left=trimBST(root.left,L,R);</span><br><span class="line">    root.right=trimBST(root.right,L,R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="671-Second-Minimum-Node-In-a-Binary-Tree"><a href="#671-Second-Minimum-Node-In-a-Binary-Tree" class="headerlink" title="671. Second Minimum Node In a Binary Tree"></a>671. Second Minimum Node In a Binary Tree</h2><p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. More formally, the property <code>root.val = min(root.left.val, root.right.val)</code> always holds.</p>
<p>Given such a binary tree, you need to output the <strong>second minimum</strong> value in the set made of all the nodes’ value in the whole tree.</p>
<p>If no such second minimum value exists, output -1 instead.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    5   7</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The smallest value is 2, the second smallest value is 5.</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findSecondMinimumValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> values=<span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        values.add(root.val);</span><br><span class="line">        getValue(root.left);</span><br><span class="line">        getValue(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    getValue(root);</span><br><span class="line">    <span class="keyword">return</span> values.size&gt;<span class="number">1</span>?[...values].sort()[<span class="number">1</span>]:<span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="725-Split-Linked-List-in-Parts"><a href="#725-Split-Linked-List-in-Parts" class="headerlink" title="725. Split Linked List in Parts"></a>725. Split Linked List in Parts</h2><p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list “parts”.</p>
<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>
<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>
<p>Return a List of ListNode’s representing the linked list parts that are formed.</p>
<p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">root &#x3D; [1, 2, 3], k &#x3D; 5</span><br><span class="line">Output: [[1],[2],[3],[],[]]</span><br><span class="line">Explanation:</span><br><span class="line">The input and each element of the output are ListNodes, not arrays.</span><br><span class="line">For example, the input root has root.val &#x3D; 1, root.next.val &#x3D; 2, \root.next.next.val &#x3D; 3, and root.next.next.next &#x3D; null.</span><br><span class="line">The first element output[0] has output[0].val &#x3D; 1, output[0].next &#x3D; null.</span><br><span class="line">The last element output[4] is null, but it&#39;s string representation as a ListNode is [].</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">root &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k &#x3D; 3</span><br><span class="line">Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class="line">Explanation:</span><br><span class="line">The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<p>The length of <code>root</code> will be in the range <code>[0, 1000]</code>.</p>
<p>Each value of a node in the input will be an integer in the range <code>[0, 999]</code>.</p>
<p><code>k</code> will be an integer in the range <code>[1, 50]</code>.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> splitListToParts = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len=<span class="number">0</span>,</span><br><span class="line">        cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> count1=len%k,</span><br><span class="line">        num1=<span class="built_in">Math</span>.floor(len/k);</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        res[i]=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;k&amp;&amp;root;i++) &#123;</span><br><span class="line">        res[i]=root;</span><br><span class="line">        <span class="keyword">let</span> nowSize=num1+(i&lt;count1?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nowSize<span class="number">-1</span>;j++) &#123;</span><br><span class="line">            root=root.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> nxt=root.next;</span><br><span class="line">        root.next=<span class="literal">null</span>;</span><br><span class="line">        root=nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a>1008. Construct Binary Search Tree from Preorder Traversal</h2><p>Return the root node of a binary <strong>search</strong> tree that matches the given <code>preorder</code> traversal.</p>
<p><em>(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &lt; node.val, and any descendant of node.right has a value &gt; node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)</em></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> bstFromPreorder = <span class="function"><span class="keyword">function</span>(<span class="params">preorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inorder=preorder.slice().sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line">    <span class="keyword">let</span> pLeft=<span class="number">0</span>,</span><br><span class="line">        pRight=preorder.length<span class="number">-1</span>,</span><br><span class="line">        iLeft=<span class="number">0</span>,</span><br><span class="line">        iRight=inorder.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> buildTree(pLeft,pRight,iLeft,iRight)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">buildTree</span>(<span class="params">pLeft,pRight,iLeft,iRight</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pLeft&gt;pRight||iLeft&gt;iRight) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> i=iLeft;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=iRight;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]===preorder[pLeft]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node=<span class="keyword">new</span> TreeNode(preorder[pLeft]);</span><br><span class="line">        node.left=buildTree(pLeft+<span class="number">1</span>,pLeft+i-iLeft,iLeft,i<span class="number">-1</span>);</span><br><span class="line">        node.right=buildTree(pLeft+<span class="number">1</span>+i-iLeft,pRight,i+<span class="number">1</span>,iRight);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1038-Binary-Search-Tree-to-Greater-Sum-Tree"><a href="#1038-Binary-Search-Tree-to-Greater-Sum-Tree" class="headerlink" title="1038. Binary Search Tree to Greater Sum Tree"></a>1038. Binary Search Tree to Greater Sum Tree</h2><p>Given the root of a binary <strong>search</strong> tree with distinct values, modify it so that every <code>node</code> has a new value equal to the sum of the values of the original tree that are greater than or equal to <code>node.val</code>.</p>
<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/05/02/tree.png" alt="img"></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> bstToGst = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack=[],</span><br><span class="line">        cur=root,</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur||stack.length) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node=stack.pop();</span><br><span class="line">        node.val+=sum;</span><br><span class="line">        sum=node.val;</span><br><span class="line">        cur=node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
