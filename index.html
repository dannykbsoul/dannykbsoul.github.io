<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="FOCUS">
<meta property="og:type" content="website">
<meta property="og:title" content="ZJ&#39;s BLOG">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ZJ&#39;s BLOG">
<meta property="og:description" content="FOCUS">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zhou Jun">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>ZJ's BLOG</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?815037cb536c1fda6d297b7d52905c8a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZJ's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/dannykbsoul" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/19/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAplugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/19/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAplugin/" class="post-title-link" itemprop="url">如何编写一个plugin</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-19 13:35:12 / Modified: 15:27:45" itemprop="dateCreated datePublished" datetime="2020-03-19T13:35:12+08:00">2020-03-19</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是plugin"><a href="#什么是plugin" class="headerlink" title="什么是plugin"></a>什么是plugin</h3><p>plugin能帮助我们在webpack打包生成文件的某个时间段帮我们做一些事，类似于Vue中的生命周期函数。例如html-webpack-plugin能帮我们在打包结束生成html文件，并把打包生成的脚本文件插入html中。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/19/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAplugin/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>
    <div>
      
    </div>
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/19/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAloader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/19/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAloader/" class="post-title-link" itemprop="url">如何编写一个loader</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-19 11:36:45 / Modified: 15:10:48" itemprop="dateCreated datePublished" datetime="2020-03-19T11:36:45+08:00">2020-03-19</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是loader"><a href="#什么是loader" class="headerlink" title="什么是loader"></a>什么是loader</h3><p>loader其实是一种打包方案，loader可以将所有类型的文件转换为webpac能够处理的有效模块，然后你就可以利用webpack的打包能力，对它们进行处理。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/19/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAloader/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>
    <div>
      
    </div>
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/19/webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/19/webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">webpack性能优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-19 09:33:04" itemprop="dateCreated datePublished" datetime="2020-03-19T09:33:04+08:00">2020-03-19</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<ol>
<li><p>及时更新版本（node，npm等），新版本一般都会有提高打包效率的新特性。</p>
</li>
<li><p>在尽可能少的模块上应用<code>loader</code>。可以优化文件搜索范围（即在rule中写include或exclude），eg. 可以不用编译<code>node_modules</code>中的代码，因为里面的都是被打包编译过的。</p>
</li>
<li><p>plugin尽可能精简并确保可靠，也尽可能少用。eg.我在prod环境下用到了<em>OptimizeCSSAssetsPlugin</em>这个插件，用于css代码的压缩，可以保证用户加载的文件尽可能的小。但是如果是在dev环境下，就不需要这个plugin，可以不用考虑用户加载速度的问题，这样的话可以提高dev环境下的打包时间。</p>
</li>
<li><p>resolve参数合理配置</p>
<p> <code>import</code>或<code>require</code>的时候可以不用写文件名后缀，而在<code>resolve</code>中写<code>resolve.extensions</code>，并尽可能减少后缀列表长度，将出现频率高的后缀排在前面。<br> <code>resolve.alias</code>：设置别名的方式映射一个路径，让webpack更快找到路径。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>], <span class="comment">//先找有没有后缀为.js的文件，没有的话再找后缀为.jsx的文件。</span></span><br><span class="line">    mainFiles: [<span class="string">'index'</span>, <span class="string">'child'</span>], <span class="comment">//先找路径下有没有文件名为index的文件，再找文件名为child的文件。</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">        child: path.resolve(__dirname, <span class="string">'src/child/child'</span>), <span class="comment">//取别名，页面上可以直接引入import child from 'child'引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>DllPlugin</code>提高打包速度(通过把一些库文件存起来，不让它每一次都重新打包)。这种方式可以极大的减少打包类库的次数。主要当类库更新版本才有需要重新打包。</p>
<p> DllPlugin与DllReferencePlugin可以用来<strong>预构建</strong>vendor包，这样只要一次预构建后没有额外的依赖变更，那么启动开发环境的速度就会显著提升。实际上DllPlugin是只用于开发环境的。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 配置webpack.dll.js文件，对第三方模块单独进行打包，生成打包结果。</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'production'</span>,</span><br><span class="line">    entry: &#123;  <span class="comment">//需要进行打包的第三方模块代码</span></span><br><span class="line">        vendors: [<span class="string">'lodash'</span>],</span><br><span class="line">        react: [<span class="string">'react-dom'</span>, <span class="string">'react'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'./dll'</span>),</span><br><span class="line">        library: <span class="string">'[name]'</span> <span class="comment">//通过全局变量暴露出去</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123; <span class="comment">//生成映射文件</span></span><br><span class="line">            name: <span class="string">'[name]'</span>,</span><br><span class="line">            path: path.resolve(__dirname, <span class="string">'./dll/[name].manifest.json'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> 把生成的文件引入到html中，并引入分析映射文件。webpack.common.js文件下</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="comment">// title: 'webpack-study',</span></span><br><span class="line">        template: <span class="string">'./index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123; <span class="comment">//把生成的dll文件挂载到html文件中</span></span><br><span class="line">        filepath: path.resolve(__dirname, <span class="string">'./dll/vendors.dll.js'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> addAssetHtmlWebpackPlugin(&#123; <span class="comment">//把生成的dll文件挂载到html文件中</span></span><br><span class="line">        filepath: path.resolve(__dirname, <span class="string">'./dll/react.dll.js'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123; <span class="comment">//分析引入映射文件</span></span><br><span class="line">        manifest: path.resolve(__dirname, <span class="string">'./dll/vendors.manifest.json'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123; <span class="comment">//分析引入映射文件</span></span><br><span class="line">        manifest: path.resolve(__dirname, <span class="string">'./dll/react.manifest.json'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制包文件的大小</p>
<p> <code>TreeShaking</code>：可以删除项目中未被引用的代码<br> <code>懒加载</code>：实现按需加载，多写异步代码，提高页面的代码使用率</p>
</li>
<li><p><code>thread-loader</code>和<code>happypack</code>可以可以利用node中的多进程，同时利用多个CPO对项目打包；对多页面应用，使用<code>parallel-webpack</code>可以实现对多个页面一起打包。因为Node是单线程运行的，所以Webpack在打包的过程中也是单线程的，特别是在执行Loader的时候，这样会导致等待的情况。HappyPack可以将Loader的同步执行转换为并行的</p>
</li>
<li><p>合理使用sourceMap:用对<code>devtool</code>配置，在开发模式建议用<code>cheap-module-eval-source-map</code>；在生产模式建议用<code>cheap-module-source-map</code></p>
</li>
<li><p>结合stats分析打包结果</p>
</li>
<li><p>开发环境内存编译。开发环境我们用的webpackDevServer，打包的时候不会生成dist目录，而是将编译生成的文件放到内存中，内存的读取肯定要比硬盘的读取快的多，从而提高开发环境下webpack打包的性能。</p>
</li>
<li><p>开发环境无用插件剔除。eg. 开发环境下，我们不需要对代码进行压缩，所以要将mode设置为development而不是production，压缩很降低webpack的性能，只有在生产环境下才需要压缩，提高用户的体验。</p>
</li>
</ol>

      
    </div>
    <div>
      
    </div>
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/webpack%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/webpack%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">webpack整理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-15 23:02:26" itemprop="dateCreated datePublished" datetime="2020-03-15T23:02:26+08:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-19 09:34:02" itemprop="dateModified" datetime="2020-03-19T09:34:02+08:00">2020-03-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>18 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、Webpack初探"><a href="#一、Webpack初探" class="headerlink" title="一、Webpack初探"></a>一、Webpack初探</h1><p><strong>webpack</strong> is a module bundler</p>
<blockquote>
<p>模块打包工具，能够识别任何模块引入的语法</p>
</blockquote>
<p>npm npx</p>
<p>npm全称：node.js package manager，是一款node.js的包管理工具。<br>npx全称: node.js package execute，是一个node.js的包执行工具。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/15/webpack%E6%95%B4%E7%90%86/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>
    <div>
      
    </div>
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/13/GoWhere%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/13/GoWhere%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">GoWhere项目总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-13 10:32:32" itemprop="dateCreated datePublished" datetime="2020-03-13T10:32:32+08:00">2020-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-14 21:56:01" itemprop="dateModified" datetime="2020-03-14T21:56:01+08:00">2020-03-14</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-多页应用-vs-单页应用"><a href="#1-多页应用-vs-单页应用" class="headerlink" title="1.多页应用 vs 单页应用"></a>1.多页应用 vs 单页应用</h2><p><strong>多页应用</strong></p>
<p>每一次的页面的跳转，后端都要返回一个新的HTML文件。</p>
<p>优点：首屏会非常快，SEO效果好，每次只发送了一次HTTP请求。</p>
<p>缺点：页面切换慢，每次跳转页面都要发送HTTP请求，所以网络不好的情况下，会有明显的卡顿情况。</p>
<p><strong>单页应用</strong></p>
<p>如果做到不请求HTML，页面也会变呢？JS会感知到url的变化，JS动态的把当前页面的内容清除掉，再把下一个页面的内容挂载到页面上。页面跳转是通过JS渲染实现。</p>
<p>优点：页面切换快</p>
<p>缺点：首屏时间稍慢，SEO差，首屏除了要请求一个HTML，还要发送一次JS请求。</p>
<p>适配移动端，禁止用户通过手势缩放页面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>reset.css是为了消除不同的浏览器在默认样式上不同表现，使得项目在所有浏览器上的表现一致。</p>
<p>移动端1px边框</p>
<p>原因：<br>我们做移动端页面时一般都会设置meta标签viewport的content=width=device-width，<br>这里就是把html视窗大小设置等于设备的大小，大多数手机的屏幕设备宽度都差不多，<br>以iphoneX为例，屏幕宽度375px。</p>
<p>而UI给设计图的时候基本上都是给的二倍图甚至三倍图，假设设计图是750px的二倍图，在750px上设计了1px的边框，要拿到375px宽度的手机来显示，就相当于缩小了一倍，所以1px的边框要以0.5px来呈现才符合预期效果，然而css里最低只支持1px大小，不足1px就以1px显示，所以你看到的就显得边框较粗，实际上只是设计图整体缩小了，而边框粗细没有跟着缩小导致的。（ps：ios较新版已经支持0.5px了，这里暂且忽略）</p>
<p>简而言之就是：多倍的设计图设计了1px的边框，在手机上缩小呈现时，由于css最低只支持显示1px大小，导致边框太粗的效果。</p>
<p>移动端300ms点击事件延迟的问题</p>
<p><strong>由于移动端会有双击缩放的这个操作，因此浏览器在click之后要等待300ms，看用户有没有下一次点击，也就是这次操作是不是双击。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install fastclick --save</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fastClick <span class="keyword">from</span> <span class="string">'fastclick'</span></span><br><span class="line"></span><br><span class="line">fastClick.attach(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure>



<p>路由就是根据网址的不同，返回不同的内容给用户</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示的是当前路由地址所对应的内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>stylus</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install stylus --save</span><br><span class="line">npm install stylus-loader --save</span><br></pre></td></tr></table></figure>



<p>scoped：只对当前的组件有效</p>
<p>移动端布局一般采用rem的布局</p>
<p>rem是一个相对单位，1rem等于html元素上字体设置的大小。我们只要设置html上font-size的大小，就可以改变rem所代表的大小。</p>
<p>1rem=html font-size=50px</p>
<p>在二倍图上的86px，实际上是我们要写成43px</p>
<p>iconfont的引入，全局main.js下需要引入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//标签放在span中，内容用十六进制的字符串</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"iconfont"</span>&gt;</span><span class="symbol">&amp;#xe624;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>css全局变量，比如背景色，在项目中多处用到，如果我需要改变的话，不需要一个个的去修改</p>
<p>在assets文件夹下创建varibles.styl的文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$bgColor = #00bcd4</span><br></pre></td></tr></table></figure>

<p>然后在你需要用到的地方引入，后面直接写变量就行了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'../../../assets/varibles.styl'</span></span><br></pre></td></tr></table></figure>



<p>@import</p>
<p><code>@import</code> 用于从其他样式表导入样式规则，告诉 CSS 引擎引入一个外部样式表。</p>
<p>如果在css里面也想简化路径的话，需要在@符号前加~</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'~@/assets/varibles.styl'</span></span><br></pre></td></tr></table></figure>

<p>或者说我们可以在webpack.base.conf.js里面自定义配置路径别名。</p>
<p><img src="/2020/03/13/GoWhere%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/1.png" alt></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'~styles/varibles.styl'</span></span><br></pre></td></tr></table></figure>



<p><strong>简单来说，BFC就是一个独立不干扰外界也不受外界干扰的盒子</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang="stylus" scoped&gt;</span><br><span class="line"><span class="selector-class">.wrapper</span> &gt;&gt;&gt; <span class="selector-class">.swiper-pagination-bullet-active</span></span><br><span class="line">  <span class="selector-tag">background-color</span>: <span class="selector-id">#fff</span></span><br><span class="line"><span class="selector-class">.wrapper</span></span><br><span class="line">  // overflow: hidden</span><br><span class="line">  // width: 100%</span><br><span class="line">  // height: 0</span><br><span class="line">  // padding-bottom: 31.25%</span><br><span class="line">  <span class="selector-tag">width</span>: 100%</span><br><span class="line">  <span class="selector-tag">height</span>: 31<span class="selector-class">.25vw</span></span><br><span class="line">  <span class="selector-class">.swiper-img</span></span><br><span class="line">    <span class="selector-tag">width</span>: 100%</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>使用&gt;&gt;&gt;可以让wrapper下的指定类的样式，样式穿透，不受scoped的限制</p>
<p><img src="/2020/03/13/GoWhere%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/2.png" alt></p>
<p>对于图标的轮播图，需要对数据进行分页处理</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:options</span>=<span class="string">"swiperOption"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">swiper-slide</span> <span class="attr">v-for</span>=<span class="string">"(page, index) of pages"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">v-for</span>=<span class="string">"item of page"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon-img"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"icon-img-content"</span> <span class="attr">:src</span>=<span class="string">"item.imgUrl"</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"icon-desc"</span>&gt;</span>&#123;&#123; item.desc &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    pages() &#123;</span><br><span class="line">      <span class="keyword">const</span> pages = [];</span><br><span class="line">      <span class="keyword">this</span>.iconList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> page = <span class="built_in">Math</span>.floor(index / <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (pages[page]) pages[page].push(item);</span><br><span class="line">        <span class="keyword">else</span> pages[page] = [item];</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> pages;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>利用computed计算数据以及缓存特性，可以对数据进行分页展示</p>
<p>对于文字过于多想要<code>...</code>显示的话</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span></span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span></span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span></span><br></pre></td></tr></table></figure>





<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class = "border-bottom"</span><br></pre></td></tr></table></figure>

<p>1像素的边框</p>
<p><img src="/2020/03/13/GoWhere%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/3.png" alt></p>
<p>vuex中getters的作用类似于组件中的computed，当我们需要根据state里面的数据算出新的数据，我们可以借助getters来避免数据的冗余</p>
<p>刷新页面以后swiper的默认显示是在最后一张图，而不是第一张图，主要是swiper一开始是空数组，后面ajax才请求到了数据。</p>
<p>解决方案：可以在swiper上添加v-if，如果数组的长度为空，那么不渲染swiper组件，可以用computed计算属性。避免在模版中写逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;swiper :options=<span class="string">"swiperOption"</span> v-<span class="keyword">if</span>=<span class="string">"showSwiper"</span>&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    showSwiper() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.list.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>alphabet组件和list组件属于同级，但是需要联动，那么可以通过父组件city传递，alphabet组件emit，city组件接受到emit过来的事件，然后在city组件向list组件传递值，list组件watch传递过来的变化。从而实现非父子之间的传值</p>
<p>手指在alphabet上拖动，如何让列表也随之变化。</p>
<p>可以根据(手指距离顶部的距离-第一个字母距离顶部的距离)/俩个字母之间距离，便可以知道此时是在第几个字母，然后触发事件。但是可以看出此时的事件触发频率太高了，可以通过防抖实现性能优化，每次执行都是在最后一次触发事件的16ms后触发，如果16ms内再次出发了事件，那么重新计时。</p>
<p>使用keep-alive优化网页性能</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>路由的内容被加载过一次之后，我就把路由中的内容放到内存之中，下次再进这个路由，不需要重新执行钩子函数，只需要从内存中重新拿出来就好了。</p>
<p>但是会存在问题，比如说我从首页进入选择城市页面，选择了另一个城市，此时返回首页，由于有keep-alive的存在，不会根据新的城市从而首页改变，还是从缓存中拿，那么可以借助activated钩子函数实现，activated钩子是在页面重新被显示的时候执行。</p>

      
    </div>
    <div>
      
    </div>
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/13/CSS%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/13/CSS%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">CSS页面布局</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-13 10:05:00 / Modified: 10:20:43" itemprop="dateCreated datePublished" datetime="2020-03-13T10:05:00+08:00">2020-03-13</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>637</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-什么是标签语义化？"><a href="#1-什么是标签语义化？" class="headerlink" title="1.什么是标签语义化？"></a>1.什么是标签语义化？</h2><p>用正确的标签做正确的事情！</p>
<ul>
<li>HTML 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；</li>
<li>在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的；</li>
<li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO；</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li>
</ul>
<p>比如，</p>
<ul>
<li>标题可以用 <code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code>；</li>
<li>边栏用 <code>&lt;aside&gt;</code>；</li>
<li>头部用 <code>&lt;header&gt;</code>；</li>
<li>主体内容用 <code>&lt;main&gt;</code>；</li>
<li>页脚用 <code>&lt;footer&gt;</code>；</li>
</ul>
<p>等等。</p>
<h2 id="2-前端需要注意哪些-SEO？"><a href="#2-前端需要注意哪些-SEO？" class="headerlink" title="2.前端需要注意哪些 SEO？"></a>2.前端需要注意哪些 SEO？</h2><p><strong>1. 合理的 title、description、keywords</strong>：</p>
<ul>
<li>搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；</li>
<li>description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；</li>
<li>keywords 列举出重要关键词即可。</li>
</ul>
<p><strong>2. 语义化的 HTML 代码，符合 W3C 规范</strong>：语义化代码让搜索引擎容易理解网页；</p>
<p><strong>3. 重要内容 HTML 代码放在最前</strong>：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取；</p>
<p><strong>4. 重要内容不要用  输出</strong>：爬虫不会执行 JS 获取内容；</p>
<p><strong>5. 少用 iframe</strong>：搜索引擎不会抓取 iframe 中的内容；</p>
<p><strong>6. 非装饰性图片必须加 alt；</strong></p>
<p><strong>7. 提高网站速度</strong>：网站速度是搜索引擎排序的一个重要指标。</p>

      
    </div>
    <div>
      
    </div>
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">从输入URL到页面加载发生了什么?</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-08 18:33:24" itemprop="dateCreated datePublished" datetime="2020-03-08T18:33:24+08:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-11 21:34:06" itemprop="dateModified" datetime="2020-03-11T21:34:06+08:00">2020-03-11</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>28 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="1-根据域名-进行DNS域名解析"><a href="#1-根据域名-进行DNS域名解析" class="headerlink" title="1.根据域名,进行DNS域名解析"></a>1.根据域名,进行DNS域名解析</h2><p>URL一般包括几大部分：</p>
<ul>
<li><code>protocol</code>，协议头，譬如有http，ftp等</li>
<li><code>host</code>，主机域名或IP地址</li>
<li><code>port</code>，端口号</li>
<li><code>path</code>，目录路径</li>
<li><code>query</code>，即查询参数</li>
<li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</li>
</ul>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/11.png" alt></p>
<h2 id="2-拿到解析的IP地址，建立TCP连接"><a href="#2-拿到解析的IP地址，建立TCP连接" class="headerlink" title="2.拿到解析的IP地址，建立TCP连接"></a>2.拿到解析的IP地址，建立TCP连接</h2><h2 id="3-向IP地址，发送HTTP请求"><a href="#3-向IP地址，发送HTTP请求" class="headerlink" title="3.向IP地址，发送HTTP请求"></a>3.向IP地址，发送HTTP请求</h2><p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/12.png" alt></p>
<p>SSL(Secure Sockets Layer 安全套接层):主要用于web的安全传输协议,在传输层对网络连接进行加密,保障在Internet上数据传输的安全。</p>
<p>https与http的区别就是：<strong>在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析</strong></p>
<p>http端口号80</p>
<p>https端口号443</p>
<blockquote>
<p>http请求报文是由三部分组成:<code>请求行</code>、<code>请求报头</code>和<code>请求正文</code></p>
<p>请求正文:    当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。</p>
</blockquote>
<blockquote>
<p>get和post的区别:</p>
<ol>
<li>都是基于http协议的，本质都是TCP连接，没有区别，可以在URL写上参数，然后POST请求，也可以在body上写参数，然后方法使用GET请求</li>
<li>一般说的GET请求浏览器地址栏输入的参数有限制，首先说明一点，HTTP协议没有BODY和URL长度的限制，对其限制的大多是浏览器和服务器的原因。服务器是因为处理长URL要消耗比较多的资源，为了性能和安全（防止恶意构造长URL来攻击）考虑，会给URL长度加限制。</li>
<li>虽然说POST比GET相对安全，但是从传输角度来说，都是不安全的，HTTP在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文，想要安全只有HTTPS。</li>
</ol>
</blockquote>
<p><code>五层因特尔协议栈</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>应用层(dns,http) DNS解析成IP并发送http请求</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>传输层(tcp,udp) 建立tcp连接（三次握手）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>网络层(IP,ARP) IP寻址</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>数据链路层(PPP) 封装成帧</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/13.png" alt></p>
<h2 id="4-服务器处理请求并返回HTTP报文"><a href="#4-服务器处理请求并返回HTTP报文" class="headerlink" title="4.服务器处理请求并返回HTTP报文"></a>4.服务器处理请求并返回HTTP报文</h2><blockquote>
<p>http响应报文也是由三部分组成:<code>状态码</code>、<code>响应报头</code>和<code>响应报文</code></p>
<p>状态码:</p>
<ul>
<li><p>1xx：指示信息–表示请求已接收，继续处理。</p>
<blockquote>
<p><code>100 Continue</code>：该状态码说明服务器收到了请求的初始部分，并且请客户端继续发送。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>101(切换协议)</code> 请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
</blockquote>
<ul>
<li><p>2xx：成功–表示请求已被成功接收、理解、接受。</p>
<blockquote>
<p><code>200(成功)</code>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>201(已创建)</code>请求成功并且服务器创建了新的资源。</p>
<p><code>202(已接受)</code>服务器已接受请求，但尚未处理。</p>
<p><code>204(无内容)</code>服务器成功处理了请求，但没有返回任何内容。等同于请求执行成功，但是没有数据，浏览器不用刷新页面也不用导向新的页面。</p>
<p><code>206(部分内容)</code>服务器成功处理了部分 GET 请求。</p>
</blockquote>
<ul>
<li><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p>
<blockquote>
<p><code>301(永久移动)</code>请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或HEAD请求的响应）时，会自动将请求者转到新位置。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>302(临时移动)</code>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<p><code>304(未修改)</code>自从上次请求后，请求的网页未修改过，请客户端使用本地缓存。 服务器返回此响应时，不会返回网页内容。</p>
<p>浏览器需要向服务器询问一次，如果服务器端认为没有内容更新，直接返回304状态码，无需返回body内容，浏览器就会直接取缓存内容输出，这样省掉了没必要的数据传输，也就提升了访问速度。</p>
</blockquote>
<ul>
<li><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p>
<blockquote>
<p><code>400(错误请求)</code>服务器不理解请求的语法。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>401(未授权)</code>请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p>
<p><code>402</code> 该状态码是为了将来可能的需求而预留的。</p>
<p><code>403(禁止)</code>服务器拒绝请求。</p>
<p><code>404(未找到)</code>服务器找不到请求的网页。</p>
</blockquote>
<ul>
<li><p>5xx：服务器端错误–服务器未能实现合法的请求。</p>
<blockquote>
<p><code>500(服务器内部错误)</code>服务器遇到错误，无法完成请求。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>503(服务不可用)</code>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</p>
</blockquote>
</blockquote>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/14.png" alt></p>
<p>cookie以及优化:</p>
<blockquote>
<p>一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在cookie中设置httponly（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）<br>另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。</p>
<p>譬如以下场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line">然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有<span class="number">20</span>个静态资源）</span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line">也就是说，这<span class="number">20</span>个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure>

<p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p>
<ol>
<li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li>
<li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的cookie的，所以就避免了浪费</li>
</ol>
<p><code>dns-prefetch</code>:<code>DNS</code> 预解析技术，当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行<code>DNS</code> 的解析，减少用户等待时间，提高用户体验。 <img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/15.png" alt></p>
<p>以上是天猫中dns-prefetch的使用<img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/16.png" alt></p>
</blockquote>
<h3 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h3><p>tcp/ip层面:</p>
<ul>
<li>长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li>
<li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li>
</ul>
<p>http层面:</p>
<ul>
<li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器每进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接。</li>
<li>http1.1起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li>
</ul>
<h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><p>http1.1和http2.0区别:</p>
<ul>
<li>http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li>
<li>http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li>
</ul>
<p>新特性:</p>
<ul>
<li>多路复用（即一个tcp/ip连接可以请求多个资源）</li>
<li>首部压缩（http头部压缩，减少体积）</li>
<li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li>
<li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li>
<li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li>
</ul>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/17.png" alt></p>
<p>当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有”要请求资源”的副本，就可以直接从浏览器缓存中提取，而不是从原始服务器中提取这个资源，<code>常见的http缓存只能缓存get请求响应的资源</code>，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/18.png" alt></p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/19.png" alt></p>
<p>Pragma和Cache-control共存时，Pragma的优先级是比Cache-Control高的。</p>
<p>在chrome浏览器中返回的200状态会有两种情况：<br>1、from memory cache<br>(从内存中获取/一般缓存更新频率较高的js、图片、字体等资源)</p>
<p>2、from disk cache<br>(从磁盘中获取/一般缓存更新频率较低的js、css等资源)</p>
<p>这两种情况是chrome自身的一种缓存策略，这也是为什么chrome浏览器响应的快的原因。其他浏览返回的是已缓存状态，没有标识是从哪获取的缓存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回<span class="number">304</span>状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回<span class="number">200</span>状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/20.png" alt></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协商缓存的执行流程是这样的：当浏览器第一次向服务器发送请求时，会在响应头中返回协商缓存的头属性：ETag和Last-Modified,其中ETag返回的是一个hash值，Last-Modified返回的是GMT格式的最后修改时间。然后浏览器在第二次发送请求的时候，会在请求头中带上与ETag对应的If-Not-Match，其值就是响应头中返回的ETag的值，Last-Modified对应的If-Modified-Since。服务器在接收到这两个参数后会做比较，如果返回的是<span class="number">304</span>状态码，则说明请求的资源没有修改，浏览器可以直接在缓存中取数据，否则，服务器会直接返回数据。</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/21.png" alt></p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/22.png" alt></p>
<p><strong>注意：</strong><br>ETag/If-Not-Match是在HTTP/1.1出现的，主要是解决以下问题：</p>
<ol>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件被修改了，但是内容并没有任何变化，而Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ol>
<h3 id="为什么使用HTTP缓存"><a href="#为什么使用HTTP缓存" class="headerlink" title="为什么使用HTTP缓存:"></a>为什么使用HTTP缓存:</h3><ol>
<li>减少了冗余的数据传输，节省了网费。</li>
<li>缓解了服务器的压力，大大提高了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<p>注意点：</p>
<ul>
<li><p>强缓存情况下，只要缓存还没过期，就会直接从缓存中取数据，就算服务器端有数据变化，也不会从服务器端获取了，这样就无法获取到修改后的数据。决解的办法有：在修改后的资源加上随机数,确保不会从缓存中取。</p>
<p>  例如：<br>  <a href="http://www.kimshare.club/kim/common.css?v=22324432" target="_blank" rel="noopener">http://www.kimshare.club/kim/common.css?v=22324432</a><br>  <a href="http://www.kimshare.club/kim/common.2312331.css" target="_blank" rel="noopener">http://www.kimshare.club/kim/common.2312331.css</a></p>
</li>
<li><p>尽量减少304的请求，因为我们知道，协商缓存每次都会与后台服务器进行交互，所以性能上不是很好。从性能上来看尽量多使用强缓存。</p>
</li>
<li><p>在Firefox浏览器下，使用Cache-Control: no-cache 是不生效的，其识别的是no-store。这样能达到其他浏览器使用Cache-Control: no-cache的效果。所以为了兼容Firefox浏览器，经常会写成Cache-Control: no-cache，no-store。</p>
</li>
<li><p>与缓存相关的几个header属性有：Vary、Date/Age。</p>
</li>
</ul>
<h3 id="SUMMARY"><a href="#SUMMARY" class="headerlink" title="SUMMARY"></a>SUMMARY</h3><ul>
<li>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行协商缓存策略。</li>
<li>对于协商缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</li>
</ul>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/23.png" alt="4845448-4b270d197649b733"></p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/24.png" alt></p>
<h2 id="5-浏览器解析渲染页面"><a href="#5-浏览器解析渲染页面" class="headerlink" title="5.浏览器解析渲染页面"></a>5.浏览器解析渲染页面</h2><p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/25.png" alt></p>
<p>浏览器渲染过程大体分为如下三部分：</p>
<h3 id="1-浏览器会解析三个东西："><a href="#1-浏览器会解析三个东西：" class="headerlink" title="1.浏览器会解析三个东西："></a>1.浏览器会解析三个东西：</h3><ul>
<li><p>一是HTML/SVG/XHTML，HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构。</p>
</li>
<li><p>二是CSS，解析CSS会产生CSS规则树，它和DOM结构比较像。</p>
</li>
<li><p>三是Javascript脚本，等到Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。</p>
</li>
</ul>
<h3 id="2-解析完成后，浏览器引擎会通过DOM-Tree和CSS-Rule-Tree来构造Rendering-Tree。"><a href="#2-解析完成后，浏览器引擎会通过DOM-Tree和CSS-Rule-Tree来构造Rendering-Tree。" class="headerlink" title="2.解析完成后，浏览器引擎会通过DOM Tree和CSS Rule Tree来构造Rendering Tree。"></a>2.解析完成后，浏览器引擎会通过DOM Tree和CSS Rule Tree来构造Rendering Tree。</h3><ul>
<li>Rendering Tree 渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息。</li>
<li>CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element（也就是每个Frame）。</li>
<li>然后，计算每个Frame 的位置，这又叫layout和reflow过程。</li>
</ul>
<h3 id="3-最后通过调用操作系统Native-GUI的API绘制。"><a href="#3-最后通过调用操作系统Native-GUI的API绘制。" class="headerlink" title="3.最后通过调用操作系统Native GUI的API绘制。"></a>3.最后通过调用操作系统Native GUI的API绘制。</h3><h3 id="构建DOM"><a href="#构建DOM" class="headerlink" title="构建DOM"></a>构建DOM</h3><p>浏览器会遵守一套步骤将HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/26.png" alt></p>
<ul>
<li><p>浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p>
</li>
<li><p>将字符串转换成Token，例如：<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>等。<strong>Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息</strong>。事实上，这就是Token要标识“起始标签”和“结束标签”等标识的作用。例如“title”Token的起始标签和结束标签之间的节点肯定是属于“head”的子节点。 </p>
<p>  <img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/27.png" alt></p>
<p>  上图给出了节点之间的关系，例如：“Hello”Token位于“title”开始标签与“title”结束标签之间，表明“Hello”Token是“title”Token的子节点。同理“title”Token是“head”Token的子节点。</p>
</li>
<li><p>生成节点对象并构建DOM</p>
<p>  事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。<strong>注意：带有结束标签标识的Token不会创建节点对象。</strong></p>
</li>
</ul>
<p>接下来我们举个例子，假设有段HTML文本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面这段HTML会解析成这样：</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/28.png" alt></p>
<h3 id="构建CSSOM"><a href="#构建CSSOM" class="headerlink" title="构建CSSOM"></a>构建CSSOM</h3><p>DOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。</p>
<p>构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。 </p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/29.png" alt></p>
<p> 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归CSSOM树，然后确定具体的元素到底是什么样式。</p>
<p><strong>注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去</strong>。</p>
<h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/30.png" alt></p>
<p>在这一过程中，不是简单的将两者合并就行了。<strong>渲染树只会包括需要显示的节点和这些节点的样式信息</strong>，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</p>
<p>我们或许有个疑惑：<strong>浏览器如果渲染过程中遇到JS文件怎么处理</strong>？</p>
<p>渲染过程中，如果遇到<code>&lt;script&gt;</code>就停止渲染，执行JS代码。因为浏览器有GUI渲染线程与JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。</p>
<p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载JS文件，这也是都建议将script标签放在body标签底部的原因。当然在当下，并不是说script标签必须放在底部，因为你可以给script标签添加defer或者 async属性（下文会介绍这两者的区别）。</p>
<p><strong>JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建</strong>。</p>
<p>原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。</p>
<p>这是什么情况？</p>
<p>这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，<strong>在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM</strong>。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/31.png" alt></p>
<h3 id="布局与绘制"><a href="#布局与绘制" class="headerlink" title="布局与绘制"></a>布局与绘制</h3><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p>
<p>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。</p>
<p>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</p>
<h3 id="JS中的三种加载模式"><a href="#JS中的三种加载模式" class="headerlink" title="JS中的三种加载模式"></a>JS中的三种加载模式</h3><p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/32.png" alt></p>
<ul>
<li><p>正常模式：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  这种情况下JS会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。</p>
</li>
<li><p>async 模式：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  async模式下，JS不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS脚本会<strong>立即执行</strong>。</p>
</li>
<li><p>defer 模式：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  defer模式下，JS的加载是异步的，执行是<strong>被推迟的</strong>。等整个文档解析完成、DOMContentLoaded事件即将被触发时，被标记了defer的JS文件才会开始依次执行。</p>
</li>
</ul>
<p>从应用的角度来说，一般当我们的脚本与DOM元素和其它脚本之间的依赖关系不强时，我们会选用async；当脚本依赖于DOM元素和其它脚本的执行结果时，我们会选用defer。</p>
<h3 id="基于渲染流程的-CSS-优化建议"><a href="#基于渲染流程的-CSS-优化建议" class="headerlink" title="基于渲染流程的 CSS 优化建议"></a>基于渲染流程的 CSS 优化建议</h3><p>CSS引擎查找样式表，对每条规则都按从右到左的顺序去匹配。 看如下规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#myList</span>  <span class="selector-tag">li</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这样的写法其实很常见。大家平时习惯了从左到右阅读的文字阅读方式，会本能地以为浏览器也是从左到右匹配 CSS 选择器的，因此会推测这个选择器并不会费多少力气：#myList 是一个id选择器，它对应的元素只有一个，查找起来应该很快。定位到了myList元素，等于是缩小了范围后再去查找它后代中的li元素，没毛病。</p>
<p>事实上，<strong>CSS选择符是从右到左进行匹配的</strong>。我们这个看似“没毛病”的选择器，实际开销相当高：浏览器必须遍历页面上每个li元素，并且每次都要去确认这个li元素的父元素id是不是myList。</p>
<p>经典的通配符：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>入门CSS的时候，不少同学拿通配符清除默认样式（我曾经也是通配符用户的一员）。但这个家伙很恐怖，它会匹配所有元素，所以浏览器必须去遍历每一个元素！</p>
<p>这样一看，一个小小的CSS选择器，也有不少的门道！好的CSS选择器书写习惯，可以为我们带来非常可观的性能提升。根据上面的分析，我们至少可以总结出如下性能提升的方案：</p>
<ul>
<li><p>避免使用通配符，只对需要用到的元素进行选择。</p>
</li>
<li><p>关注可以通过继承实现的属性，避免重复匹配重复定义。</p>
</li>
<li><p>少用标签选择器。如果可以，用类选择器替代，举个🌰：</p>
<p>  错误示范：</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#myList</span> <span class="selector-tag">li</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>  课代表：</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.myList_li</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要画蛇添足，id和class选择器不应该被多余的标签选择器拖后腿。举个🌰：</p>
<p>  错误示范</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.myList</span><span class="selector-id">#title</span></span><br></pre></td></tr></table></figure>

<p>  课代表</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#title</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。</p>
</li>
</ul>
<h3 id="DOM为什么这么慢？"><a href="#DOM为什么这么慢？" class="headerlink" title="DOM为什么这么慢？"></a>DOM为什么这么慢？</h3><p><strong>因为收了“过路费”</strong></p>
<blockquote>
<p>把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》</p>
</blockquote>
<p>JS 是很快的，在JS中修改DOM对象也是很快的。在JS的世界里，一切是简单的、迅速的。但DOM操作并非JS 一个人的独舞，而是两个模块之间的协作。</p>
<p>上一节我们提到，JS 引擎和渲染引擎（浏览器内核）是独立实现的。当我们用JS去操作 DOM 时，本质上是JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/33.png" alt></p>
<p>过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。</p>
<p>很多时候，我们对 DOM 的操作都不会局限于访问，而是为了修改它。当我们对 DOM 的修改会引发它外观（样式）上的改变时，就会触发<strong>回流</strong>或<strong>重绘</strong>。</p>
<p>这个过程本质上还是因为我们对 DOM 的修改触发了渲染树（Render Tree）的变化所导致的：</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/34.png" alt></p>
<ul>
<li>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</li>
<li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</li>
</ul>
<p>由此我们可以看出，<strong>重绘不一定导致回流，回流一定会导致重绘</strong>。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>减少 DOM 操作：少交“过路费”、避免过度渲染</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM操作测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时我有一个假需求——我想往 container 元素里写10000句一样的话。如果我这么做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).innerHTML+=<span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有两个明显的可优化点。</p>
<ol>
<li><p><strong>过路费交太多了</strong>。我们每一次循环都调用 DOM 接口重新获取了一次 container 元素，相当于每次循环都交了一次过路费。前后交了 10000 次过路费，但其中 9999 次过路费都可以用<strong>缓存变量</strong>的方式节省下来：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只获取一次container</span></span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  container.innerHTML += <span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不必要的 DOM 更改太多了</strong>。我们的 10000 次循环里，修改了 10000 次 DOM 树。我们前面说过，对 DOM 的修改会引发渲染树的改变、进而去走一个（可能的）回流或重绘的过程，而这个过程的开销是很“贵”的。这么贵的操作，我们竟然重复执行了 N 多次！其实我们可以通过<strong>就事论事</strong>的方式节省下来不必要的渲染：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="keyword">let</span> content = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  <span class="comment">// 先对内容进行操作</span></span><br><span class="line">  content += <span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 内容处理好了,最后再触发DOM的更改</span></span><br><span class="line">container.innerHTML = content</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。</p>
</blockquote>
<p>在我们上面的例子里，字符串变量 content 就扮演着一个 DOM Fragment 的角色。其实无论字符串变量也好，DOM Fragment 也罢，它们本质上都作为脱离了真实 DOM 树的<strong>容器</strong>出现，用于缓存批量化的 DOM 操作。</p>
<p>前面我们直接用 innerHTML 去拼接目标内容，这样做固然有用，但却不够优雅。相比之下，DOM Fragment 可以帮助我们用更加结构化的方式去达成同样的目的，从而在维持性能的同时，保住我们代码的可拓展和可维护性。我们现在用 DOM Fragment 来改写上面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="comment">// 创建一个DOM Fragment对象作为容器</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123;</span><br><span class="line">  <span class="comment">// span此时可以通过DOM API去创建</span></span><br><span class="line">  <span class="keyword">let</span> oSpan = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>)</span><br><span class="line">  oSpan.innerHTML = <span class="string">'我是一个小测试'</span></span><br><span class="line">  <span class="comment">// 像操作真实DOM一样操作DOM Fragment对象</span></span><br><span class="line">  content.appendChild(oSpan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内容处理好了,最后再触发真实DOM的更改</span></span><br><span class="line">container.appendChild(content)</span><br></pre></td></tr></table></figure>

<p>我们运行这段代码，可以得到与前面两种写法相同的运行结果。<br>可以看出，DOM Fragment 对象允许我们像操作真实 DOM 一样去调用各种各样的 DOM API，我们的代码质量因此得到了保证。并且它的身份也非常纯粹：当我们试图将其 append 进真实 DOM 时，它会在乖乖交出自身缓存的所有后代节点后<strong>全身而退</strong>，完美地完成一个容器的使命，而不会出现在真实的 DOM 结构中。这种结构化、干净利落的特性，使得 DOM Fragment 作为经典的性能优化手段大受欢迎，这一点在 jQuery、Vue 等优秀前端框架的源码中均有体现。</p>
<h3 id="渲染的时机"><a href="#渲染的时机" class="headerlink" title="渲染的时机"></a>渲染的时机</h3><p>大家现在思考一个这样的问题：假如我想要在异步任务里进行DOM更新，我该把它包装成micro还是macro呢？</p>
<p>我们先假设它是一个macro任务，比如我在script脚本中用setTimeout来处理它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task是一个用于修改DOM的回调</span></span><br><span class="line">setTimeout(task, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>现在task被推入的macro队列。但因为script脚本本身是一个macro任务，所以本次执行完script脚本之后，下一个步骤就要去处理micro队列了，再往下就去执行了一次render，对不对？</p>
<p>但本次render我的目标task其实并没有执行，想要修改的DOM也没有修改，因此这一次的render其实是一次无效的render。</p>
<p>macro不ok，我们转向micro试试看。我用Promise来把task包装成是一个micro任务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(task)</span><br></pre></td></tr></table></figure>

<p>那么我们结束了对script脚本的执行，是不是紧接着就去处理micro-task队列了？micro-task处理完，DOM 修改好了，紧接着就可以走render流程了——不需要再消耗多余的一次渲染，不需要再等待一轮事件循环，直接为用户呈现最即时的更新结果。</p>
<p>因此，我们更新DOM的时间点，应该尽可能靠近渲染的时机。<strong>当我们需要在异步任务中实现DOM修改时，把它包装成micro任务是相对明智的选择</strong>。</p>
<h3 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h3><p>回流(reflow)</p>
<p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>
<p>会导致回流的操作：</p>
<ul>
<li><p>最“贵”的操作：改变 DOM 元素的几何属性</p>
<p>  这个改变几乎可以说是“牵一发动全身”——当一个DOM元素的几何属性发生变化时，所有和它相关的节点（比如父子节点、兄弟节点等）的几何属性都需要进行重新计算，它会带来巨大的计算量。</p>
<p>  常见的几何属性有 width、height、padding、margin、left、top、border 等等。</p>
</li>
<li><p>“价格适中”的操作：改变 DOM 树的结构</p>
<p>  这里主要指的是节点的增减、移动等操作。浏览器引擎布局的过程，顺序上可以类比于树的前序遍历——它是一个从上到下、从左到右的过程。通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。</p>
</li>
<li><p>最容易被忽略的操作：获取一些特定属性的值</p>
<p>  当你要用到像这样的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 时，你就要注意了！</p>
<p>  “像这样”的属性，到底是像什么样？——这些值有一个共性，就是需要通过<strong>即时计算</strong>得到。因此浏览器为了获取这些值，也会进行回流。</p>
</li>
</ul>
<p>重绘(Repaint)</p>
<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>
<h3 id="如何规避回流与重绘"><a href="#如何规避回流与重绘" class="headerlink" title="如何规避回流与重绘"></a>如何规避回流与重绘</h3><p>CSS</p>
<ul>
<li>避免使用<code>table</code>布局。</li>
<li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li>
<li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li>
</ul>
<p>JavaScript</p>
<ul>
<li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
<li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li>
<li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<h4 id="1-将导致回流与重绘的元素缓存起来，避免频繁改动"><a href="#1-将导致回流与重绘的元素缓存起来，避免频繁改动" class="headerlink" title="1.将导致回流与重绘的元素缓存起来，避免频繁改动"></a>1.将导致回流与重绘的元素缓存起来，避免频繁改动</h4><p>有时我们想要通过多次计算得到一个元素的布局位置，我们可能会这样做：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#el</span> &#123;</span></span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"el"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 获取el元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'el'</span>)</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 这里循环判定比较简单，实际中或许会拓展出比较复杂的判定需求</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span></span><br><span class="line"><span class="actionscript">      el.style.top  = el.offsetTop  + <span class="number">10</span> + <span class="string">"px"</span>;</span></span><br><span class="line"><span class="actionscript">      el.style.left = el.offsetLeft + <span class="number">10</span> + <span class="string">"px"</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样做，每次循环都需要获取多次“敏感属性”，是比较糟糕的。我们可以将其以 JS 变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存offsetLeft与offsetTop的值</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'el'</span>) </span><br><span class="line"><span class="keyword">let</span> offLeft = el.offsetLeft, offTop = el.offsetTop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JS层面进行计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  offLeft += <span class="number">10</span></span><br><span class="line">  offTop  += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性将计算结果应用到DOM上</span></span><br><span class="line">el.style.left = offLeft + <span class="string">"px"</span></span><br><span class="line">el.style.top = offTop  + <span class="string">"px"</span></span><br></pre></td></tr></table></figure>

<h4 id="2-避免逐条改变样式，使用类名去合并样式"><a href="#2-避免逐条改变样式，使用类名去合并样式" class="headerlink" title="2.避免逐条改变样式，使用类名去合并样式"></a>2.避免逐条改变样式，使用类名去合并样式</h4><p>比如我们可以把这段单纯的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure>

<p>优化成一个有 class 加持的样子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.basic_style</span> &#123;</span></span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 200px;</span><br><span class="line">      border: 10px solid red;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span></span><br><span class="line"><span class="actionscript">  container.classList.add(<span class="string">'basic_style'</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前者每次单独操作，都去触发一次渲染树更改，从而导致相应的回流与重绘过程。</p>
<p>合并之后，等于我们将所有的更改一次性发出，用一个style请求解决掉了。</p>
<h4 id="3-将-DOM-“离线”"><a href="#3-将-DOM-“离线”" class="headerlink" title="3.将 DOM “离线”"></a>3.将 DOM “离线”</h4><p>我们上文所说的回流和重绘，都是在“该元素位于页面上”的前提下会发生的。一旦我们给元素设置 display: none，将其从页面上“拿掉”，那么我们的后续操作，将无法触发回流与重绘——这个将元素“拿掉”的操作，就叫做 DOM 离线化。</p>
<p>仍以我们上文的代码片段为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br></pre></td></tr></table></figure>

<p>离线化后就是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.display = <span class="string">'none'</span></span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br><span class="line">container.style.display = <span class="string">'block'</span></span><br></pre></td></tr></table></figure>

<p>有的同学会问，拿掉一个元素再把它放回去，这不也会触发一次昂贵的回流吗？这话不假，但我们把它拿下来了，后续不管我操作这个元素多少次，每一步的操作成本都会非常低。当我们只需要进行很少的 DOM 操作时，DOM 离线化的优越性确实不太明显。一旦操作频繁起来，这“拿掉”和“放回”的开销都将会是非常值得的。</p>
<h4 id="4-Flush-队列：浏览器并没有那么简单"><a href="#4-Flush-队列：浏览器并没有那么简单" class="headerlink" title="4.Flush 队列：浏览器并没有那么简单"></a>4.Flush 队列：浏览器并没有那么简单</h4><p>以我们现在的知识基础，理解上面的优化操作并不难。那么现在我问大家一个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure>

<p>这段代码里，浏览器进行了多少次的回流或重绘呢？</p>
<p>“width、height、border是几何属性，各触发一次回流；color只造成外观的变化，会触发一次重绘。”——如果你立刻这么想了，说明你是个能力不错的同学，认真阅读了前面的内容。那么我们现在立刻跑一跑这段代码，看看浏览器怎么说：</p>
<p><img src="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/35.png" alt></p>
<p>这里为大家截取有“Layout”和“Paint”出镜的片段（这个图是通过 Chrome 的 Performance 面板得到的，后面会教大家用这个东西）。我们看到浏览器只进行了一次回流和一次重绘——和我们想的不一样啊，为啥呢？</p>
<p>因为现代浏览器是很聪明的。浏览器自己也清楚，如果每次 DOM 操作都即时地反馈一次回流或重绘，那么性能上来说是扛不住的。于是它自己缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。因此我们看到，上面就算我们进行了 4 次 DOM 更改，也只触发了一次 Layout 和一次 Paint。</p>
<p>大家这里尤其小心这个“不得已”的时候。前面我们在介绍回流的“导火索”的时候，提到过有一类属性很特别，它们有很强的“即时性”。当我们访问这些属性时，浏览器会为了获得此时此刻的、最准确的属性值，而提前将 flush 队列的任务出队——这就是所谓的“不得已”时刻。具体是哪些属性值，我们已经在“最容易被忽略的操作”这个小模块介绍过了，此处不再赘述。</p>
<h2 id="6-关闭TCP连接"><a href="#6-关闭TCP连接" class="headerlink" title="6.关闭TCP连接"></a>6.关闭TCP连接</h2><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><h3 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS?"></a>什么是DNS?</h3><p>全称 Domain Name System ,即域名系统。</p>
<blockquote>
<p>万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS协议运行在UDP协议之上，使用端口号53。</p>
</blockquote>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>简单的说,通过域名,最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.dnscache.com (域名)  - DNS解析 -&gt; <span class="number">11.222</span><span class="number">.33</span><span class="number">.444</span> (IP地址)</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/08/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>
    <div>
      
    </div>
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/08/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">跨域解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-08 18:11:18" itemprop="dateCreated datePublished" datetime="2020-03-08T18:11:18+08:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-14 11:04:31" itemprop="dateModified" datetime="2020-03-14T11:04:31+08:00">2020-03-14</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>同源策略</strong></p>
<p>同源要求</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/dir2/other.html：同源</span><br><span class="line">http://example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</span><br></pre></td></tr></table></figure>

<p>限制范围</p>
<ul>
<li>cookie、localstorage和 indexDB无法读取</li>
<li>DOM 无法获得</li>
<li>Ajax 请求不能发送</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/08/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>
    <div>
      
    </div>
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/07/DOM%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/07/DOM%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">DOM事件机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-07 22:37:12" itemprop="dateCreated datePublished" datetime="2020-03-07T22:37:12+08:00">2020-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-08 13:21:48" itemprop="dateModified" datetime="2020-03-08T13:21:48+08:00">2020-03-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>面试的时候经常会被问到，事件代理是利用了事件的什么机制？一般我们都会说，是利用了事件冒泡机制，但具体冒泡机制在事件代理的过程了起到了什么关键作用，我想大部分人也是不了解的。静下心来，仔细看了下有关事件和事件代理问题，自己终于找到了合适的答案。</p>
<p>在揭晓答案之前，还是来看一下事件的基本知识</p>
<p>事件操作在项目中使用频繁，jQuery封装了我们对DOM的事件操作，NodeJS中也有 <code>events</code> 这个事件操作模块，几乎各种语言都有事件模型，事件使用频繁，事件模型可以使我们从复杂的业务中抽象出独立的逻辑，跨越模块与模块之间传递数据，以达到类似解耦的概念。</p>
<p>不同的环境有不同的事件模型，在浏览器中，DOM事件模型比较特殊，重温一下DOM事件模型，再来自定义一个事件模型。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/07/DOM%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>
    <div>
      
    </div>
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhou Jun">
      <meta itemprop="description" content="FOCUS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">事件轮询机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-07 11:39:08 / Modified: 22:31:25" itemprop="dateCreated datePublished" datetime="2020-03-07T11:39:08+08:00">2020-03-07</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>15 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h1><p>JavaScript是一门==<strong>单线程</strong>、<strong>非阻塞</strong>==的脚本语言，目的是为了实现与浏览器交互。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/07/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>
    <div>
      
    </div>
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhou Jun"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Zhou Jun</p>
  <div class="site-description" itemprop="description">FOCUS</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dannykbsoul" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dannykbsoul" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:346925954@qq.com" title="E-Mail → mailto:346925954@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/zjsouljoy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;zjsouljoy" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://youtube.com/zhou%20jun" title="YouTube → https:&#x2F;&#x2F;youtube.com&#x2F;zhou jun" rel="noopener" target="_blank"><i class="fa fa-fw fa-youtube"></i>YouTube</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">413k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">6:15</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>
-->

<script>
      var now = new Date(); 
      function createtime() { 
          var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 
          now.setTime(now.getTime()+250); 
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
          document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
      } 
  setInterval("createtime()",250);
  </script>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
